{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/Nginx-Keepalived.png","path":"image/Nginx-Keepalived.png","modified":1,"renderable":0},{"_id":"source/image/classloader.png","path":"image/classloader.png","modified":1,"renderable":0},{"_id":"source/image/F5_ISH_WAS.png","path":"image/F5_ISH_WAS.png","modified":1,"renderable":0},{"_id":"source/image/volatile.png","path":"image/volatile.png","modified":1,"renderable":0},{"_id":"source/image/loadbalancing/Nginx-Keepalived.png","path":"image/loadbalancing/Nginx-Keepalived.png","modified":1,"renderable":0},{"_id":"source/image/loadbalancing/loadbalancing_layer4&7.jpeg","path":"image/loadbalancing/loadbalancing_layer4&7.jpeg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/image/loadbalancing/DNS.png","path":"image/loadbalancing/DNS.png","modified":1,"renderable":0},{"_id":"source/image/loadbalancing/IP.png","path":"image/loadbalancing/IP.png","modified":1,"renderable":0},{"_id":"source/image/loadbalancing/LVS.png","path":"image/loadbalancing/LVS.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"source/image/loadbalancing/F5_ISH_WAS.png","path":"image/loadbalancing/F5_ISH_WAS.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1535966589863},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1535966589863},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1535966589864},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1535966589868},{"_id":"themes/next/.gitignore","hash":"dac14c54600bc26df8547765c5eb057d8f3e3ddb","modified":1542782191694},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1535966589868},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1535966589869},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1535966589869},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1535966589870},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1535966589869},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1535966589870},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1535966589871},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1535966589872},{"_id":"themes/next/_config.yml","hash":"b27ce64b60c5f04db1175811adaef5ee1bce8aaf","modified":1538963841083},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1535966589873},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1535966589917},{"_id":"source/_posts/Stream.md","hash":"a428ec84208682262c013b12368afbb6164c6e2b","modified":1542780367158},{"_id":"source/_posts/hexo.md","hash":"c33297b6c82bf9d96c7c9d8b7ad8652b2041aff3","modified":1536137065123},{"_id":"source/_posts/hello-world.md","hash":"16a7337e47dfecfd808d38c1c6a22d0651f76120","modified":1536109331148},{"_id":"source/_posts/lambda、函数式接口、引用表达式.md","hash":"96548a4e8848ce7a4d790457c8e181174cde99fe","modified":1542792915981},{"_id":"source/_posts/load-balancing.md","hash":"e01a69d0b47adaee4f6026cd922efce456cdc7fc","modified":1539076691820},{"_id":"source/_posts/thread.md","hash":"88711da873f7e4ce24c3823b63779c433d90a64e","modified":1543394878905},{"_id":"source/categories/index.md","hash":"855a3fa417eacda45e5ac8db7d66a8a54d1d631c","modified":1536109365554},{"_id":"source/_posts/对象创建及类的加载机制.md","hash":"1c3b4e234c139ae0e061e4417db23e9d839ecef1","modified":1543394717093},{"_id":"source/_posts/线程池线程模型.md","hash":"d1f90611f742bec86288224f33497d1f68dfd1f9","modified":1540957625043},{"_id":"source/image/Nginx-Keepalived.png","hash":"923d679f2510aeea93a0d4a6c5432b73ef84903d","modified":1535968065649},{"_id":"source/image/classloader.png","hash":"dd269bacf46fd036e7c35d045585d2b7b3639ca4","modified":1543201014175},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1535966589865},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1535966589866},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1535966589867},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1535966589866},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1535966589873},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1535966589874},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1535966589874},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1535966589874},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1535966589875},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1535966589876},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1535966589876},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1535966589877},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1535966589876},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1535966589877},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1535966589878},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1535966589878},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1535966589878},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1535966589879},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1535966589879},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1535966589880},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1535966589882},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1535966589914},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1535966589915},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1535966589914},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1535966589915},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1535966589915},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1535966589916},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1535966589916},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1535966589917},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1535966589918},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1535966590066},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1535966590067},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1535966590067},{"_id":"source/image/F5_ISH_WAS.png","hash":"7824635a6200e4508c13614509c83f67f8e418d8","modified":1535782926720},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589974},{"_id":"source/image/volatile.png","hash":"4f1fae3fdeb807a6030b0b62b9742abc0c5baaa1","modified":1543385097414},{"_id":"source/image/loadbalancing/Nginx-Keepalived.png","hash":"923d679f2510aeea93a0d4a6c5432b73ef84903d","modified":1535968065649},{"_id":"source/image/loadbalancing/loadbalancing_layer4&7.jpeg","hash":"3c6b85cd80d1c3dbedcab17a47a86734bb95d615","modified":1539048683369},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1535966589881},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1535966589882},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1535966589883},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1535966589883},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1535966589885},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1535966589884},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1535966589885},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1535966589885},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1535966589886},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1535966589886},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1535966589888},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1535966589889},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1535966589887},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1535966589889},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1535966589890},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1535966589894},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1535966589895},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1535966589898},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1535966589908},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1535966589908},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1535966589909},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1535966589909},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1535966589910},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1535966589909},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1535966589910},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1535966589919},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1535966589919},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1535966589920},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1535966589920},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1535966589921},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1535966589922},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1535966589921},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1535966589921},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1535966589922},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1535966589974},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1535966589975},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1535966589975},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1535966589976},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1535966589976},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1535966589977},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1535966589977},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1535966589978},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1535966589977},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1535966589978},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1535966589979},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1535966589979},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1535966589979},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535966589980},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1535966589980},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1535966589981},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535966589980},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1535966589981},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1535966589982},{"_id":"source/image/loadbalancing/DNS.png","hash":"9c4690ed18ee0d68f18323c7fb52e6a2c1e56bfc","modified":1539075841622},{"_id":"source/image/loadbalancing/IP.png","hash":"b40e4c7e4d44d90300c9a436e76ba0c8e7f96ffa","modified":1539076332437},{"_id":"source/image/loadbalancing/LVS.png","hash":"8938245784788e780d2f3d6d297cbef3cfcf0562","modified":1539076108060},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589896},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589897},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589972},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589973},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589958},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589958},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535966589959},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1535966589888},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1535966589888},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1535966589891},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1535966589891},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1535966589892},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1535966589893},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1535966589892},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1535966589893},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1535966589894},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1535966589895},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1535966589896},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1535966589897},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1535966589898},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1535966589899},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1535966589899},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1535966589900},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1535966589901},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1535966589900},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1535966589901},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1535966589901},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1535966589902},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1535966589903},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1535966589903},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1535966589902},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1535966589903},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1535966589904},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1535966589904},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1535966589905},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1535966589905},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1535966589906},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1535966589906},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1535966589907},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1535966589906},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1535966589907},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1535966589912},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1535966589912},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1535966589913},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1535966589913},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1535966589957},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1535966589971},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1535966589971},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1535966589972},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1535966589973},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1535966589958},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1535966589959},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1535966589959},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1535966589983},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1535966589983},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1535966589983},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1535966589984},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1535966589984},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1535966589985},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1535966589985},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1535966589986},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1535966589987},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1535966589987},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1535966589988},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1535966589995},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1535966589999},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1535966590000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1535966590001},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1535966590000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1535966590010},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1535966590010},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1535966590011},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1535966590011},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1535966590031},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1535966590014},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1535966590014},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1535966590014},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1535966590015},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1535966590015},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1535966590038},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1535966590038},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1535966590038},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1535966590040},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1535966590039},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1535966590040},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1535966590039},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1535966590040},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1535966590042},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1535966590048},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1535966590048},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1535966590049},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1535966590050},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1535966590050},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1535966590033},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1535966590033},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1535966590036},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1535966590033},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1535966590034},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1535966590036},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1535966590034},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1535966590035},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1535966590037},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1535966590052},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1535966590061},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1535966590052},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1535966590062},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1535966590053},{"_id":"source/image/loadbalancing/F5_ISH_WAS.png","hash":"7824635a6200e4508c13614509c83f67f8e418d8","modified":1535782926720},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1535966590064},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1535966590032},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1535966590065},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1535966590065},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1535966589911},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1535966589911},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1535966589924},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1535966589924},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1535966589925},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1535966589925},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1535966589925},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1535966589934},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1535966589954},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1535966589955},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1535966589945},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1535966589955},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1535966589956},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1535966589955},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1535966589956},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1535966589954},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1535966589961},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1535966589961},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1535966589962},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1535966589962},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1535966589963},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1535966589963},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1535966589963},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1535966589960},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1535966589965},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1535966589965},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1535966589966},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1535966589966},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1535966589967},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1535966589968},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1535966589968},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1535966589969},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1535966589969},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1535966589970},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1535966589970},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1535966589992},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1535966589994},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1535966589995},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1535966589986},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1535966590001},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1535966590002},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1535966590002},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1535966590003},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1535966590004},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1535966590003},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1535966590007},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1535966590008},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1535966590009},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1535966590013},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1535966590012},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1535966590016},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1535966590018},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1535966590017},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1535966590059},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1535966590060},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535966590030},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535966590030},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1535966590063},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1535966589927},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1535966589928},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1535966589928},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1535966589928},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1535966589929},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1535966589929},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1535966589930},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1535966589931},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1535966589930},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1535966589931},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1535966589932},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1535966589932},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1535966589933},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1535966589940},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1535966589933},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1535966589941},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1535966589941},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1535966589942},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1535966589942},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1535966589942},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1535966589943},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1535966589934},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1535966589943},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1535966589935},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1535966589944},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1535966589944},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1535966589935},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1535966589935},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1535966589936},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1535966589936},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1535966589937},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1535966589937},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1535966589937},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1535966589938},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1535966589938},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1535966589939},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1535966589939},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1535966589939},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1535966589940},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1535966589946},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1535966589945},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1535966589946},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1535966589947},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1535966589947},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1535966589948},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1535966589947},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1535966589948},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1535966589949},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1535966589949},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1535966589950},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1535966589950},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1535966589951},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1535966589951},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1535966589951},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1535966589952},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1535966589952},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1535966589953},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1535966589953},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1535966589964},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1535966589964},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1535966589967},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1535966589989},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1535966589991},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1535966589990},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1535966589992},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1535966590006},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1535966590005},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1535966590005},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1535966590006},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1535966590005},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1535966590007},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535966590020},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1535966589993},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1535966589991},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535966590022},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1535966589998},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535966590029},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1535966590058},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1535966590026},{"_id":"public/categories/index.html","hash":"5c011b53544893856b4988bfc3e24874890199bf","modified":1543394976812},{"_id":"public/archives/index.html","hash":"2e13b4d0b215fd8e7c4689739a3cf2b4cd16d7a1","modified":1543394976812},{"_id":"public/archives/2018/index.html","hash":"cb4d1b0bb5c1750b81042c25d93e56da59313ce6","modified":1543394976812},{"_id":"public/archives/2018/09/index.html","hash":"668f0c889ccedfa9f580880202c269bdc6fee589","modified":1543394976812},{"_id":"public/archives/2018/10/index.html","hash":"70d4e8c60fcd372f4a62161e28cbee2c02346185","modified":1543394976812},{"_id":"public/archives/2018/11/index.html","hash":"54d596e8715f4a9ada0060c4f3b931487332c476","modified":1543394976812},{"_id":"public/categories/Others/index.html","hash":"9d9e7fa9f5b118958410d022b5e637e4edd40f8a","modified":1543394976812},{"_id":"public/categories/Java/index.html","hash":"2dead4616f6bdb6d1a214c3f10f9e620a26b9ec3","modified":1543394976812},{"_id":"public/2018/11/28/对象创建及类的加载机制/index.html","hash":"dae578bab80341f65face19f019f7bba29f345c8","modified":1543394976812},{"_id":"public/2018/11/28/thread/index.html","hash":"562dddc5078d562abc600b73753f778d7b229f79","modified":1543394976812},{"_id":"public/2018/11/21/lambda、函数式接口、引用表达式/index.html","hash":"9fda6cd2dc67e76dfe4ac074d2ee542bfb1358e9","modified":1543394976812},{"_id":"public/2018/11/19/Stream/index.html","hash":"d42e1e2c7061ae7ce6402f95899d65d6ed383d4d","modified":1543394976812},{"_id":"public/2018/10/31/线程池线程模型/index.html","hash":"b73f261db8d5767c9807c7add6388d277a195dfb","modified":1543394976812},{"_id":"public/2018/09/04/hexo/index.html","hash":"dd65e6a7822dd393a3fc4f446310a007547af467","modified":1543394976812},{"_id":"public/2018/09/04/load-balancing/index.html","hash":"707cde977c48a9076ae7002db4d849a484740857","modified":1543394976812},{"_id":"public/2018/09/03/hello-world/index.html","hash":"0dd0d0f2d0c4215b8d2c4f010dc0229f1e79b8df","modified":1543394976812},{"_id":"public/index.html","hash":"37326383214de05d2fc173b150e2b7a9e697baab","modified":1543394976813},{"_id":"public/image/Nginx-Keepalived.png","hash":"923d679f2510aeea93a0d4a6c5432b73ef84903d","modified":1543394976813},{"_id":"public/image/loadbalancing/Nginx-Keepalived.png","hash":"923d679f2510aeea93a0d4a6c5432b73ef84903d","modified":1543394976813},{"_id":"public/image/classloader.png","hash":"dd269bacf46fd036e7c35d045585d2b7b3639ca4","modified":1543394976813},{"_id":"public/image/loadbalancing/loadbalancing_layer4&7.jpeg","hash":"3c6b85cd80d1c3dbedcab17a47a86734bb95d615","modified":1543394976813},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1543394976813},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543394976813},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543394976813},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1543394976813},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1543394976813},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1543394976813},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1543394976813},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1543394976813},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1543394976813},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1543394976813},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543394976814},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543394976814},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543394976814},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543394976814},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1543394976814},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1543394977305},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1543394977305},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543394977306},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1543394977306},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1543394977306},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543394977306},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543394977306},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543394977306},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543394977306},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543394977306},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543394977306},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1543394977306},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1543394977306},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1543394977306},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1543394977306},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1543394977306},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543394977307},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1543394977307},{"_id":"public/css/main.css","hash":"ac9ccbafe157d3586496e9d75db8f769ec8364ac","modified":1543394977326},{"_id":"public/image/loadbalancing/LVS.png","hash":"8938245784788e780d2f3d6d297cbef3cfcf0562","modified":1543394977326},{"_id":"public/image/loadbalancing/IP.png","hash":"b40e4c7e4d44d90300c9a436e76ba0c8e7f96ffa","modified":1543394977327},{"_id":"public/image/F5_ISH_WAS.png","hash":"7824635a6200e4508c13614509c83f67f8e418d8","modified":1543394977327},{"_id":"public/image/volatile.png","hash":"4f1fae3fdeb807a6030b0b62b9742abc0c5baaa1","modified":1543394977327},{"_id":"public/image/loadbalancing/F5_ISH_WAS.png","hash":"7824635a6200e4508c13614509c83f67f8e418d8","modified":1543394977328},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543394977328},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543394977328},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1543394977334},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1543394977334},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1543394977334},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1543394977334},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1543394977334},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543394977334},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1543394977334},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1543394977334},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1543394977334},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1543394977334},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1543394977334},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1543394977334},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1543394977335},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1543394977335},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1543394977335},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1543394977335},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1543394977335},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1543394977335},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1543394977335},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1543394977335},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1543394977335},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1543394977335},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1543394977335},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1543394977335},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1543394977336},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543394977336},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1543394977336},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543394977336},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1543394977336},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1543394977337},{"_id":"public/image/loadbalancing/DNS.png","hash":"9c4690ed18ee0d68f18323c7fb52e6a2c1e56bfc","modified":1543394977337},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1543394977337},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543394977337},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1543394977342},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1543394977342},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1543394977342},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1543394977343},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1543394977343},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543394977343},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543394977343},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543394977343},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1543394977343},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1543394977345},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1543394977345},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1543394977347},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543394977348},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1543394977365},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1543394977399},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543394977399},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1543394977400},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543394977400},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1543394977400},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543394977400},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1543394977418},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1543394977418},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1543394977436},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1543394977436},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543394977502},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1543394977503},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1543394977555},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543394977602},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1543394977614},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1543394977618}],"Category":[{"name":"Others","_id":"cjp0xioho0003uog45bwicsbc"},{"name":"Java","_id":"cjp0xiohw0007uog47r08s68z"}],"Data":[],"Page":[{"title":"categories","date":"2018-09-05T01:01:35.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-05 09:01:35\ntype: \"categories\"\n---\n","updated":"2018-09-05T01:02:45.554Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjp0xiohj0001uog4pfttthcd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"hexo","date":"2018-09-04T07:12:28.000Z","_content":"\n# Hexo&GitHub Pages\n\n最初接触github pages之后，一直想尝试搭建一个属于自己的博客网站，根据朋友的博客网站搭建选择了jekyll，但由于选择的模板以及调试问题居多，最后放弃了。偶然间了解到了hexo和vuepress，了解了之后感觉vuepress的模板比较单一，再加上自己不是很了解vuejs（说的好像node.js自己就很懂一样），最后选择了hexo。\n\nhexo是基于node.js的高效的静态站点生成框架，通过Hexo可以轻松地使用Markdown编写文章，除了Markdown本身的语法之外，还可以使用Hexo提供的标签插件来快速的插入特定形式的内容。使用起来非常方便。\n\n从基于Ruby的jekyll，到hexo，再到vuepress。最后选择了hexo。真的是因为用起来简单，但是可能由于自己的电脑git出现了一些问题，导致不能使用hexo deploy，每次都要自己手动构建提交，这还是很麻烦的。\n\n关于如何在使用github pages搭建博客网站，这里就不抄写细节了，能找到一大堆教程，这篇文章主要是记录下我在学习hexo的一些常用命令。\n\ngithub pages是github提供的一个托管的公开网页，会自动将你id.github.io仓库的静态文件自动部署至：https://你的githubID.github.io/ 但由于是公开的仓库，所以大家要注意不要将敏感数据上传。\n\n由于hexo是基于NodeJS的，所以要先安装NodeJS，具体教程有很多，就不做表述了，下面记录了一些搭建博客过程中常用的命令。\n\n# 常用指令\n## 清理\n``` linux\n$ hexo clean\n```\n\n## 构建服务\n``` linux\n$ hexo generate\n```\n也可以缩写为：\n``` linux\n$ hexo g\n```\n\n## 启动服务\n``` linux\n$ hexo server\n```\n缩写：\n``` linux\n$ hexo s\n```\n\n## 部署到远程站点\n``` linux\n$ hexo deploy\n```\n缩写：\n``` linux\n$ hexo d\n```\n\n## 新建博文\n``` linux\n$ hexo new \"post name\"\n```\n缩写：\n``` linux\n$ hexo n \"post name\"\n```\n\n之后会在source/\\_posts下面生成对应的post name.md的文件。\n\n## 创建新主页\n``` linux\n$ hexo new page \"page name\"\n```\n\n之后会在source/\\_posts/page name下面生成对应的page index.md的文件。如：tags、categories的主页，然后再标题头中添加type。\n\n\n# 选择主题\nhttps://hexo.io/themes/\n\n## 替换模板\ngithub上clone各类模板到/themes/xxx\n\n修改_config.yml中的theme: xxx\n\n我个人使用的Theme是NexT，他有三种模式，分别可以在模板的_config.yml中设置schemes。\n``` yml\n# Schemes\nscheme: Muse\n#scheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\n\n\n## 安装hexo git配置插件\nnpm install hexo-deployer-git --save\n配置_config.yml中修改入下：\n``` yml\ndeploy:\n  type: git\n  repo: gti仓库https地址或SSH地址\n  branch: master\n```\n\n目前我是每一次generate之后，将构建好的文件从public中全部复制到本地仓库，然后再上传，其实嘛区别不大，就是自己打两个命令。","source":"_posts/hexo.md","raw":"---\ntitle: hexo\ndate: 2018-09-04 15:12:28\ntags:\ncategories: Others\n---\n\n# Hexo&GitHub Pages\n\n最初接触github pages之后，一直想尝试搭建一个属于自己的博客网站，根据朋友的博客网站搭建选择了jekyll，但由于选择的模板以及调试问题居多，最后放弃了。偶然间了解到了hexo和vuepress，了解了之后感觉vuepress的模板比较单一，再加上自己不是很了解vuejs（说的好像node.js自己就很懂一样），最后选择了hexo。\n\nhexo是基于node.js的高效的静态站点生成框架，通过Hexo可以轻松地使用Markdown编写文章，除了Markdown本身的语法之外，还可以使用Hexo提供的标签插件来快速的插入特定形式的内容。使用起来非常方便。\n\n从基于Ruby的jekyll，到hexo，再到vuepress。最后选择了hexo。真的是因为用起来简单，但是可能由于自己的电脑git出现了一些问题，导致不能使用hexo deploy，每次都要自己手动构建提交，这还是很麻烦的。\n\n关于如何在使用github pages搭建博客网站，这里就不抄写细节了，能找到一大堆教程，这篇文章主要是记录下我在学习hexo的一些常用命令。\n\ngithub pages是github提供的一个托管的公开网页，会自动将你id.github.io仓库的静态文件自动部署至：https://你的githubID.github.io/ 但由于是公开的仓库，所以大家要注意不要将敏感数据上传。\n\n由于hexo是基于NodeJS的，所以要先安装NodeJS，具体教程有很多，就不做表述了，下面记录了一些搭建博客过程中常用的命令。\n\n# 常用指令\n## 清理\n``` linux\n$ hexo clean\n```\n\n## 构建服务\n``` linux\n$ hexo generate\n```\n也可以缩写为：\n``` linux\n$ hexo g\n```\n\n## 启动服务\n``` linux\n$ hexo server\n```\n缩写：\n``` linux\n$ hexo s\n```\n\n## 部署到远程站点\n``` linux\n$ hexo deploy\n```\n缩写：\n``` linux\n$ hexo d\n```\n\n## 新建博文\n``` linux\n$ hexo new \"post name\"\n```\n缩写：\n``` linux\n$ hexo n \"post name\"\n```\n\n之后会在source/\\_posts下面生成对应的post name.md的文件。\n\n## 创建新主页\n``` linux\n$ hexo new page \"page name\"\n```\n\n之后会在source/\\_posts/page name下面生成对应的page index.md的文件。如：tags、categories的主页，然后再标题头中添加type。\n\n\n# 选择主题\nhttps://hexo.io/themes/\n\n## 替换模板\ngithub上clone各类模板到/themes/xxx\n\n修改_config.yml中的theme: xxx\n\n我个人使用的Theme是NexT，他有三种模式，分别可以在模板的_config.yml中设置schemes。\n``` yml\n# Schemes\nscheme: Muse\n#scheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\n\n\n## 安装hexo git配置插件\nnpm install hexo-deployer-git --save\n配置_config.yml中修改入下：\n``` yml\ndeploy:\n  type: git\n  repo: gti仓库https地址或SSH地址\n  branch: master\n```\n\n目前我是每一次generate之后，将构建好的文件从public中全部复制到本地仓库，然后再上传，其实嘛区别不大，就是自己打两个命令。","slug":"hexo","published":1,"updated":"2018-09-05T08:44:25.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiohd0000uog40u12vpsr","content":"<h1 id=\"Hexo-amp-GitHub-Pages\"><a href=\"#Hexo-amp-GitHub-Pages\" class=\"headerlink\" title=\"Hexo&amp;GitHub Pages\"></a>Hexo&amp;GitHub Pages</h1><p>最初接触github pages之后，一直想尝试搭建一个属于自己的博客网站，根据朋友的博客网站搭建选择了jekyll，但由于选择的模板以及调试问题居多，最后放弃了。偶然间了解到了hexo和vuepress，了解了之后感觉vuepress的模板比较单一，再加上自己不是很了解vuejs（说的好像node.js自己就很懂一样），最后选择了hexo。</p>\n<p>hexo是基于node.js的高效的静态站点生成框架，通过Hexo可以轻松地使用Markdown编写文章，除了Markdown本身的语法之外，还可以使用Hexo提供的标签插件来快速的插入特定形式的内容。使用起来非常方便。</p>\n<p>从基于Ruby的jekyll，到hexo，再到vuepress。最后选择了hexo。真的是因为用起来简单，但是可能由于自己的电脑git出现了一些问题，导致不能使用hexo deploy，每次都要自己手动构建提交，这还是很麻烦的。</p>\n<p>关于如何在使用github pages搭建博客网站，这里就不抄写细节了，能找到一大堆教程，这篇文章主要是记录下我在学习hexo的一些常用命令。</p>\n<p>github pages是github提供的一个托管的公开网页，会自动将你id.github.io仓库的静态文件自动部署至：https://你的githubID.github.io/ 但由于是公开的仓库，所以大家要注意不要将敏感数据上传。</p>\n<p>由于hexo是基于NodeJS的，所以要先安装NodeJS，具体教程有很多，就不做表述了，下面记录了一些搭建博客过程中常用的命令。</p>\n<h1 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h1><h2 id=\"清理\"><a href=\"#清理\" class=\"headerlink\" title=\"清理\"></a>清理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建服务\"><a href=\"#构建服务\" class=\"headerlink\" title=\"构建服务\"></a>构建服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>也可以缩写为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>缩写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"部署到远程站点\"><a href=\"#部署到远程站点\" class=\"headerlink\" title=\"部署到远程站点\"></a>部署到远程站点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>缩写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"新建博文\"><a href=\"#新建博文\" class=\"headerlink\" title=\"新建博文\"></a>新建博文</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;post name&quot;</span><br></pre></td></tr></table></figure>\n<p>缩写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo n &quot;post name&quot;</span><br></pre></td></tr></table></figure></p>\n<p>之后会在source/_posts下面生成对应的post name.md的文件。</p>\n<h2 id=\"创建新主页\"><a href=\"#创建新主页\" class=\"headerlink\" title=\"创建新主页\"></a>创建新主页</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &quot;page name&quot;</span><br></pre></td></tr></table></figure>\n<p>之后会在source/_posts/page name下面生成对应的page index.md的文件。如：tags、categories的主页，然后再标题头中添加type。</p>\n<h1 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h1><p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a></p>\n<h2 id=\"替换模板\"><a href=\"#替换模板\" class=\"headerlink\" title=\"替换模板\"></a>替换模板</h2><p>github上clone各类模板到/themes/xxx</p>\n<p>修改_config.yml中的theme: xxx</p>\n<p>我个人使用的Theme是NexT，他有三种模式，分别可以在模板的_config.yml中设置schemes。<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Schemes</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Muse</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Mist</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Pisces</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Gemini</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装hexo-git配置插件\"><a href=\"#安装hexo-git配置插件\" class=\"headerlink\" title=\"安装hexo git配置插件\"></a>安装hexo git配置插件</h2><p>npm install hexo-deployer-git –save<br>配置_config.yml中修改入下：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">gti仓库https地址或SSH地址</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure></p>\n<p>目前我是每一次generate之后，将构建好的文件从public中全部复制到本地仓库，然后再上传，其实嘛区别不大，就是自己打两个命令。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hexo-amp-GitHub-Pages\"><a href=\"#Hexo-amp-GitHub-Pages\" class=\"headerlink\" title=\"Hexo&amp;GitHub Pages\"></a>Hexo&amp;GitHub Pages</h1><p>最初接触github pages之后，一直想尝试搭建一个属于自己的博客网站，根据朋友的博客网站搭建选择了jekyll，但由于选择的模板以及调试问题居多，最后放弃了。偶然间了解到了hexo和vuepress，了解了之后感觉vuepress的模板比较单一，再加上自己不是很了解vuejs（说的好像node.js自己就很懂一样），最后选择了hexo。</p>\n<p>hexo是基于node.js的高效的静态站点生成框架，通过Hexo可以轻松地使用Markdown编写文章，除了Markdown本身的语法之外，还可以使用Hexo提供的标签插件来快速的插入特定形式的内容。使用起来非常方便。</p>\n<p>从基于Ruby的jekyll，到hexo，再到vuepress。最后选择了hexo。真的是因为用起来简单，但是可能由于自己的电脑git出现了一些问题，导致不能使用hexo deploy，每次都要自己手动构建提交，这还是很麻烦的。</p>\n<p>关于如何在使用github pages搭建博客网站，这里就不抄写细节了，能找到一大堆教程，这篇文章主要是记录下我在学习hexo的一些常用命令。</p>\n<p>github pages是github提供的一个托管的公开网页，会自动将你id.github.io仓库的静态文件自动部署至：https://你的githubID.github.io/ 但由于是公开的仓库，所以大家要注意不要将敏感数据上传。</p>\n<p>由于hexo是基于NodeJS的，所以要先安装NodeJS，具体教程有很多，就不做表述了，下面记录了一些搭建博客过程中常用的命令。</p>\n<h1 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h1><h2 id=\"清理\"><a href=\"#清理\" class=\"headerlink\" title=\"清理\"></a>清理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h2 id=\"构建服务\"><a href=\"#构建服务\" class=\"headerlink\" title=\"构建服务\"></a>构建服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>也可以缩写为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>缩写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"部署到远程站点\"><a href=\"#部署到远程站点\" class=\"headerlink\" title=\"部署到远程站点\"></a>部署到远程站点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>缩写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"新建博文\"><a href=\"#新建博文\" class=\"headerlink\" title=\"新建博文\"></a>新建博文</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;post name&quot;</span><br></pre></td></tr></table></figure>\n<p>缩写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo n &quot;post name&quot;</span><br></pre></td></tr></table></figure></p>\n<p>之后会在source/_posts下面生成对应的post name.md的文件。</p>\n<h2 id=\"创建新主页\"><a href=\"#创建新主页\" class=\"headerlink\" title=\"创建新主页\"></a>创建新主页</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page &quot;page name&quot;</span><br></pre></td></tr></table></figure>\n<p>之后会在source/_posts/page name下面生成对应的page index.md的文件。如：tags、categories的主页，然后再标题头中添加type。</p>\n<h1 id=\"选择主题\"><a href=\"#选择主题\" class=\"headerlink\" title=\"选择主题\"></a>选择主题</h1><p><a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/</a></p>\n<h2 id=\"替换模板\"><a href=\"#替换模板\" class=\"headerlink\" title=\"替换模板\"></a>替换模板</h2><p>github上clone各类模板到/themes/xxx</p>\n<p>修改_config.yml中的theme: xxx</p>\n<p>我个人使用的Theme是NexT，他有三种模式，分别可以在模板的_config.yml中设置schemes。<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Schemes</span></span><br><span class=\"line\"><span class=\"attr\">scheme:</span> <span class=\"string\">Muse</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Mist</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Pisces</span></span><br><span class=\"line\"><span class=\"comment\">#scheme: Gemini</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"安装hexo-git配置插件\"><a href=\"#安装hexo-git配置插件\" class=\"headerlink\" title=\"安装hexo git配置插件\"></a>安装hexo git配置插件</h2><p>npm install hexo-deployer-git –save<br>配置_config.yml中修改入下：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"string\">gti仓库https地址或SSH地址</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure></p>\n<p>目前我是每一次generate之后，将构建好的文件从public中全部复制到本地仓库，然后再上传，其实嘛区别不大，就是自己打两个命令。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntags:\ncategories: Others\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-09-03T09:02:29.498Z","updated":"2018-09-05T01:02:11.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiohl0002uog47kg0ik59","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Java Thread","date":"2018-11-28T06:12:17.000Z","_content":"\n> 本篇是在对线程基础进行学习时的概念知识的随笔\n\n## 线程\n每一个java进程，都伴随着N个线程进行执行，入口main函数为主线程。\n\n## 线程的状态\n线程启动使用的start()方法，但是启动的时候，线程将进入一种就绪状态，现在并没有立刻执行。\n\n进入到就绪状态之后就需要等待进行资源调度，当某一个线程的调度成功之后，则回进入到运行状态（run方法）\n\n但是所有的线程不可能一致执行下去，中间需要产生一些暂停的状态，例如：某个线程执行一段时间之后就需要让出资源，这个线程将会进入阻塞状态\n\nrun()方法执行结束后，实际该线程的主要任务也就结束了，此时将会直接进入到停止状态\n\n1. start() 就绪\n2. run() 运行状态\n3. 阻塞状态\n4. 停止状态\n\n注：线程的停止等相关方法在jdk1.2就已经废弃，如果想停止线程应当自定义编写线程推出的条件对线程进行退出，而不是外部的暴力退出线程。\n\n## 线程休眠\n希望一个线程可以暂缓执行，进行休眠的时候可能会产生中断异常\n\n休眠的特点是可以自动实现线程的唤醒，以继续进行后续的处理，但休眠也是有先后顺序的\n\n## 线程中断\n所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理\n* 判断线程是否被中断：public static boolean interrupted()\n* 中断线程执行：public void interrupt()\n\ninterrupt()不能中断在运行中的线程，它只能改变中断状态\n\n## 线程的强制执行\n当满足于某些条件之后，某一个线程对象可以一直独占资源，一直到该线程的程序执行结束\n\n通过需要进行join的线程对象调用\n* public final void join() throws InterruptedException \n  \n## 线程的礼让\n将资源让出给其他线程先执行\n* public static native void yield();\n\n## 线程优先级\n* 线程优先级越高，越有可能先执行（先抢占到资源），在Thread类中针对于优先级有两个方法：\n* 设置优先级：public final void setPriority(int newPriority)\n* 获取优先级：public final void getPriority()\n* 优先级常量，分别为低、中、高优先级\n```java\n    /**\n     * The minimum priority that a thread can have.\n     */\n    public final static int MIN_PRIORITY = 1;\n\n   /**\n     * The default priority that is assigned to a thread.\n     */\n    public final static int NORM_PRIORITY = 5;\n\n    /**\n     * The maximum priority that a thread can have.\n     */\n    public final static int MAX_PRIORITY = 10;\n```\n主线程、子线程默认的优先级为NORM_PRIORITY，中优先级\n\n设置高优先级后，该线程有可能，但并不是必定会优先执行\n\n\n## 线程同步问题\n\n* 关键字：synchronized，同步代码块、同步方法中只允许一个线程执行，大都使用同步方法。\n```java\nsynchronized(同步对象){\n    同步代码操作;\n}\n```\n一般要进行同步对象处理的时候可以采用当前对象this进行同步。\n\n同步会造成程序性能的整体降低\n\n\n## 线程死锁\n\n死锁造成的主要原因是因为彼此都在互相等待，等待对方先让出资源。\n\n若干个线程访问同一资源时一定要进行同步处理，而过多的同步处理可能会造成死锁。\n\n如何避免死锁：\n\n    避免在对象的同步方法种调用其他对象的同步方法\n\n    死锁的根本原因1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。要采取各种方法来杜绝这种可能性。\n\n\n一旦我们在一个同步方法中，或者说在一个锁的保护的范围中，调用了其它对象的方法时，就要十而分的小心：\n\n1）如果其它对象的这个方法会消耗比较长的时间，那么就会导致锁被我们持有了很长的时间；\n\n2）如果其它对象的这个方法是一个同步方法，那么就要注意避免发生死锁的可能性了；\n\n## 守护线程\n守护线程的生命周期紧随用户线程，JVM最大的守护线程是GC线程，程序执行中GC线程将一直存在，如果程序执行完毕，GC线程也会消失\n\n* 设置为当前线程的守护线程 public final void setDaemon(boolean on)\n\n* 是否是守护线程 public final boolean isDaemon()\n\n## volatile关键字\n用于修饰关键字，表示该属性为直接属性操作，不进行副本拷贝处理。\n一些文档和书中错误的讲其描写为同步属性。\n\n在正常进行变量处理的时候一般会经历以下几个步骤：\n1. 获取变量原有的数据内容副本\n2. 利用副本为变量进行数学计算\n3. 将计算后的变量保存到原始空间之中\n\n如果加上了volatile关键字，表示不使用副本，直接操作原始变量，相当于节约了拷贝副本\n\n![volatile-photo](/image/volatile.png)\n\nvolatile与synchronized的区别：\n\n    volatile只能描述属性，而synchronized可以用于代码块与方法。\n    volatile无法描述属性进行同步处理，只是一种直接内存的处理，避免了副本处理。\n\n对于volatile的详细解释，可以参考：https://www.ibm.com/developerworks/cn/java/j-jtp06197.html","source":"_posts/thread.md","raw":"---\ntitle: Java Thread\ndate: 2018-11-28 14:12:17\ntags:\ncategories: Java\n---\n\n> 本篇是在对线程基础进行学习时的概念知识的随笔\n\n## 线程\n每一个java进程，都伴随着N个线程进行执行，入口main函数为主线程。\n\n## 线程的状态\n线程启动使用的start()方法，但是启动的时候，线程将进入一种就绪状态，现在并没有立刻执行。\n\n进入到就绪状态之后就需要等待进行资源调度，当某一个线程的调度成功之后，则回进入到运行状态（run方法）\n\n但是所有的线程不可能一致执行下去，中间需要产生一些暂停的状态，例如：某个线程执行一段时间之后就需要让出资源，这个线程将会进入阻塞状态\n\nrun()方法执行结束后，实际该线程的主要任务也就结束了，此时将会直接进入到停止状态\n\n1. start() 就绪\n2. run() 运行状态\n3. 阻塞状态\n4. 停止状态\n\n注：线程的停止等相关方法在jdk1.2就已经废弃，如果想停止线程应当自定义编写线程推出的条件对线程进行退出，而不是外部的暴力退出线程。\n\n## 线程休眠\n希望一个线程可以暂缓执行，进行休眠的时候可能会产生中断异常\n\n休眠的特点是可以自动实现线程的唤醒，以继续进行后续的处理，但休眠也是有先后顺序的\n\n## 线程中断\n所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理\n* 判断线程是否被中断：public static boolean interrupted()\n* 中断线程执行：public void interrupt()\n\ninterrupt()不能中断在运行中的线程，它只能改变中断状态\n\n## 线程的强制执行\n当满足于某些条件之后，某一个线程对象可以一直独占资源，一直到该线程的程序执行结束\n\n通过需要进行join的线程对象调用\n* public final void join() throws InterruptedException \n  \n## 线程的礼让\n将资源让出给其他线程先执行\n* public static native void yield();\n\n## 线程优先级\n* 线程优先级越高，越有可能先执行（先抢占到资源），在Thread类中针对于优先级有两个方法：\n* 设置优先级：public final void setPriority(int newPriority)\n* 获取优先级：public final void getPriority()\n* 优先级常量，分别为低、中、高优先级\n```java\n    /**\n     * The minimum priority that a thread can have.\n     */\n    public final static int MIN_PRIORITY = 1;\n\n   /**\n     * The default priority that is assigned to a thread.\n     */\n    public final static int NORM_PRIORITY = 5;\n\n    /**\n     * The maximum priority that a thread can have.\n     */\n    public final static int MAX_PRIORITY = 10;\n```\n主线程、子线程默认的优先级为NORM_PRIORITY，中优先级\n\n设置高优先级后，该线程有可能，但并不是必定会优先执行\n\n\n## 线程同步问题\n\n* 关键字：synchronized，同步代码块、同步方法中只允许一个线程执行，大都使用同步方法。\n```java\nsynchronized(同步对象){\n    同步代码操作;\n}\n```\n一般要进行同步对象处理的时候可以采用当前对象this进行同步。\n\n同步会造成程序性能的整体降低\n\n\n## 线程死锁\n\n死锁造成的主要原因是因为彼此都在互相等待，等待对方先让出资源。\n\n若干个线程访问同一资源时一定要进行同步处理，而过多的同步处理可能会造成死锁。\n\n如何避免死锁：\n\n    避免在对象的同步方法种调用其他对象的同步方法\n\n    死锁的根本原因1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。要采取各种方法来杜绝这种可能性。\n\n\n一旦我们在一个同步方法中，或者说在一个锁的保护的范围中，调用了其它对象的方法时，就要十而分的小心：\n\n1）如果其它对象的这个方法会消耗比较长的时间，那么就会导致锁被我们持有了很长的时间；\n\n2）如果其它对象的这个方法是一个同步方法，那么就要注意避免发生死锁的可能性了；\n\n## 守护线程\n守护线程的生命周期紧随用户线程，JVM最大的守护线程是GC线程，程序执行中GC线程将一直存在，如果程序执行完毕，GC线程也会消失\n\n* 设置为当前线程的守护线程 public final void setDaemon(boolean on)\n\n* 是否是守护线程 public final boolean isDaemon()\n\n## volatile关键字\n用于修饰关键字，表示该属性为直接属性操作，不进行副本拷贝处理。\n一些文档和书中错误的讲其描写为同步属性。\n\n在正常进行变量处理的时候一般会经历以下几个步骤：\n1. 获取变量原有的数据内容副本\n2. 利用副本为变量进行数学计算\n3. 将计算后的变量保存到原始空间之中\n\n如果加上了volatile关键字，表示不使用副本，直接操作原始变量，相当于节约了拷贝副本\n\n![volatile-photo](/image/volatile.png)\n\nvolatile与synchronized的区别：\n\n    volatile只能描述属性，而synchronized可以用于代码块与方法。\n    volatile无法描述属性进行同步处理，只是一种直接内存的处理，避免了副本处理。\n\n对于volatile的详细解释，可以参考：https://www.ibm.com/developerworks/cn/java/j-jtp06197.html","slug":"thread","published":1,"updated":"2018-11-28T08:47:58.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiohq0004uog47hs634lt","content":"<blockquote>\n<p>本篇是在对线程基础进行学习时的概念知识的随笔</p>\n</blockquote>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>每一个java进程，都伴随着N个线程进行执行，入口main函数为主线程。</p>\n<h2 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h2><p>线程启动使用的start()方法，但是启动的时候，线程将进入一种就绪状态，现在并没有立刻执行。</p>\n<p>进入到就绪状态之后就需要等待进行资源调度，当某一个线程的调度成功之后，则回进入到运行状态（run方法）</p>\n<p>但是所有的线程不可能一致执行下去，中间需要产生一些暂停的状态，例如：某个线程执行一段时间之后就需要让出资源，这个线程将会进入阻塞状态</p>\n<p>run()方法执行结束后，实际该线程的主要任务也就结束了，此时将会直接进入到停止状态</p>\n<ol>\n<li>start() 就绪</li>\n<li>run() 运行状态</li>\n<li>阻塞状态</li>\n<li>停止状态</li>\n</ol>\n<p>注：线程的停止等相关方法在jdk1.2就已经废弃，如果想停止线程应当自定义编写线程推出的条件对线程进行退出，而不是外部的暴力退出线程。</p>\n<h2 id=\"线程休眠\"><a href=\"#线程休眠\" class=\"headerlink\" title=\"线程休眠\"></a>线程休眠</h2><p>希望一个线程可以暂缓执行，进行休眠的时候可能会产生中断异常</p>\n<p>休眠的特点是可以自动实现线程的唤醒，以继续进行后续的处理，但休眠也是有先后顺序的</p>\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h2><p>所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理</p>\n<ul>\n<li>判断线程是否被中断：public static boolean interrupted()</li>\n<li>中断线程执行：public void interrupt()</li>\n</ul>\n<p>interrupt()不能中断在运行中的线程，它只能改变中断状态</p>\n<h2 id=\"线程的强制执行\"><a href=\"#线程的强制执行\" class=\"headerlink\" title=\"线程的强制执行\"></a>线程的强制执行</h2><p>当满足于某些条件之后，某一个线程对象可以一直独占资源，一直到该线程的程序执行结束</p>\n<p>通过需要进行join的线程对象调用</p>\n<ul>\n<li>public final void join() throws InterruptedException </li>\n</ul>\n<h2 id=\"线程的礼让\"><a href=\"#线程的礼让\" class=\"headerlink\" title=\"线程的礼让\"></a>线程的礼让</h2><p>将资源让出给其他线程先执行</p>\n<ul>\n<li>public static native void yield();</li>\n</ul>\n<h2 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h2><ul>\n<li>线程优先级越高，越有可能先执行（先抢占到资源），在Thread类中针对于优先级有两个方法：</li>\n<li>设置优先级：public final void setPriority(int newPriority)</li>\n<li>获取优先级：public final void getPriority()</li>\n<li>优先级常量，分别为低、中、高优先级<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The minimum priority that a thread can have.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MIN_PRIORITY = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The default priority that is assigned to a thread.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> NORM_PRIORITY = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The maximum priority that a thread can have.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_PRIORITY = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主线程、子线程默认的优先级为NORM_PRIORITY，中优先级</p>\n<p>设置高优先级后，该线程有可能，但并不是必定会优先执行</p>\n<h2 id=\"线程同步问题\"><a href=\"#线程同步问题\" class=\"headerlink\" title=\"线程同步问题\"></a>线程同步问题</h2><ul>\n<li>关键字：synchronized，同步代码块、同步方法中只允许一个线程执行，大都使用同步方法。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(同步对象)&#123;</span><br><span class=\"line\">    同步代码操作;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>一般要进行同步对象处理的时候可以采用当前对象this进行同步。</p>\n<p>同步会造成程序性能的整体降低</p>\n<h2 id=\"线程死锁\"><a href=\"#线程死锁\" class=\"headerlink\" title=\"线程死锁\"></a>线程死锁</h2><p>死锁造成的主要原因是因为彼此都在互相等待，等待对方先让出资源。</p>\n<p>若干个线程访问同一资源时一定要进行同步处理，而过多的同步处理可能会造成死锁。</p>\n<p>如何避免死锁：</p>\n<pre><code>避免在对象的同步方法种调用其他对象的同步方法\n\n死锁的根本原因1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。要采取各种方法来杜绝这种可能性。\n</code></pre><p>一旦我们在一个同步方法中，或者说在一个锁的保护的范围中，调用了其它对象的方法时，就要十而分的小心：</p>\n<p>1）如果其它对象的这个方法会消耗比较长的时间，那么就会导致锁被我们持有了很长的时间；</p>\n<p>2）如果其它对象的这个方法是一个同步方法，那么就要注意避免发生死锁的可能性了；</p>\n<h2 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h2><p>守护线程的生命周期紧随用户线程，JVM最大的守护线程是GC线程，程序执行中GC线程将一直存在，如果程序执行完毕，GC线程也会消失</p>\n<ul>\n<li><p>设置为当前线程的守护线程 public final void setDaemon(boolean on)</p>\n</li>\n<li><p>是否是守护线程 public final boolean isDaemon()</p>\n</li>\n</ul>\n<h2 id=\"volatile关键字\"><a href=\"#volatile关键字\" class=\"headerlink\" title=\"volatile关键字\"></a>volatile关键字</h2><p>用于修饰关键字，表示该属性为直接属性操作，不进行副本拷贝处理。<br>一些文档和书中错误的讲其描写为同步属性。</p>\n<p>在正常进行变量处理的时候一般会经历以下几个步骤：</p>\n<ol>\n<li>获取变量原有的数据内容副本</li>\n<li>利用副本为变量进行数学计算</li>\n<li>将计算后的变量保存到原始空间之中</li>\n</ol>\n<p>如果加上了volatile关键字，表示不使用副本，直接操作原始变量，相当于节约了拷贝副本</p>\n<p><img src=\"/image/volatile.png\" alt=\"volatile-photo\"></p>\n<p>volatile与synchronized的区别：</p>\n<pre><code>volatile只能描述属性，而synchronized可以用于代码块与方法。\nvolatile无法描述属性进行同步处理，只是一种直接内存的处理，避免了副本处理。\n</code></pre><p>对于volatile的详细解释，可以参考：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp06197.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇是在对线程基础进行学习时的概念知识的随笔</p>\n</blockquote>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>每一个java进程，都伴随着N个线程进行执行，入口main函数为主线程。</p>\n<h2 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h2><p>线程启动使用的start()方法，但是启动的时候，线程将进入一种就绪状态，现在并没有立刻执行。</p>\n<p>进入到就绪状态之后就需要等待进行资源调度，当某一个线程的调度成功之后，则回进入到运行状态（run方法）</p>\n<p>但是所有的线程不可能一致执行下去，中间需要产生一些暂停的状态，例如：某个线程执行一段时间之后就需要让出资源，这个线程将会进入阻塞状态</p>\n<p>run()方法执行结束后，实际该线程的主要任务也就结束了，此时将会直接进入到停止状态</p>\n<ol>\n<li>start() 就绪</li>\n<li>run() 运行状态</li>\n<li>阻塞状态</li>\n<li>停止状态</li>\n</ol>\n<p>注：线程的停止等相关方法在jdk1.2就已经废弃，如果想停止线程应当自定义编写线程推出的条件对线程进行退出，而不是外部的暴力退出线程。</p>\n<h2 id=\"线程休眠\"><a href=\"#线程休眠\" class=\"headerlink\" title=\"线程休眠\"></a>线程休眠</h2><p>希望一个线程可以暂缓执行，进行休眠的时候可能会产生中断异常</p>\n<p>休眠的特点是可以自动实现线程的唤醒，以继续进行后续的处理，但休眠也是有先后顺序的</p>\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a>线程中断</h2><p>所有正在执行的线程都是可以被中断的，中断线程必须进行异常的处理</p>\n<ul>\n<li>判断线程是否被中断：public static boolean interrupted()</li>\n<li>中断线程执行：public void interrupt()</li>\n</ul>\n<p>interrupt()不能中断在运行中的线程，它只能改变中断状态</p>\n<h2 id=\"线程的强制执行\"><a href=\"#线程的强制执行\" class=\"headerlink\" title=\"线程的强制执行\"></a>线程的强制执行</h2><p>当满足于某些条件之后，某一个线程对象可以一直独占资源，一直到该线程的程序执行结束</p>\n<p>通过需要进行join的线程对象调用</p>\n<ul>\n<li>public final void join() throws InterruptedException </li>\n</ul>\n<h2 id=\"线程的礼让\"><a href=\"#线程的礼让\" class=\"headerlink\" title=\"线程的礼让\"></a>线程的礼让</h2><p>将资源让出给其他线程先执行</p>\n<ul>\n<li>public static native void yield();</li>\n</ul>\n<h2 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h2><ul>\n<li>线程优先级越高，越有可能先执行（先抢占到资源），在Thread类中针对于优先级有两个方法：</li>\n<li>设置优先级：public final void setPriority(int newPriority)</li>\n<li>获取优先级：public final void getPriority()</li>\n<li>优先级常量，分别为低、中、高优先级<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The minimum priority that a thread can have.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MIN_PRIORITY = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The default priority that is assigned to a thread.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> NORM_PRIORITY = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * The maximum priority that a thread can have.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_PRIORITY = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主线程、子线程默认的优先级为NORM_PRIORITY，中优先级</p>\n<p>设置高优先级后，该线程有可能，但并不是必定会优先执行</p>\n<h2 id=\"线程同步问题\"><a href=\"#线程同步问题\" class=\"headerlink\" title=\"线程同步问题\"></a>线程同步问题</h2><ul>\n<li>关键字：synchronized，同步代码块、同步方法中只允许一个线程执行，大都使用同步方法。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(同步对象)&#123;</span><br><span class=\"line\">    同步代码操作;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>一般要进行同步对象处理的时候可以采用当前对象this进行同步。</p>\n<p>同步会造成程序性能的整体降低</p>\n<h2 id=\"线程死锁\"><a href=\"#线程死锁\" class=\"headerlink\" title=\"线程死锁\"></a>线程死锁</h2><p>死锁造成的主要原因是因为彼此都在互相等待，等待对方先让出资源。</p>\n<p>若干个线程访问同一资源时一定要进行同步处理，而过多的同步处理可能会造成死锁。</p>\n<p>如何避免死锁：</p>\n<pre><code>避免在对象的同步方法种调用其他对象的同步方法\n\n死锁的根本原因1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。要采取各种方法来杜绝这种可能性。\n</code></pre><p>一旦我们在一个同步方法中，或者说在一个锁的保护的范围中，调用了其它对象的方法时，就要十而分的小心：</p>\n<p>1）如果其它对象的这个方法会消耗比较长的时间，那么就会导致锁被我们持有了很长的时间；</p>\n<p>2）如果其它对象的这个方法是一个同步方法，那么就要注意避免发生死锁的可能性了；</p>\n<h2 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h2><p>守护线程的生命周期紧随用户线程，JVM最大的守护线程是GC线程，程序执行中GC线程将一直存在，如果程序执行完毕，GC线程也会消失</p>\n<ul>\n<li><p>设置为当前线程的守护线程 public final void setDaemon(boolean on)</p>\n</li>\n<li><p>是否是守护线程 public final boolean isDaemon()</p>\n</li>\n</ul>\n<h2 id=\"volatile关键字\"><a href=\"#volatile关键字\" class=\"headerlink\" title=\"volatile关键字\"></a>volatile关键字</h2><p>用于修饰关键字，表示该属性为直接属性操作，不进行副本拷贝处理。<br>一些文档和书中错误的讲其描写为同步属性。</p>\n<p>在正常进行变量处理的时候一般会经历以下几个步骤：</p>\n<ol>\n<li>获取变量原有的数据内容副本</li>\n<li>利用副本为变量进行数学计算</li>\n<li>将计算后的变量保存到原始空间之中</li>\n</ol>\n<p>如果加上了volatile关键字，表示不使用副本，直接操作原始变量，相当于节约了拷贝副本</p>\n<p><img src=\"/image/volatile.png\" alt=\"volatile-photo\"></p>\n<p>volatile与synchronized的区别：</p>\n<pre><code>volatile只能描述属性，而synchronized可以用于代码块与方法。\nvolatile无法描述属性进行同步处理，只是一种直接内存的处理，避免了副本处理。\n</code></pre><p>对于volatile的详细解释，可以参考：<a href=\"https://www.ibm.com/developerworks/cn/java/j-jtp06197.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></p>\n"},{"title":"对象的创建及类的加载机制","date":"2018-11-28T06:20:10.000Z","_content":"\n> 本篇是最近在学习JVM相关知识时的随笔，虽然我们现在大都通过Spring容器进行对象的实例化，但本身应当了解对象的各类创建方式，以及最基本的Class文件如何通过何种方式加载到内存中生成对应的对象的。\n\n## 类加载的各种几种方式和区别\n\n1. new\n2. Class.forName\n3. class.newInstance\n4. ClassLoader\n\n## ClassLoader\n\n类加载器主要分为两类，一类是JDK默认提供的，一类是用户自定义的。 \n\n![classloader-photo](/image/classloader.png)\n\n### JDK 默认提供三种类加载器：\n\n* Bootstrap ClassLoader 启动类加载器\n\n    每次执行java命令时都会使用该加载器为虚拟机加载核心类。该加载器是由nativecode实现，而不是Java代码，加载类的路径为<JAVA_HOME>/jre/lib。特别的 <JAVA_HOME>/jre/lib/rt.jar中包含了sun.misc.Launcher 类， 而sun.misc.Launcher$ExtClassLoader和sun.misc.Launcher$AppClassLoader都是 sun.misc.Launcher的内部类，所以拓展类加载器和系统类加载器都是由启动类加载器加载的。\n\n* Extension ClassLoader, 拓展类加载器：\n\n    用于加载拓展库中的类。拓展库路径为<JAVA_HOME>/jre/lib/ext/。实现类为sun.misc.Launcher$ExtClassLoader\n\n* System ClassLoader 系统类加载器：\n\n    用于加载CLASSPATH中的类。实现类为sun.misc.Launcher$AppClassLoader\n\n### 用户自定义的类加载器\n\n* Custom ClassLoader, 一般都是java.lang.ClassLoder的子类\n\n    正统的类加载机制是基于双亲委派的，也就是当调用类加载器加载类时，首先将加载任务委派给双亲，若双亲无法加载成功时，自己才进行类加载。\n\n    在实例化一个新的类加载器时，我们可以为其指定一个parent，即双亲，若未显式指定，则System ClassLoader就作为默认双亲。\n\n    具体的说，类加载任务是由ClassLoader的loadClass() 方法来执行的，他会按照以下顺序加载类：\n\n    通过findLoadedClass() 看该类是否已经被加载。该方法为nativecode 实现，若已加载则返回。\n    \n    若未加载则委派给双亲，parent.loadClass()，若成功则返回。\n    \n    若未成功，则调用 findClass() 方法加载类。java.lang.ClassLoader中该方法只是简单的抛出一个ClassNotFoundException所以，自定义的ClassLoader都需要 Override findClass() 方法。\n\n### ClassLoader的API\n\n#### java.lang.ClassLoader\n\n* ClassLoader 是一个抽象类。\n* 待加载的类必须用The Java™Language Specification 定义的全类名，全类名的定义请查阅The Form of a Binary。\n* 给定一个全类名，类加载器应该去定位该类所在的位置。通用的策略是将全类名转换为类文件路径，然后通过类文件路径在文件系统中定位。\n* 每一个加载到内存的类都由一个Class对象来表示，每一个Class对象都有一个指向加载该类的类加载器的引用。但是数组的Class对象是由Java运行时环境创建的，通过 Class.getClassLoader()方法返回的是数组元素的类加载器，若数组元素是基本类型，则返回null，若类是由Bootstrap ClassLoader加载的话也是返回null。\n* ClassLoader默认支持并行加载，但是其子类必须调用ClassLoader.registerAsParallelCapable()来启用并行加载\n* 一般来说,JVM从本地文件系统加载类的行为是与平台有关的。\n* defineClass() 方法可以将字节流转换成一个Class对象。然后调用Class.newInstance()来创建类的实例\n\n```java\npublic static void main(String[] args) {\n    // Object 类在 <java_home>/jre/lib/rt.jar 中，\n    // 由 Bootstrap ClassLoader 加载，由于该类加载器是由 native code 编写\n    // 所以输出为 null\n    Object[] objects = new Object[5];\n    System.out.println();\n    System.out.println(objects.getClass().getClassLoader());\n\n    // ZipFileAttributes 类在 <java_home>/jre/lib/ext/zipfs.jar 中，\n    // 由 Extension ClassLoader 加载，\n    // 输出为  sun.misc.Launcher$ExtClassLoader@4b67cf4d\n    ZipFileAttributes[] attributes = new ZipFileAttributes[5];\n    System.out.println();\n    System.out.println(attributes.getClass().getClassLoader());\n\n    // Main 类是自定义的类，\n    // 默认由 System ClassLoader 加载，\n    // 输出为 sun.misc.Launcher$AppClassLoader@18b4aac2\n    Main[] array = new Main[5];\n    array[0] = new Main();\n    System.out.println();\n    System.out.println(array.getClass().getClassLoader());\n}\n```\n\n#### java.security.SecureClassLoader\n增加了一层权限验证，因为关注点不在安全，所以暂不讨论。\n\n#### java.net.URLClassLoader\n该类加载器用来加载URL指定的JAR文件或目录中的类和资源，以/结尾的URL认为是目录，否则认为是JAR文件。\n\n```java\n// 尝试通过 URLClassLoader 来加载桌面下的 Test 类。\npublic static void main(String[] args) {\n    try {\n        URL[] urls = new URL[1];\n        URLStreamHandler streamHandler = null;\n        File classPath = new File(\"/home/chen/Desktop/\");\n        String repository = (new URL(\"file\", null,\n                classPath.getCanonicalPath() + File.separator))\n                .toString();\n        urls[0] = new URL(null, repository, streamHandler);\n\n        ClassLoader loader = new URLClassLoader(urls);\n\n        Class testClass = loader.loadClass(\"Test\");\n\n        // output:  java.net.URLClassLoader@7f31245a\n        System.out.println(testClass.getClassLoader());\n    } catch (MalformedURLException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n\n```\n\n## 参考资料\n* https://github.com/c-rainstorm/blog/blob/master/java\n* https://mp.weixin.qq.com/s/HIiy7Q5UoPySFn3ge8Y-Ow\n* https://docs.oracle.com/javase/tutorial/ext/basics/load.html\n* https://en.wikipedia.org/wiki/Java_Classloader","source":"_posts/对象创建及类的加载机制.md","raw":"---\ntitle: 对象的创建及类的加载机制\ndate: 2018-11-28 14:20:10\ntags:\ncategories: Java\n---\n\n> 本篇是最近在学习JVM相关知识时的随笔，虽然我们现在大都通过Spring容器进行对象的实例化，但本身应当了解对象的各类创建方式，以及最基本的Class文件如何通过何种方式加载到内存中生成对应的对象的。\n\n## 类加载的各种几种方式和区别\n\n1. new\n2. Class.forName\n3. class.newInstance\n4. ClassLoader\n\n## ClassLoader\n\n类加载器主要分为两类，一类是JDK默认提供的，一类是用户自定义的。 \n\n![classloader-photo](/image/classloader.png)\n\n### JDK 默认提供三种类加载器：\n\n* Bootstrap ClassLoader 启动类加载器\n\n    每次执行java命令时都会使用该加载器为虚拟机加载核心类。该加载器是由nativecode实现，而不是Java代码，加载类的路径为<JAVA_HOME>/jre/lib。特别的 <JAVA_HOME>/jre/lib/rt.jar中包含了sun.misc.Launcher 类， 而sun.misc.Launcher$ExtClassLoader和sun.misc.Launcher$AppClassLoader都是 sun.misc.Launcher的内部类，所以拓展类加载器和系统类加载器都是由启动类加载器加载的。\n\n* Extension ClassLoader, 拓展类加载器：\n\n    用于加载拓展库中的类。拓展库路径为<JAVA_HOME>/jre/lib/ext/。实现类为sun.misc.Launcher$ExtClassLoader\n\n* System ClassLoader 系统类加载器：\n\n    用于加载CLASSPATH中的类。实现类为sun.misc.Launcher$AppClassLoader\n\n### 用户自定义的类加载器\n\n* Custom ClassLoader, 一般都是java.lang.ClassLoder的子类\n\n    正统的类加载机制是基于双亲委派的，也就是当调用类加载器加载类时，首先将加载任务委派给双亲，若双亲无法加载成功时，自己才进行类加载。\n\n    在实例化一个新的类加载器时，我们可以为其指定一个parent，即双亲，若未显式指定，则System ClassLoader就作为默认双亲。\n\n    具体的说，类加载任务是由ClassLoader的loadClass() 方法来执行的，他会按照以下顺序加载类：\n\n    通过findLoadedClass() 看该类是否已经被加载。该方法为nativecode 实现，若已加载则返回。\n    \n    若未加载则委派给双亲，parent.loadClass()，若成功则返回。\n    \n    若未成功，则调用 findClass() 方法加载类。java.lang.ClassLoader中该方法只是简单的抛出一个ClassNotFoundException所以，自定义的ClassLoader都需要 Override findClass() 方法。\n\n### ClassLoader的API\n\n#### java.lang.ClassLoader\n\n* ClassLoader 是一个抽象类。\n* 待加载的类必须用The Java™Language Specification 定义的全类名，全类名的定义请查阅The Form of a Binary。\n* 给定一个全类名，类加载器应该去定位该类所在的位置。通用的策略是将全类名转换为类文件路径，然后通过类文件路径在文件系统中定位。\n* 每一个加载到内存的类都由一个Class对象来表示，每一个Class对象都有一个指向加载该类的类加载器的引用。但是数组的Class对象是由Java运行时环境创建的，通过 Class.getClassLoader()方法返回的是数组元素的类加载器，若数组元素是基本类型，则返回null，若类是由Bootstrap ClassLoader加载的话也是返回null。\n* ClassLoader默认支持并行加载，但是其子类必须调用ClassLoader.registerAsParallelCapable()来启用并行加载\n* 一般来说,JVM从本地文件系统加载类的行为是与平台有关的。\n* defineClass() 方法可以将字节流转换成一个Class对象。然后调用Class.newInstance()来创建类的实例\n\n```java\npublic static void main(String[] args) {\n    // Object 类在 <java_home>/jre/lib/rt.jar 中，\n    // 由 Bootstrap ClassLoader 加载，由于该类加载器是由 native code 编写\n    // 所以输出为 null\n    Object[] objects = new Object[5];\n    System.out.println();\n    System.out.println(objects.getClass().getClassLoader());\n\n    // ZipFileAttributes 类在 <java_home>/jre/lib/ext/zipfs.jar 中，\n    // 由 Extension ClassLoader 加载，\n    // 输出为  sun.misc.Launcher$ExtClassLoader@4b67cf4d\n    ZipFileAttributes[] attributes = new ZipFileAttributes[5];\n    System.out.println();\n    System.out.println(attributes.getClass().getClassLoader());\n\n    // Main 类是自定义的类，\n    // 默认由 System ClassLoader 加载，\n    // 输出为 sun.misc.Launcher$AppClassLoader@18b4aac2\n    Main[] array = new Main[5];\n    array[0] = new Main();\n    System.out.println();\n    System.out.println(array.getClass().getClassLoader());\n}\n```\n\n#### java.security.SecureClassLoader\n增加了一层权限验证，因为关注点不在安全，所以暂不讨论。\n\n#### java.net.URLClassLoader\n该类加载器用来加载URL指定的JAR文件或目录中的类和资源，以/结尾的URL认为是目录，否则认为是JAR文件。\n\n```java\n// 尝试通过 URLClassLoader 来加载桌面下的 Test 类。\npublic static void main(String[] args) {\n    try {\n        URL[] urls = new URL[1];\n        URLStreamHandler streamHandler = null;\n        File classPath = new File(\"/home/chen/Desktop/\");\n        String repository = (new URL(\"file\", null,\n                classPath.getCanonicalPath() + File.separator))\n                .toString();\n        urls[0] = new URL(null, repository, streamHandler);\n\n        ClassLoader loader = new URLClassLoader(urls);\n\n        Class testClass = loader.loadClass(\"Test\");\n\n        // output:  java.net.URLClassLoader@7f31245a\n        System.out.println(testClass.getClassLoader());\n    } catch (MalformedURLException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n    }\n}\n\n```\n\n## 参考资料\n* https://github.com/c-rainstorm/blog/blob/master/java\n* https://mp.weixin.qq.com/s/HIiy7Q5UoPySFn3ge8Y-Ow\n* https://docs.oracle.com/javase/tutorial/ext/basics/load.html\n* https://en.wikipedia.org/wiki/Java_Classloader","slug":"对象创建及类的加载机制","published":1,"updated":"2018-11-28T08:45:17.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiohs0005uog4xgj08d5b","content":"<blockquote>\n<p>本篇是最近在学习JVM相关知识时的随笔，虽然我们现在大都通过Spring容器进行对象的实例化，但本身应当了解对象的各类创建方式，以及最基本的Class文件如何通过何种方式加载到内存中生成对应的对象的。</p>\n</blockquote>\n<h2 id=\"类加载的各种几种方式和区别\"><a href=\"#类加载的各种几种方式和区别\" class=\"headerlink\" title=\"类加载的各种几种方式和区别\"></a>类加载的各种几种方式和区别</h2><ol>\n<li>new</li>\n<li>Class.forName</li>\n<li>class.newInstance</li>\n<li>ClassLoader</li>\n</ol>\n<h2 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h2><p>类加载器主要分为两类，一类是JDK默认提供的，一类是用户自定义的。 </p>\n<p><img src=\"/image/classloader.png\" alt=\"classloader-photo\"></p>\n<h3 id=\"JDK-默认提供三种类加载器：\"><a href=\"#JDK-默认提供三种类加载器：\" class=\"headerlink\" title=\"JDK 默认提供三种类加载器：\"></a>JDK 默认提供三种类加载器：</h3><ul>\n<li><p>Bootstrap ClassLoader 启动类加载器</p>\n<p>  每次执行java命令时都会使用该加载器为虚拟机加载核心类。该加载器是由nativecode实现，而不是Java代码，加载类的路径为&lt;JAVA_HOME&gt;/jre/lib。特别的 &lt;JAVA_HOME&gt;/jre/lib/rt.jar中包含了sun.misc.Launcher 类， 而sun.misc.Launcher$ExtClassLoader和sun.misc.Launcher$AppClassLoader都是 sun.misc.Launcher的内部类，所以拓展类加载器和系统类加载器都是由启动类加载器加载的。</p>\n</li>\n<li><p>Extension ClassLoader, 拓展类加载器：</p>\n<p>  用于加载拓展库中的类。拓展库路径为&lt;JAVA_HOME&gt;/jre/lib/ext/。实现类为sun.misc.Launcher$ExtClassLoader</p>\n</li>\n<li><p>System ClassLoader 系统类加载器：</p>\n<p>  用于加载CLASSPATH中的类。实现类为sun.misc.Launcher$AppClassLoader</p>\n</li>\n</ul>\n<h3 id=\"用户自定义的类加载器\"><a href=\"#用户自定义的类加载器\" class=\"headerlink\" title=\"用户自定义的类加载器\"></a>用户自定义的类加载器</h3><ul>\n<li><p>Custom ClassLoader, 一般都是java.lang.ClassLoder的子类</p>\n<p>  正统的类加载机制是基于双亲委派的，也就是当调用类加载器加载类时，首先将加载任务委派给双亲，若双亲无法加载成功时，自己才进行类加载。</p>\n<p>  在实例化一个新的类加载器时，我们可以为其指定一个parent，即双亲，若未显式指定，则System ClassLoader就作为默认双亲。</p>\n<p>  具体的说，类加载任务是由ClassLoader的loadClass() 方法来执行的，他会按照以下顺序加载类：</p>\n<p>  通过findLoadedClass() 看该类是否已经被加载。该方法为nativecode 实现，若已加载则返回。</p>\n<p>  若未加载则委派给双亲，parent.loadClass()，若成功则返回。</p>\n<p>  若未成功，则调用 findClass() 方法加载类。java.lang.ClassLoader中该方法只是简单的抛出一个ClassNotFoundException所以，自定义的ClassLoader都需要 Override findClass() 方法。</p>\n</li>\n</ul>\n<h3 id=\"ClassLoader的API\"><a href=\"#ClassLoader的API\" class=\"headerlink\" title=\"ClassLoader的API\"></a>ClassLoader的API</h3><h4 id=\"java-lang-ClassLoader\"><a href=\"#java-lang-ClassLoader\" class=\"headerlink\" title=\"java.lang.ClassLoader\"></a>java.lang.ClassLoader</h4><ul>\n<li>ClassLoader 是一个抽象类。</li>\n<li>待加载的类必须用The Java™Language Specification 定义的全类名，全类名的定义请查阅The Form of a Binary。</li>\n<li>给定一个全类名，类加载器应该去定位该类所在的位置。通用的策略是将全类名转换为类文件路径，然后通过类文件路径在文件系统中定位。</li>\n<li>每一个加载到内存的类都由一个Class对象来表示，每一个Class对象都有一个指向加载该类的类加载器的引用。但是数组的Class对象是由Java运行时环境创建的，通过 Class.getClassLoader()方法返回的是数组元素的类加载器，若数组元素是基本类型，则返回null，若类是由Bootstrap ClassLoader加载的话也是返回null。</li>\n<li>ClassLoader默认支持并行加载，但是其子类必须调用ClassLoader.registerAsParallelCapable()来启用并行加载</li>\n<li>一般来说,JVM从本地文件系统加载类的行为是与平台有关的。</li>\n<li>defineClass() 方法可以将字节流转换成一个Class对象。然后调用Class.newInstance()来创建类的实例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Object 类在 &lt;java_home&gt;/jre/lib/rt.jar 中，</span></span><br><span class=\"line\">    <span class=\"comment\">// 由 Bootstrap ClassLoader 加载，由于该类加载器是由 native code 编写</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以输出为 null</span></span><br><span class=\"line\">    Object[] objects = <span class=\"keyword\">new</span> Object[<span class=\"number\">5</span>];</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    System.out.println(objects.getClass().getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ZipFileAttributes 类在 &lt;java_home&gt;/jre/lib/ext/zipfs.jar 中，</span></span><br><span class=\"line\">    <span class=\"comment\">// 由 Extension ClassLoader 加载，</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出为  sun.misc.Launcher$ExtClassLoader@4b67cf4d</span></span><br><span class=\"line\">    ZipFileAttributes[] attributes = <span class=\"keyword\">new</span> ZipFileAttributes[<span class=\"number\">5</span>];</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    System.out.println(attributes.getClass().getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Main 类是自定义的类，</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认由 System ClassLoader 加载，</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出为 sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class=\"line\">    Main[] array = <span class=\"keyword\">new</span> Main[<span class=\"number\">5</span>];</span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Main();</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    System.out.println(array.getClass().getClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"java-security-SecureClassLoader\"><a href=\"#java-security-SecureClassLoader\" class=\"headerlink\" title=\"java.security.SecureClassLoader\"></a>java.security.SecureClassLoader</h4><p>增加了一层权限验证，因为关注点不在安全，所以暂不讨论。</p>\n<h4 id=\"java-net-URLClassLoader\"><a href=\"#java-net-URLClassLoader\" class=\"headerlink\" title=\"java.net.URLClassLoader\"></a>java.net.URLClassLoader</h4><p>该类加载器用来加载URL指定的JAR文件或目录中的类和资源，以/结尾的URL认为是目录，否则认为是JAR文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 尝试通过 URLClassLoader 来加载桌面下的 Test 类。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        URL[] urls = <span class=\"keyword\">new</span> URL[<span class=\"number\">1</span>];</span><br><span class=\"line\">        URLStreamHandler streamHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        File classPath = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/home/chen/Desktop/\"</span>);</span><br><span class=\"line\">        String repository = (<span class=\"keyword\">new</span> URL(<span class=\"string\">\"file\"</span>, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                classPath.getCanonicalPath() + File.separator))</span><br><span class=\"line\">                .toString();</span><br><span class=\"line\">        urls[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> URL(<span class=\"keyword\">null</span>, repository, streamHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">        ClassLoader loader = <span class=\"keyword\">new</span> URLClassLoader(urls);</span><br><span class=\"line\"></span><br><span class=\"line\">        Class testClass = loader.loadClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// output:  java.net.URLClassLoader@7f31245a</span></span><br><span class=\"line\">        System.out.println(testClass.getClassLoader());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (MalformedURLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/c-rainstorm/blog/blob/master/java\" target=\"_blank\" rel=\"noopener\">https://github.com/c-rainstorm/blog/blob/master/java</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HIiy7Q5UoPySFn3ge8Y-Ow\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/HIiy7Q5UoPySFn3ge8Y-Ow</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/ext/basics/load.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/ext/basics/load.html</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Java_Classloader\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Java_Classloader</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇是最近在学习JVM相关知识时的随笔，虽然我们现在大都通过Spring容器进行对象的实例化，但本身应当了解对象的各类创建方式，以及最基本的Class文件如何通过何种方式加载到内存中生成对应的对象的。</p>\n</blockquote>\n<h2 id=\"类加载的各种几种方式和区别\"><a href=\"#类加载的各种几种方式和区别\" class=\"headerlink\" title=\"类加载的各种几种方式和区别\"></a>类加载的各种几种方式和区别</h2><ol>\n<li>new</li>\n<li>Class.forName</li>\n<li>class.newInstance</li>\n<li>ClassLoader</li>\n</ol>\n<h2 id=\"ClassLoader\"><a href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"></a>ClassLoader</h2><p>类加载器主要分为两类，一类是JDK默认提供的，一类是用户自定义的。 </p>\n<p><img src=\"/image/classloader.png\" alt=\"classloader-photo\"></p>\n<h3 id=\"JDK-默认提供三种类加载器：\"><a href=\"#JDK-默认提供三种类加载器：\" class=\"headerlink\" title=\"JDK 默认提供三种类加载器：\"></a>JDK 默认提供三种类加载器：</h3><ul>\n<li><p>Bootstrap ClassLoader 启动类加载器</p>\n<p>  每次执行java命令时都会使用该加载器为虚拟机加载核心类。该加载器是由nativecode实现，而不是Java代码，加载类的路径为&lt;JAVA_HOME&gt;/jre/lib。特别的 &lt;JAVA_HOME&gt;/jre/lib/rt.jar中包含了sun.misc.Launcher 类， 而sun.misc.Launcher$ExtClassLoader和sun.misc.Launcher$AppClassLoader都是 sun.misc.Launcher的内部类，所以拓展类加载器和系统类加载器都是由启动类加载器加载的。</p>\n</li>\n<li><p>Extension ClassLoader, 拓展类加载器：</p>\n<p>  用于加载拓展库中的类。拓展库路径为&lt;JAVA_HOME&gt;/jre/lib/ext/。实现类为sun.misc.Launcher$ExtClassLoader</p>\n</li>\n<li><p>System ClassLoader 系统类加载器：</p>\n<p>  用于加载CLASSPATH中的类。实现类为sun.misc.Launcher$AppClassLoader</p>\n</li>\n</ul>\n<h3 id=\"用户自定义的类加载器\"><a href=\"#用户自定义的类加载器\" class=\"headerlink\" title=\"用户自定义的类加载器\"></a>用户自定义的类加载器</h3><ul>\n<li><p>Custom ClassLoader, 一般都是java.lang.ClassLoder的子类</p>\n<p>  正统的类加载机制是基于双亲委派的，也就是当调用类加载器加载类时，首先将加载任务委派给双亲，若双亲无法加载成功时，自己才进行类加载。</p>\n<p>  在实例化一个新的类加载器时，我们可以为其指定一个parent，即双亲，若未显式指定，则System ClassLoader就作为默认双亲。</p>\n<p>  具体的说，类加载任务是由ClassLoader的loadClass() 方法来执行的，他会按照以下顺序加载类：</p>\n<p>  通过findLoadedClass() 看该类是否已经被加载。该方法为nativecode 实现，若已加载则返回。</p>\n<p>  若未加载则委派给双亲，parent.loadClass()，若成功则返回。</p>\n<p>  若未成功，则调用 findClass() 方法加载类。java.lang.ClassLoader中该方法只是简单的抛出一个ClassNotFoundException所以，自定义的ClassLoader都需要 Override findClass() 方法。</p>\n</li>\n</ul>\n<h3 id=\"ClassLoader的API\"><a href=\"#ClassLoader的API\" class=\"headerlink\" title=\"ClassLoader的API\"></a>ClassLoader的API</h3><h4 id=\"java-lang-ClassLoader\"><a href=\"#java-lang-ClassLoader\" class=\"headerlink\" title=\"java.lang.ClassLoader\"></a>java.lang.ClassLoader</h4><ul>\n<li>ClassLoader 是一个抽象类。</li>\n<li>待加载的类必须用The Java™Language Specification 定义的全类名，全类名的定义请查阅The Form of a Binary。</li>\n<li>给定一个全类名，类加载器应该去定位该类所在的位置。通用的策略是将全类名转换为类文件路径，然后通过类文件路径在文件系统中定位。</li>\n<li>每一个加载到内存的类都由一个Class对象来表示，每一个Class对象都有一个指向加载该类的类加载器的引用。但是数组的Class对象是由Java运行时环境创建的，通过 Class.getClassLoader()方法返回的是数组元素的类加载器，若数组元素是基本类型，则返回null，若类是由Bootstrap ClassLoader加载的话也是返回null。</li>\n<li>ClassLoader默认支持并行加载，但是其子类必须调用ClassLoader.registerAsParallelCapable()来启用并行加载</li>\n<li>一般来说,JVM从本地文件系统加载类的行为是与平台有关的。</li>\n<li>defineClass() 方法可以将字节流转换成一个Class对象。然后调用Class.newInstance()来创建类的实例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Object 类在 &lt;java_home&gt;/jre/lib/rt.jar 中，</span></span><br><span class=\"line\">    <span class=\"comment\">// 由 Bootstrap ClassLoader 加载，由于该类加载器是由 native code 编写</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以输出为 null</span></span><br><span class=\"line\">    Object[] objects = <span class=\"keyword\">new</span> Object[<span class=\"number\">5</span>];</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    System.out.println(objects.getClass().getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ZipFileAttributes 类在 &lt;java_home&gt;/jre/lib/ext/zipfs.jar 中，</span></span><br><span class=\"line\">    <span class=\"comment\">// 由 Extension ClassLoader 加载，</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出为  sun.misc.Launcher$ExtClassLoader@4b67cf4d</span></span><br><span class=\"line\">    ZipFileAttributes[] attributes = <span class=\"keyword\">new</span> ZipFileAttributes[<span class=\"number\">5</span>];</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    System.out.println(attributes.getClass().getClassLoader());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Main 类是自定义的类，</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认由 System ClassLoader 加载，</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出为 sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class=\"line\">    Main[] array = <span class=\"keyword\">new</span> Main[<span class=\"number\">5</span>];</span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Main();</span><br><span class=\"line\">    System.out.println();</span><br><span class=\"line\">    System.out.println(array.getClass().getClassLoader());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"java-security-SecureClassLoader\"><a href=\"#java-security-SecureClassLoader\" class=\"headerlink\" title=\"java.security.SecureClassLoader\"></a>java.security.SecureClassLoader</h4><p>增加了一层权限验证，因为关注点不在安全，所以暂不讨论。</p>\n<h4 id=\"java-net-URLClassLoader\"><a href=\"#java-net-URLClassLoader\" class=\"headerlink\" title=\"java.net.URLClassLoader\"></a>java.net.URLClassLoader</h4><p>该类加载器用来加载URL指定的JAR文件或目录中的类和资源，以/结尾的URL认为是目录，否则认为是JAR文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 尝试通过 URLClassLoader 来加载桌面下的 Test 类。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        URL[] urls = <span class=\"keyword\">new</span> URL[<span class=\"number\">1</span>];</span><br><span class=\"line\">        URLStreamHandler streamHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        File classPath = <span class=\"keyword\">new</span> File(<span class=\"string\">\"/home/chen/Desktop/\"</span>);</span><br><span class=\"line\">        String repository = (<span class=\"keyword\">new</span> URL(<span class=\"string\">\"file\"</span>, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                classPath.getCanonicalPath() + File.separator))</span><br><span class=\"line\">                .toString();</span><br><span class=\"line\">        urls[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> URL(<span class=\"keyword\">null</span>, repository, streamHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">        ClassLoader loader = <span class=\"keyword\">new</span> URLClassLoader(urls);</span><br><span class=\"line\"></span><br><span class=\"line\">        Class testClass = loader.loadClass(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// output:  java.net.URLClassLoader@7f31245a</span></span><br><span class=\"line\">        System.out.println(testClass.getClassLoader());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (MalformedURLException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/c-rainstorm/blog/blob/master/java\" target=\"_blank\" rel=\"noopener\">https://github.com/c-rainstorm/blog/blob/master/java</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HIiy7Q5UoPySFn3ge8Y-Ow\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/HIiy7Q5UoPySFn3ge8Y-Ow</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/ext/basics/load.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/ext/basics/load.html</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Java_Classloader\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Java_Classloader</a></li>\n</ul>\n"},{"title":"Lambda、函数式接口、引用表达式","date":"2018-11-21T06:00:01.000Z","_content":"\n# Lambda、函数式接口、引用表达式\n\n## 写在前面\n>最近在学习Stream的api，发现Java推出的函数式接口、Lambda表达式、引用表达式等大都服务于Stream的api使用，但其实并不一定，所以收集整理了下关于相关特性的用法。\n在这只会讲解下基本的用法，关于函数编程框架的详细解读，大家可以参考下这篇 [Java8 函数式编程探秘](http://www.importnew.com/27901.html \"Java8 函数式编程探秘\")，介绍的非常全面。\n\n## 函数式接口\n先讲一个注解 ***@FunctionalInterface***\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {}\n```\n\n@FunctionalInterface 注解要求接口有且只有一个抽象方法，JDK中有许多类用到该注解，比如 Runnable，它只有一个 Run 方法。（注：默认方法并不是抽象方法）\n\n```java\n@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface <code>Runnable</code> is used\n     * to create a thread, starting the thread causes the object's\n     * <code>run</code> method to be called in that separately executing\n     * thread.\n     * <p>\n     * The general contract of the method <code>run</code> is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n```\nJava8中接口可以定义静态方法，直接通过类名调用，并且接口中可以通过default为抽象方法提供默认的实现。接口继承接口时，如果默认方法相同，则需要进行重写\n\nJava8推出的Lambda表达式只能针对函数式接口使用。\n\n\n## Lambda的语法\n\n首先Lambda可以认为是一种特殊的匿名内部类，其次lambda只能用于函数式接口。\n\nlambda语法：\n\n```java\n([形参列表，不带数据类型])-> {\n    //执行语句\n    [return..;]\n}\n```\n\n要注意的点：\n1. 如果形参列表是空的，只需要保留（）即可\n2. 如果没有返回值。只需要在{}写执行语句即可\n3. 如果接口的抽象方法只有一个形参，（）可以省略，只需要参数的名称即可\n4. 如果执行语句只有一行，可以省略{}，但是如果有返回值时，情况特殊。\n5. 如果函数式接口的方法有返回值，必须给定返回值，如果执行语句只有一句，还可以简写，即省去大括号和return以及最后的；号。\n6. 形参列表的数据类型会自动推断，只需要参数名称。\n\neg:\n\n```java\npublic class TestLambda {\n     public static void main(String[] args) {\n           TestLanmdaInterface1 t1 = new TestLanmdaInterface1() {\n                @Override\n                public void test() {\n                     System.out.println(\"使用匿名内部类\");\n \n                }\n           };\n           //与上面的匿名内部类执行效果一样\n           //右边的类型会自动根据左边的类型进行判断\n           TestLanmdaInterface1 t2 = () -> {\n                System.out.println(\"使用lanbda\");\n           };\n           t1.test();\n           t2.test();\n \n           //如果执行语句只有一行，可以省略大括号\n           TestLanmdaInterface1 t3 = () -> System.out.println(\"省略执行语句大括号，使用lanbda\");\n           t3.test();\n \n           TestLanmdaInterface2 t4 = (s) -> System.out.println(\"使用lanbda表达式，带1个参数，参数为：\"+s);\n           t4.test(\"字符串参数1\");\n \n           TestLanmdaInterface2 t5 = s -> System.out.println(\"使用lanbda表达式，只带1个参数，可省略参数的圆括号，参数为：\"+s);\n           t5.test(\"字符串参数2\");\n \n           TestLanmdaInterface3 t6 = (s,i) -> System.out.println(\"使用lanbda表达式，带两个参数，不可以省略圆括号，参数为：\"+s+\"  \"+ i);\n           t6.test(\"字符串参数3\",50);\n     }\n}\n \n@FunctionalInterface\ninterface TestLanmdaInterface1 {\n     //不带参数的抽象方法\n     void test();\n}\n@FunctionalInterface\ninterface TestLanmdaInterface2 {\n     //带参数的抽象方法\n     void test(String str);\n}\n@FunctionalInterface\ninterface TestLanmdaInterface3 {\n     //带多个参数的抽象方法\n     void test(String str,int num);\n}\n```\n\n```java\n@FunctionalInterface\ninterface IDemo {\n    void doSomething();\n}\n\nclass Demo {\n    public void doSomething(IDemo c) {\n        System.out.println(c);\n        c.doSomething();\n    }\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.doSomething(new IDemo() {\n            @Override\n            public void doSomething() {\n                System.out.println(\"使用匿名内部类实现\");\n\n            }\n        });\n        demo.doSomething(() -> System.out.println(\"使用lambda表达式实现\"));\n        /*\n        demo.doSomething(() -> {\n            System.out.println(\"使用lambda表达式实现\");\n            System.out.println(\"使用lambda表达式实现\");\n        });\n        */\n    }\n```\n\n可以看出，lambda表达式和匿名内部类并不完全相同\n\n观察生成的class文件可以看出，lambda表达式并不会生成额外的.class文件，而匿名内部类会生成Test$1.class\n```java\ncn.lb.Test$1@4554617c\n使用匿名内部类实现\ncn.lb.Test$$Lambda$1/1324119927@404b9385\n使用lambda表达式实现\n```\n\n\n## 函数式接口引用表达式\n\n* 引用实例方法：\n    自动把调用方法的时候的参数，全部传给引用的方法\n\n```java\n<函数式接口> <变量名> = <实例> :: <实例方法名>\n//自动把实参传递给引用的实例方法\n<变量名>.<接口方法>（[实参]）\n```\n* 引用类方法（静态方法）：\n    自动把调用方法的时候的参数，全部传给引用的方法\n\n* 引用类的实例方法：\n    定义、调用接口方法的时候需要多一个参数，并且参数的类型必须和引用实例方法的类型必须一致，把第一个参数作为引用的实例，后面的每个参数全部传递给引用的方法。\n\n```java\ninterface <函数式接口> {\n    <返回值> <方法名>(<类名><名称> [,其它参数...])    \n}\n<变量名>.<方法名>（<类名的实例>[,其它参数]）\n```\n\neg:\n```java\npublic class TestMethodRef {\n    public static void main(String[] args) {\n        MethodRef r1 = (s) -> System.out.println(s);\n        r1.test(\"普通方式\");\n\n        //使用方法的引用：实例方法的引用\n        //System.out是一个实例  out是PrintStream 类型，有println方法\n        MethodRef r2 = System.out::println;\n        r2.test(\"方法引用\");\n\n        //MethodRef1 r3 =(a)-> Arrays.sort(a);\n        //引用类方法\n        MethodRef1 r3 = Arrays::sort;\n        int[] a = new int[]{4, 12, 23, 1, 3};\n        r3.test(a);\n        //将排序后的数组输出\n        r1.test(Arrays.toString(a));\n\n        //引用类的实例方法\n        MethodRef2 r4 = PrintStream::println;\n        //第二个之后的参数作为引用方法的参数\n        r4.test(System.out, \"第二个参数\");\n\n        //引用构造器\n        MethodRef3 r5 = String::new;\n        String test = r5.test(new char[]{'测', '试', '构', '造', '器', '引', '用'});\n        System.out.println(test);\n        //普通情况\n        MethodRef3 r6 = (c) -> {\n            return new String(c);\n        };\n        String test2 = r6.test(new char[]{'测', '试', '构', '造', '器', '引', '用'});\n        System.out.println(test2);\n    }\n}\n\ninterface MethodRef {\n    void test(String s);\n}\n\ninterface MethodRef1 {\n    void test(int[] arr);\n}\n\ninterface MethodRef2 {\n    void test(PrintStream out, String str);\n}\n\n//测试构造器引用\ninterface MethodRef3 {\n    String test(char[] chars);\n}\n\n```\n\n## 参考资料\n\n* https://blog.csdn.net/zymx14/article/details/70175746\n* https://blog.csdn.net/kegaofei/article/details/80582356\n* https://edu.aliyun.com/lesson_1012_9096?spm=5176.10731542.0.0.xGlbkv#_9096\n* http://www.importnew.com/27901.html\n* http://www.importnew.com/10360.html","source":"_posts/lambda、函数式接口、引用表达式.md","raw":"---\ntitle: Lambda、函数式接口、引用表达式\ndate: 2018-11-21 14:00:01\ntags:\ncategories: Java\n---\n\n# Lambda、函数式接口、引用表达式\n\n## 写在前面\n>最近在学习Stream的api，发现Java推出的函数式接口、Lambda表达式、引用表达式等大都服务于Stream的api使用，但其实并不一定，所以收集整理了下关于相关特性的用法。\n在这只会讲解下基本的用法，关于函数编程框架的详细解读，大家可以参考下这篇 [Java8 函数式编程探秘](http://www.importnew.com/27901.html \"Java8 函数式编程探秘\")，介绍的非常全面。\n\n## 函数式接口\n先讲一个注解 ***@FunctionalInterface***\n\n```java\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {}\n```\n\n@FunctionalInterface 注解要求接口有且只有一个抽象方法，JDK中有许多类用到该注解，比如 Runnable，它只有一个 Run 方法。（注：默认方法并不是抽象方法）\n\n```java\n@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface <code>Runnable</code> is used\n     * to create a thread, starting the thread causes the object's\n     * <code>run</code> method to be called in that separately executing\n     * thread.\n     * <p>\n     * The general contract of the method <code>run</code> is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n```\nJava8中接口可以定义静态方法，直接通过类名调用，并且接口中可以通过default为抽象方法提供默认的实现。接口继承接口时，如果默认方法相同，则需要进行重写\n\nJava8推出的Lambda表达式只能针对函数式接口使用。\n\n\n## Lambda的语法\n\n首先Lambda可以认为是一种特殊的匿名内部类，其次lambda只能用于函数式接口。\n\nlambda语法：\n\n```java\n([形参列表，不带数据类型])-> {\n    //执行语句\n    [return..;]\n}\n```\n\n要注意的点：\n1. 如果形参列表是空的，只需要保留（）即可\n2. 如果没有返回值。只需要在{}写执行语句即可\n3. 如果接口的抽象方法只有一个形参，（）可以省略，只需要参数的名称即可\n4. 如果执行语句只有一行，可以省略{}，但是如果有返回值时，情况特殊。\n5. 如果函数式接口的方法有返回值，必须给定返回值，如果执行语句只有一句，还可以简写，即省去大括号和return以及最后的；号。\n6. 形参列表的数据类型会自动推断，只需要参数名称。\n\neg:\n\n```java\npublic class TestLambda {\n     public static void main(String[] args) {\n           TestLanmdaInterface1 t1 = new TestLanmdaInterface1() {\n                @Override\n                public void test() {\n                     System.out.println(\"使用匿名内部类\");\n \n                }\n           };\n           //与上面的匿名内部类执行效果一样\n           //右边的类型会自动根据左边的类型进行判断\n           TestLanmdaInterface1 t2 = () -> {\n                System.out.println(\"使用lanbda\");\n           };\n           t1.test();\n           t2.test();\n \n           //如果执行语句只有一行，可以省略大括号\n           TestLanmdaInterface1 t3 = () -> System.out.println(\"省略执行语句大括号，使用lanbda\");\n           t3.test();\n \n           TestLanmdaInterface2 t4 = (s) -> System.out.println(\"使用lanbda表达式，带1个参数，参数为：\"+s);\n           t4.test(\"字符串参数1\");\n \n           TestLanmdaInterface2 t5 = s -> System.out.println(\"使用lanbda表达式，只带1个参数，可省略参数的圆括号，参数为：\"+s);\n           t5.test(\"字符串参数2\");\n \n           TestLanmdaInterface3 t6 = (s,i) -> System.out.println(\"使用lanbda表达式，带两个参数，不可以省略圆括号，参数为：\"+s+\"  \"+ i);\n           t6.test(\"字符串参数3\",50);\n     }\n}\n \n@FunctionalInterface\ninterface TestLanmdaInterface1 {\n     //不带参数的抽象方法\n     void test();\n}\n@FunctionalInterface\ninterface TestLanmdaInterface2 {\n     //带参数的抽象方法\n     void test(String str);\n}\n@FunctionalInterface\ninterface TestLanmdaInterface3 {\n     //带多个参数的抽象方法\n     void test(String str,int num);\n}\n```\n\n```java\n@FunctionalInterface\ninterface IDemo {\n    void doSomething();\n}\n\nclass Demo {\n    public void doSomething(IDemo c) {\n        System.out.println(c);\n        c.doSomething();\n    }\n}\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n        demo.doSomething(new IDemo() {\n            @Override\n            public void doSomething() {\n                System.out.println(\"使用匿名内部类实现\");\n\n            }\n        });\n        demo.doSomething(() -> System.out.println(\"使用lambda表达式实现\"));\n        /*\n        demo.doSomething(() -> {\n            System.out.println(\"使用lambda表达式实现\");\n            System.out.println(\"使用lambda表达式实现\");\n        });\n        */\n    }\n```\n\n可以看出，lambda表达式和匿名内部类并不完全相同\n\n观察生成的class文件可以看出，lambda表达式并不会生成额外的.class文件，而匿名内部类会生成Test$1.class\n```java\ncn.lb.Test$1@4554617c\n使用匿名内部类实现\ncn.lb.Test$$Lambda$1/1324119927@404b9385\n使用lambda表达式实现\n```\n\n\n## 函数式接口引用表达式\n\n* 引用实例方法：\n    自动把调用方法的时候的参数，全部传给引用的方法\n\n```java\n<函数式接口> <变量名> = <实例> :: <实例方法名>\n//自动把实参传递给引用的实例方法\n<变量名>.<接口方法>（[实参]）\n```\n* 引用类方法（静态方法）：\n    自动把调用方法的时候的参数，全部传给引用的方法\n\n* 引用类的实例方法：\n    定义、调用接口方法的时候需要多一个参数，并且参数的类型必须和引用实例方法的类型必须一致，把第一个参数作为引用的实例，后面的每个参数全部传递给引用的方法。\n\n```java\ninterface <函数式接口> {\n    <返回值> <方法名>(<类名><名称> [,其它参数...])    \n}\n<变量名>.<方法名>（<类名的实例>[,其它参数]）\n```\n\neg:\n```java\npublic class TestMethodRef {\n    public static void main(String[] args) {\n        MethodRef r1 = (s) -> System.out.println(s);\n        r1.test(\"普通方式\");\n\n        //使用方法的引用：实例方法的引用\n        //System.out是一个实例  out是PrintStream 类型，有println方法\n        MethodRef r2 = System.out::println;\n        r2.test(\"方法引用\");\n\n        //MethodRef1 r3 =(a)-> Arrays.sort(a);\n        //引用类方法\n        MethodRef1 r3 = Arrays::sort;\n        int[] a = new int[]{4, 12, 23, 1, 3};\n        r3.test(a);\n        //将排序后的数组输出\n        r1.test(Arrays.toString(a));\n\n        //引用类的实例方法\n        MethodRef2 r4 = PrintStream::println;\n        //第二个之后的参数作为引用方法的参数\n        r4.test(System.out, \"第二个参数\");\n\n        //引用构造器\n        MethodRef3 r5 = String::new;\n        String test = r5.test(new char[]{'测', '试', '构', '造', '器', '引', '用'});\n        System.out.println(test);\n        //普通情况\n        MethodRef3 r6 = (c) -> {\n            return new String(c);\n        };\n        String test2 = r6.test(new char[]{'测', '试', '构', '造', '器', '引', '用'});\n        System.out.println(test2);\n    }\n}\n\ninterface MethodRef {\n    void test(String s);\n}\n\ninterface MethodRef1 {\n    void test(int[] arr);\n}\n\ninterface MethodRef2 {\n    void test(PrintStream out, String str);\n}\n\n//测试构造器引用\ninterface MethodRef3 {\n    String test(char[] chars);\n}\n\n```\n\n## 参考资料\n\n* https://blog.csdn.net/zymx14/article/details/70175746\n* https://blog.csdn.net/kegaofei/article/details/80582356\n* https://edu.aliyun.com/lesson_1012_9096?spm=5176.10731542.0.0.xGlbkv#_9096\n* http://www.importnew.com/27901.html\n* http://www.importnew.com/10360.html","slug":"lambda、函数式接口、引用表达式","published":1,"updated":"2018-11-21T09:35:15.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiomc000duog4tjm8cwzk","content":"<h1 id=\"Lambda、函数式接口、引用表达式\"><a href=\"#Lambda、函数式接口、引用表达式\" class=\"headerlink\" title=\"Lambda、函数式接口、引用表达式\"></a>Lambda、函数式接口、引用表达式</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><blockquote>\n<p>最近在学习Stream的api，发现Java推出的函数式接口、Lambda表达式、引用表达式等大都服务于Stream的api使用，但其实并不一定，所以收集整理了下关于相关特性的用法。<br>在这只会讲解下基本的用法，关于函数编程框架的详细解读，大家可以参考下这篇 <a href=\"http://www.importnew.com/27901.html\" title=\"Java8 函数式编程探秘\" target=\"_blank\" rel=\"noopener\">Java8 函数式编程探秘</a>，介绍的非常全面。</p>\n</blockquote>\n<h2 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h2><p>先讲一个注解 <strong><em>@FunctionalInterface</em></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>@FunctionalInterface 注解要求接口有且只有一个抽象方法，JDK中有许多类用到该注解，比如 Runnable，它只有一个 Run 方法。（注：默认方法并不是抽象方法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class=\"line\"><span class=\"comment\">     * to create a thread, starting the thread causes the object's</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class=\"line\"><span class=\"comment\">     * thread.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class=\"line\"><span class=\"comment\">     * take any action whatsoever.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span>     java.lang.Thread#run()</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java8中接口可以定义静态方法，直接通过类名调用，并且接口中可以通过default为抽象方法提供默认的实现。接口继承接口时，如果默认方法相同，则需要进行重写</p>\n<p>Java8推出的Lambda表达式只能针对函数式接口使用。</p>\n<h2 id=\"Lambda的语法\"><a href=\"#Lambda的语法\" class=\"headerlink\" title=\"Lambda的语法\"></a>Lambda的语法</h2><p>首先Lambda可以认为是一种特殊的匿名内部类，其次lambda只能用于函数式接口。</p>\n<p>lambda语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([形参列表，不带数据类型])-&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//执行语句</span></span><br><span class=\"line\">    [<span class=\"keyword\">return</span>..;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要注意的点：</p>\n<ol>\n<li>如果形参列表是空的，只需要保留（）即可</li>\n<li>如果没有返回值。只需要在{}写执行语句即可</li>\n<li>如果接口的抽象方法只有一个形参，（）可以省略，只需要参数的名称即可</li>\n<li>如果执行语句只有一行，可以省略{}，但是如果有返回值时，情况特殊。</li>\n<li>如果函数式接口的方法有返回值，必须给定返回值，如果执行语句只有一句，还可以简写，即省去大括号和return以及最后的；号。</li>\n<li>形参列表的数据类型会自动推断，只需要参数名称。</li>\n</ol>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestLambda</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">           TestLanmdaInterface1 t1 = <span class=\"keyword\">new</span> TestLanmdaInterface1() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                     System.out.println(<span class=\"string\">\"使用匿名内部类\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">           &#125;;</span><br><span class=\"line\">           <span class=\"comment\">//与上面的匿名内部类执行效果一样</span></span><br><span class=\"line\">           <span class=\"comment\">//右边的类型会自动根据左边的类型进行判断</span></span><br><span class=\"line\">           TestLanmdaInterface1 t2 = () -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"使用lanbda\"</span>);</span><br><span class=\"line\">           &#125;;</span><br><span class=\"line\">           t1.test();</span><br><span class=\"line\">           t2.test();</span><br><span class=\"line\"> </span><br><span class=\"line\">           <span class=\"comment\">//如果执行语句只有一行，可以省略大括号</span></span><br><span class=\"line\">           TestLanmdaInterface1 t3 = () -&gt; System.out.println(<span class=\"string\">\"省略执行语句大括号，使用lanbda\"</span>);</span><br><span class=\"line\">           t3.test();</span><br><span class=\"line\"> </span><br><span class=\"line\">           TestLanmdaInterface2 t4 = (s) -&gt; System.out.println(<span class=\"string\">\"使用lanbda表达式，带1个参数，参数为：\"</span>+s);</span><br><span class=\"line\">           t4.test(<span class=\"string\">\"字符串参数1\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">           TestLanmdaInterface2 t5 = s -&gt; System.out.println(<span class=\"string\">\"使用lanbda表达式，只带1个参数，可省略参数的圆括号，参数为：\"</span>+s);</span><br><span class=\"line\">           t5.test(<span class=\"string\">\"字符串参数2\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">           TestLanmdaInterface3 t6 = (s,i) -&gt; System.out.println(<span class=\"string\">\"使用lanbda表达式，带两个参数，不可以省略圆括号，参数为：\"</span>+s+<span class=\"string\">\"  \"</span>+ i);</span><br><span class=\"line\">           t6.test(<span class=\"string\">\"字符串参数3\"</span>,<span class=\"number\">50</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestLanmdaInterface1</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//不带参数的抽象方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestLanmdaInterface2</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//带参数的抽象方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestLanmdaInterface3</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//带多个参数的抽象方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String str,<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(IDemo c)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(c);</span><br><span class=\"line\">        c.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.doSomething(<span class=\"keyword\">new</span> IDemo() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"使用匿名内部类实现\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        demo.doSomething(() -&gt; System.out.println(<span class=\"string\">\"使用lambda表达式实现\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        demo.doSomething(() -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            System.out.println(\"使用lambda表达式实现\");</span></span><br><span class=\"line\"><span class=\"comment\">            System.out.println(\"使用lambda表达式实现\");</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，lambda表达式和匿名内部类并不完全相同</p>\n<p>观察生成的class文件可以看出，lambda表达式并不会生成额外的.class文件，而匿名内部类会生成Test$1.class<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cn.lb.Test$<span class=\"number\">1</span>@<span class=\"number\">4554617</span>c</span><br><span class=\"line\">使用匿名内部类实现</span><br><span class=\"line\">cn.lb.Test$$Lambda$<span class=\"number\">1</span>/<span class=\"number\">1324119927</span>@<span class=\"number\">404</span>b9385</span><br><span class=\"line\">使用lambda表达式实现</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数式接口引用表达式\"><a href=\"#函数式接口引用表达式\" class=\"headerlink\" title=\"函数式接口引用表达式\"></a>函数式接口引用表达式</h2><ul>\n<li>引用实例方法：<br>  自动把调用方法的时候的参数，全部传给引用的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;函数式接口&gt; &lt;变量名&gt; = &lt;实例&gt; :: &lt;实例方法名&gt;</span><br><span class=\"line\"><span class=\"comment\">//自动把实参传递给引用的实例方法</span></span><br><span class=\"line\">&lt;变量名&gt;.&lt;接口方法&gt;（[实参]）</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>引用类方法（静态方法）：<br>  自动把调用方法的时候的参数，全部传给引用的方法</p>\n</li>\n<li><p>引用类的实例方法：<br>  定义、调用接口方法的时候需要多一个参数，并且参数的类型必须和引用实例方法的类型必须一致，把第一个参数作为引用的实例，后面的每个参数全部传递给引用的方法。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> &lt;函数式接口&gt; </span>&#123;</span><br><span class=\"line\">    &lt;返回值&gt; &lt;方法名&gt;(&lt;类名&gt;&lt;名称&gt; [,其它参数...])    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;变量名&gt;.&lt;方法名&gt;（&lt;类名的实例&gt;[,其它参数]）</span><br></pre></td></tr></table></figure>\n<p>eg:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestMethodRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodRef r1 = (s) -&gt; System.out.println(s);</span><br><span class=\"line\">        r1.test(<span class=\"string\">\"普通方式\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用方法的引用：实例方法的引用</span></span><br><span class=\"line\">        <span class=\"comment\">//System.out是一个实例  out是PrintStream 类型，有println方法</span></span><br><span class=\"line\">        MethodRef r2 = System.out::println;</span><br><span class=\"line\">        r2.test(<span class=\"string\">\"方法引用\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//MethodRef1 r3 =(a)-&gt; Arrays.sort(a);</span></span><br><span class=\"line\">        <span class=\"comment\">//引用类方法</span></span><br><span class=\"line\">        MethodRef1 r3 = Arrays::sort;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">4</span>, <span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        r3.test(a);</span><br><span class=\"line\">        <span class=\"comment\">//将排序后的数组输出</span></span><br><span class=\"line\">        r1.test(Arrays.toString(a));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//引用类的实例方法</span></span><br><span class=\"line\">        MethodRef2 r4 = PrintStream::println;</span><br><span class=\"line\">        <span class=\"comment\">//第二个之后的参数作为引用方法的参数</span></span><br><span class=\"line\">        r4.test(System.out, <span class=\"string\">\"第二个参数\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//引用构造器</span></span><br><span class=\"line\">        MethodRef3 r5 = String::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">        String test = r5.test(<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;<span class=\"string\">'测'</span>, <span class=\"string\">'试'</span>, <span class=\"string\">'构'</span>, <span class=\"string\">'造'</span>, <span class=\"string\">'器'</span>, <span class=\"string\">'引'</span>, <span class=\"string\">'用'</span>&#125;);</span><br><span class=\"line\">        System.out.println(test);</span><br><span class=\"line\">        <span class=\"comment\">//普通情况</span></span><br><span class=\"line\">        MethodRef3 r6 = (c) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(c);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        String test2 = r6.test(<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;<span class=\"string\">'测'</span>, <span class=\"string\">'试'</span>, <span class=\"string\">'构'</span>, <span class=\"string\">'造'</span>, <span class=\"string\">'器'</span>, <span class=\"string\">'引'</span>, <span class=\"string\">'用'</span>&#125;);</span><br><span class=\"line\">        System.out.println(test2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String s)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(PrintStream out, String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试构造器引用</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">char</span>[] chars)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/zymx14/article/details/70175746\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zymx14/article/details/70175746</a></li>\n<li><a href=\"https://blog.csdn.net/kegaofei/article/details/80582356\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kegaofei/article/details/80582356</a></li>\n<li><a href=\"https://edu.aliyun.com/lesson_1012_9096?spm=5176.10731542.0.0.xGlbkv#_9096\" target=\"_blank\" rel=\"noopener\">https://edu.aliyun.com/lesson_1012_9096?spm=5176.10731542.0.0.xGlbkv#_9096</a></li>\n<li><a href=\"http://www.importnew.com/27901.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/27901.html</a></li>\n<li><a href=\"http://www.importnew.com/10360.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/10360.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Lambda、函数式接口、引用表达式\"><a href=\"#Lambda、函数式接口、引用表达式\" class=\"headerlink\" title=\"Lambda、函数式接口、引用表达式\"></a>Lambda、函数式接口、引用表达式</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><blockquote>\n<p>最近在学习Stream的api，发现Java推出的函数式接口、Lambda表达式、引用表达式等大都服务于Stream的api使用，但其实并不一定，所以收集整理了下关于相关特性的用法。<br>在这只会讲解下基本的用法，关于函数编程框架的详细解读，大家可以参考下这篇 <a href=\"http://www.importnew.com/27901.html\" title=\"Java8 函数式编程探秘\" target=\"_blank\" rel=\"noopener\">Java8 函数式编程探秘</a>，介绍的非常全面。</p>\n</blockquote>\n<h2 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h2><p>先讲一个注解 <strong><em>@FunctionalInterface</em></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>@FunctionalInterface 注解要求接口有且只有一个抽象方法，JDK中有许多类用到该注解，比如 Runnable，它只有一个 Run 方法。（注：默认方法并不是抽象方法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class=\"line\"><span class=\"comment\">     * to create a thread, starting the thread causes the object's</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class=\"line\"><span class=\"comment\">     * thread.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class=\"line\"><span class=\"comment\">     * take any action whatsoever.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span>     java.lang.Thread#run()</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java8中接口可以定义静态方法，直接通过类名调用，并且接口中可以通过default为抽象方法提供默认的实现。接口继承接口时，如果默认方法相同，则需要进行重写</p>\n<p>Java8推出的Lambda表达式只能针对函数式接口使用。</p>\n<h2 id=\"Lambda的语法\"><a href=\"#Lambda的语法\" class=\"headerlink\" title=\"Lambda的语法\"></a>Lambda的语法</h2><p>首先Lambda可以认为是一种特殊的匿名内部类，其次lambda只能用于函数式接口。</p>\n<p>lambda语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([形参列表，不带数据类型])-&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//执行语句</span></span><br><span class=\"line\">    [<span class=\"keyword\">return</span>..;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要注意的点：</p>\n<ol>\n<li>如果形参列表是空的，只需要保留（）即可</li>\n<li>如果没有返回值。只需要在{}写执行语句即可</li>\n<li>如果接口的抽象方法只有一个形参，（）可以省略，只需要参数的名称即可</li>\n<li>如果执行语句只有一行，可以省略{}，但是如果有返回值时，情况特殊。</li>\n<li>如果函数式接口的方法有返回值，必须给定返回值，如果执行语句只有一句，还可以简写，即省去大括号和return以及最后的；号。</li>\n<li>形参列表的数据类型会自动推断，只需要参数名称。</li>\n</ol>\n<p>eg:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestLambda</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">           TestLanmdaInterface1 t1 = <span class=\"keyword\">new</span> TestLanmdaInterface1() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                     System.out.println(<span class=\"string\">\"使用匿名内部类\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">           &#125;;</span><br><span class=\"line\">           <span class=\"comment\">//与上面的匿名内部类执行效果一样</span></span><br><span class=\"line\">           <span class=\"comment\">//右边的类型会自动根据左边的类型进行判断</span></span><br><span class=\"line\">           TestLanmdaInterface1 t2 = () -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"使用lanbda\"</span>);</span><br><span class=\"line\">           &#125;;</span><br><span class=\"line\">           t1.test();</span><br><span class=\"line\">           t2.test();</span><br><span class=\"line\"> </span><br><span class=\"line\">           <span class=\"comment\">//如果执行语句只有一行，可以省略大括号</span></span><br><span class=\"line\">           TestLanmdaInterface1 t3 = () -&gt; System.out.println(<span class=\"string\">\"省略执行语句大括号，使用lanbda\"</span>);</span><br><span class=\"line\">           t3.test();</span><br><span class=\"line\"> </span><br><span class=\"line\">           TestLanmdaInterface2 t4 = (s) -&gt; System.out.println(<span class=\"string\">\"使用lanbda表达式，带1个参数，参数为：\"</span>+s);</span><br><span class=\"line\">           t4.test(<span class=\"string\">\"字符串参数1\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">           TestLanmdaInterface2 t5 = s -&gt; System.out.println(<span class=\"string\">\"使用lanbda表达式，只带1个参数，可省略参数的圆括号，参数为：\"</span>+s);</span><br><span class=\"line\">           t5.test(<span class=\"string\">\"字符串参数2\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">           TestLanmdaInterface3 t6 = (s,i) -&gt; System.out.println(<span class=\"string\">\"使用lanbda表达式，带两个参数，不可以省略圆括号，参数为：\"</span>+s+<span class=\"string\">\"  \"</span>+ i);</span><br><span class=\"line\">           t6.test(<span class=\"string\">\"字符串参数3\"</span>,<span class=\"number\">50</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestLanmdaInterface1</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//不带参数的抽象方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestLanmdaInterface2</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//带参数的抽象方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestLanmdaInterface3</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//带多个参数的抽象方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String str,<span class=\"keyword\">int</span> num)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(IDemo c)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(c);</span><br><span class=\"line\">        c.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Demo demo = <span class=\"keyword\">new</span> Demo();</span><br><span class=\"line\">        demo.doSomething(<span class=\"keyword\">new</span> IDemo() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"使用匿名内部类实现\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        demo.doSomething(() -&gt; System.out.println(<span class=\"string\">\"使用lambda表达式实现\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        demo.doSomething(() -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            System.out.println(\"使用lambda表达式实现\");</span></span><br><span class=\"line\"><span class=\"comment\">            System.out.println(\"使用lambda表达式实现\");</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，lambda表达式和匿名内部类并不完全相同</p>\n<p>观察生成的class文件可以看出，lambda表达式并不会生成额外的.class文件，而匿名内部类会生成Test$1.class<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cn.lb.Test$<span class=\"number\">1</span>@<span class=\"number\">4554617</span>c</span><br><span class=\"line\">使用匿名内部类实现</span><br><span class=\"line\">cn.lb.Test$$Lambda$<span class=\"number\">1</span>/<span class=\"number\">1324119927</span>@<span class=\"number\">404</span>b9385</span><br><span class=\"line\">使用lambda表达式实现</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数式接口引用表达式\"><a href=\"#函数式接口引用表达式\" class=\"headerlink\" title=\"函数式接口引用表达式\"></a>函数式接口引用表达式</h2><ul>\n<li>引用实例方法：<br>  自动把调用方法的时候的参数，全部传给引用的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;函数式接口&gt; &lt;变量名&gt; = &lt;实例&gt; :: &lt;实例方法名&gt;</span><br><span class=\"line\"><span class=\"comment\">//自动把实参传递给引用的实例方法</span></span><br><span class=\"line\">&lt;变量名&gt;.&lt;接口方法&gt;（[实参]）</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>引用类方法（静态方法）：<br>  自动把调用方法的时候的参数，全部传给引用的方法</p>\n</li>\n<li><p>引用类的实例方法：<br>  定义、调用接口方法的时候需要多一个参数，并且参数的类型必须和引用实例方法的类型必须一致，把第一个参数作为引用的实例，后面的每个参数全部传递给引用的方法。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> &lt;函数式接口&gt; </span>&#123;</span><br><span class=\"line\">    &lt;返回值&gt; &lt;方法名&gt;(&lt;类名&gt;&lt;名称&gt; [,其它参数...])    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;变量名&gt;.&lt;方法名&gt;（&lt;类名的实例&gt;[,其它参数]）</span><br></pre></td></tr></table></figure>\n<p>eg:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestMethodRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MethodRef r1 = (s) -&gt; System.out.println(s);</span><br><span class=\"line\">        r1.test(<span class=\"string\">\"普通方式\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用方法的引用：实例方法的引用</span></span><br><span class=\"line\">        <span class=\"comment\">//System.out是一个实例  out是PrintStream 类型，有println方法</span></span><br><span class=\"line\">        MethodRef r2 = System.out::println;</span><br><span class=\"line\">        r2.test(<span class=\"string\">\"方法引用\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//MethodRef1 r3 =(a)-&gt; Arrays.sort(a);</span></span><br><span class=\"line\">        <span class=\"comment\">//引用类方法</span></span><br><span class=\"line\">        MethodRef1 r3 = Arrays::sort;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">4</span>, <span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        r3.test(a);</span><br><span class=\"line\">        <span class=\"comment\">//将排序后的数组输出</span></span><br><span class=\"line\">        r1.test(Arrays.toString(a));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//引用类的实例方法</span></span><br><span class=\"line\">        MethodRef2 r4 = PrintStream::println;</span><br><span class=\"line\">        <span class=\"comment\">//第二个之后的参数作为引用方法的参数</span></span><br><span class=\"line\">        r4.test(System.out, <span class=\"string\">\"第二个参数\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//引用构造器</span></span><br><span class=\"line\">        MethodRef3 r5 = String::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">        String test = r5.test(<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;<span class=\"string\">'测'</span>, <span class=\"string\">'试'</span>, <span class=\"string\">'构'</span>, <span class=\"string\">'造'</span>, <span class=\"string\">'器'</span>, <span class=\"string\">'引'</span>, <span class=\"string\">'用'</span>&#125;);</span><br><span class=\"line\">        System.out.println(test);</span><br><span class=\"line\">        <span class=\"comment\">//普通情况</span></span><br><span class=\"line\">        MethodRef3 r6 = (c) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(c);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        String test2 = r6.test(<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[]&#123;<span class=\"string\">'测'</span>, <span class=\"string\">'试'</span>, <span class=\"string\">'构'</span>, <span class=\"string\">'造'</span>, <span class=\"string\">'器'</span>, <span class=\"string\">'引'</span>, <span class=\"string\">'用'</span>&#125;);</span><br><span class=\"line\">        System.out.println(test2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String s)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(PrintStream out, String str)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试构造器引用</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MethodRef3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">char</span>[] chars)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/zymx14/article/details/70175746\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zymx14/article/details/70175746</a></li>\n<li><a href=\"https://blog.csdn.net/kegaofei/article/details/80582356\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kegaofei/article/details/80582356</a></li>\n<li><a href=\"https://edu.aliyun.com/lesson_1012_9096?spm=5176.10731542.0.0.xGlbkv#_9096\" target=\"_blank\" rel=\"noopener\">https://edu.aliyun.com/lesson_1012_9096?spm=5176.10731542.0.0.xGlbkv#_9096</a></li>\n<li><a href=\"http://www.importnew.com/27901.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/27901.html</a></li>\n<li><a href=\"http://www.importnew.com/10360.html\" target=\"_blank\" rel=\"noopener\">http://www.importnew.com/10360.html</a></li>\n</ul>\n"},{"title":"load balancing","date":"2018-09-04T05:54:17.000Z","_content":"\n---\n## 什么是负载均衡？\n讲到负载均衡是什么，首先要讨论下负载均衡出现的背景。\n* CPU的发展单核心高频->多核心多线程技术\n* 单体架构->集群架构->分布式架构\n\n---\n## 关键字\n* 效率提升\n* 横向扩容（集群）  \n* 平衡、防止单体过载\n* 空间换时间\n\n---\n## 概念\n负载均衡（Load balancing）：在计算中，负载平衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。\n\n将负载（工作任务）进行平衡、分摊到多个操作单元上进行执行。需要我们注意的是：它并不属于网络基础架构，而是属于一种网络优化设备。它是建立在现有的网络基础架构之上，给企业提供了更廉价更有效的扩展选择。\n\n个人总结：将负载进行平衡，将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备。\n\n---\n## 为了解决的问题\n流量堵塞、效率缓慢、运行不畅，提高业务的处理能力，服务的高可用性。\n\n---\n## 硬件负载均衡&软件负载均衡\n硬件负载均衡不做讨论。列举一些产品：\n* F5 BIG-IP负载均衡器（LTM）\n* 思科\n* Radware的AppDirector系列\n* ...\n\n---\n## 网络七层协议\n1. 物理层 \n2. 数据链路层\n3. 网络层\n4. 传输层\n5. 会话层\n6. 表示层\n7. 应用层\n\n---\n## 负载均衡的场景\n### 浏览器发送请求后发生了什么？\n* DNS服务器，DNS本身是一个基于UDP协议的网络协议，查询IP地址信息。\n* 浏览器获得真正的IP、port、通过TCP协议发起网络访问\n* Web Server（协议处理、静态文件、动态内容）\n* 调用不同服务、不同接口等进行处理\n* 响应\n\n### 全局负载均衡系统（GSLB）\n全局负载均衡主要用于在多个区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度。\n* 内容分发网络（CDN）\n* DNS轮询\n![DNS-photo](/image/loadbalancing/DNS.png)\n利用DNS处理域名解析请求的同时进行负载均衡是另一种常用的方案。在DNS服务器中配置多个A记录，如：xxx IN A 114.100.80.1、xxx IN A 114.100.80.2、xxx IN A 114.100.80.3.\n每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。\n\n* HTTP重定向\n\n### 服务器负载均衡系统（SLB）\n* 数据链路层负载均衡\n![LVS-photo](/image/loadbalancing/LVS.png)\n\n数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。\n\n这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一样，从而达到负载均衡，这种负载均衡方式又称为直接路由方式（DR）.\n\n在上图中，用户请求到达负载均衡服务器后，负载均衡服务器将请求数据的目的mac地址修改为真是WEB服务器的mac地址，并不修改数据包目标IP地址，因此数据可以正常到达目标WEB服务器，该服务器在处理完数据后可以经过网管服务器而不是负载均衡服务器直接到达用户浏览器。\n\n使用三角传输模式的链路层负载均衡是目前大型网站所使用的最广的一种负载均衡手段。在linux平台上最好的链路层负载均衡开源产品是LVS(linux virtual server)。\n\n* IP负载均衡（SNAT）\n![IP-photo](/image/loadbalancing/IP.png)\n\nIP负载均衡：即在网络层通过修改请求目标地址进行负载均衡。\n\n用户请求数据包到达负载均衡服务器后，负载均衡服务器在操作系统内核进行获取网络数据包，根据负载均衡算法计算得到一台真实的WEB服务器地址，然后将数据包的IP地址修改为真实的WEB服务器地址，不需要通过用户进程处理。真实的WEB服务器处理完毕后，相应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。\n\n这里的关键在于真实WEB服务器相应数据包如何返回给负载均衡服务器，一种是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址改为自身的IP，即源地址转换（SNAT），另一种方案是将负载均衡服务器同时作为真实物理服务器的网关服务器，这样所有的数据都会到达负载均衡服务器。\n\nIP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。但由于所有请求响应的数据包都需要经过负载均衡服务器，因此负载均衡的网卡带宽成为系统的瓶颈。\n\n---\n\n## 常用的负载均衡\n* FW-F5-IHS-核心（三层）交换机-WAS\n![F5-photo](/image/loadbalancing/F5_ISH_WAS.png)\n* VIP-Nginx-Keepalived-webserver\n![Nginx-photo](/image/loadbalancing/Nginx-Keepalived.png)\n\n---\n\n### 服务底层负载均衡\n* 分布系统中服务的负载均衡，如SpringCloud Ribbon、Zookeeper。\n---\n\n## 网络分层中的负载均衡区别\n服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡和七层负载均衡。\n\n* 技术原理上的区别\n\n四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。\n以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP)，直接转发给该服务器。\nTCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。\n\n七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。\n以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。\n\n![layer4&7-photo](/image/loadbalancing/loadbalancing_layer4&7.jpeg)\n\n* 应用场景的需求\n\n七层应用负载的好处，是使得整个网络更\"智能化\", 例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术。\n将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。\n\n* 安全性\n\n是否真的可以提高安全性\n\n是否有足够的灵活度\n\n---\n## 正向代理&反向代理\n* 正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 \n\n* 反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 \n---\n## 服务端负载均衡&客户端负载均衡\n---\n## 负载均衡服务\n* 四层：F5、LVS\n* 七层：Nginx、HAproxy\n* 协调：Keepalived\n---\n## 负载均衡云服务\n* 阿里SLB\n* Amazon ELB\n* Citrix ADC\n* 腾讯 CLB\n* Radware的AppDirector\n---\n## 负载均衡组件\n* zookeeper\n* spring-cloud-ribbon客户端负载均衡\n* spring-cloud-zuul实现反向代理和负载均衡\n---\n## 负载均衡策咯\n* 轮循(Round Robin) & 加权轮循(Weighted Round Robin)\n* 最少连接数(Least Connection)\n* 最少连接数慢启动时间(Least Connection Slow Start Time)\n* 基于代理的自适应负载均衡(Agent Based Adaptive Balancing)\n* 固定权重(Fixed Weighted)\n* 加权响应(Weighted Response)\n* 源IP哈希(Source IP Hash)\n\n---\n## 参考资料\n* Load Balancing (computing) WIKI：https://en.wikipedia.org/wiki/Load_balancing_(computing)\n* 四层/七层负载均衡区别：https://www.jianshu.com/p/fa937b8e6712\n* 软/硬件负载均衡产品知多少：https://www.cnblogs.com/lcword/p/5773296.html\n* 全局负载均衡与CDN网络简介：https://blog.csdn.net/u010340143/article/details/9062213\n* 大型网络-负载均衡架构：http://www.cnblogs.com/and/p/3366400.html\n* Nginx实现负载均衡+keepalived实现Nginx高可用：https://www.cnblogs.com/youzhibing/p/7327342.html\n* 正向代理&反向代理：https://blog.csdn.net/zt15732625878/article/details/78941268\n* 常见负载均衡算法：https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html","source":"_posts/load-balancing.md","raw":"---\ntitle: load balancing\ndate: 2018-09-04 13:54:17\ntags:\ncategories: Others\n---\n\n---\n## 什么是负载均衡？\n讲到负载均衡是什么，首先要讨论下负载均衡出现的背景。\n* CPU的发展单核心高频->多核心多线程技术\n* 单体架构->集群架构->分布式架构\n\n---\n## 关键字\n* 效率提升\n* 横向扩容（集群）  \n* 平衡、防止单体过载\n* 空间换时间\n\n---\n## 概念\n负载均衡（Load balancing）：在计算中，负载平衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。\n\n将负载（工作任务）进行平衡、分摊到多个操作单元上进行执行。需要我们注意的是：它并不属于网络基础架构，而是属于一种网络优化设备。它是建立在现有的网络基础架构之上，给企业提供了更廉价更有效的扩展选择。\n\n个人总结：将负载进行平衡，将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备。\n\n---\n## 为了解决的问题\n流量堵塞、效率缓慢、运行不畅，提高业务的处理能力，服务的高可用性。\n\n---\n## 硬件负载均衡&软件负载均衡\n硬件负载均衡不做讨论。列举一些产品：\n* F5 BIG-IP负载均衡器（LTM）\n* 思科\n* Radware的AppDirector系列\n* ...\n\n---\n## 网络七层协议\n1. 物理层 \n2. 数据链路层\n3. 网络层\n4. 传输层\n5. 会话层\n6. 表示层\n7. 应用层\n\n---\n## 负载均衡的场景\n### 浏览器发送请求后发生了什么？\n* DNS服务器，DNS本身是一个基于UDP协议的网络协议，查询IP地址信息。\n* 浏览器获得真正的IP、port、通过TCP协议发起网络访问\n* Web Server（协议处理、静态文件、动态内容）\n* 调用不同服务、不同接口等进行处理\n* 响应\n\n### 全局负载均衡系统（GSLB）\n全局负载均衡主要用于在多个区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度。\n* 内容分发网络（CDN）\n* DNS轮询\n![DNS-photo](/image/loadbalancing/DNS.png)\n利用DNS处理域名解析请求的同时进行负载均衡是另一种常用的方案。在DNS服务器中配置多个A记录，如：xxx IN A 114.100.80.1、xxx IN A 114.100.80.2、xxx IN A 114.100.80.3.\n每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。\n\n* HTTP重定向\n\n### 服务器负载均衡系统（SLB）\n* 数据链路层负载均衡\n![LVS-photo](/image/loadbalancing/LVS.png)\n\n数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。\n\n这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一样，从而达到负载均衡，这种负载均衡方式又称为直接路由方式（DR）.\n\n在上图中，用户请求到达负载均衡服务器后，负载均衡服务器将请求数据的目的mac地址修改为真是WEB服务器的mac地址，并不修改数据包目标IP地址，因此数据可以正常到达目标WEB服务器，该服务器在处理完数据后可以经过网管服务器而不是负载均衡服务器直接到达用户浏览器。\n\n使用三角传输模式的链路层负载均衡是目前大型网站所使用的最广的一种负载均衡手段。在linux平台上最好的链路层负载均衡开源产品是LVS(linux virtual server)。\n\n* IP负载均衡（SNAT）\n![IP-photo](/image/loadbalancing/IP.png)\n\nIP负载均衡：即在网络层通过修改请求目标地址进行负载均衡。\n\n用户请求数据包到达负载均衡服务器后，负载均衡服务器在操作系统内核进行获取网络数据包，根据负载均衡算法计算得到一台真实的WEB服务器地址，然后将数据包的IP地址修改为真实的WEB服务器地址，不需要通过用户进程处理。真实的WEB服务器处理完毕后，相应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。\n\n这里的关键在于真实WEB服务器相应数据包如何返回给负载均衡服务器，一种是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址改为自身的IP，即源地址转换（SNAT），另一种方案是将负载均衡服务器同时作为真实物理服务器的网关服务器，这样所有的数据都会到达负载均衡服务器。\n\nIP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。但由于所有请求响应的数据包都需要经过负载均衡服务器，因此负载均衡的网卡带宽成为系统的瓶颈。\n\n---\n\n## 常用的负载均衡\n* FW-F5-IHS-核心（三层）交换机-WAS\n![F5-photo](/image/loadbalancing/F5_ISH_WAS.png)\n* VIP-Nginx-Keepalived-webserver\n![Nginx-photo](/image/loadbalancing/Nginx-Keepalived.png)\n\n---\n\n### 服务底层负载均衡\n* 分布系统中服务的负载均衡，如SpringCloud Ribbon、Zookeeper。\n---\n\n## 网络分层中的负载均衡区别\n服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡和七层负载均衡。\n\n* 技术原理上的区别\n\n四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。\n以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP)，直接转发给该服务器。\nTCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。\n\n七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。\n以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。\n\n![layer4&7-photo](/image/loadbalancing/loadbalancing_layer4&7.jpeg)\n\n* 应用场景的需求\n\n七层应用负载的好处，是使得整个网络更\"智能化\", 例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术。\n将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。\n\n* 安全性\n\n是否真的可以提高安全性\n\n是否有足够的灵活度\n\n---\n## 正向代理&反向代理\n* 正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 \n\n* 反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 \n---\n## 服务端负载均衡&客户端负载均衡\n---\n## 负载均衡服务\n* 四层：F5、LVS\n* 七层：Nginx、HAproxy\n* 协调：Keepalived\n---\n## 负载均衡云服务\n* 阿里SLB\n* Amazon ELB\n* Citrix ADC\n* 腾讯 CLB\n* Radware的AppDirector\n---\n## 负载均衡组件\n* zookeeper\n* spring-cloud-ribbon客户端负载均衡\n* spring-cloud-zuul实现反向代理和负载均衡\n---\n## 负载均衡策咯\n* 轮循(Round Robin) & 加权轮循(Weighted Round Robin)\n* 最少连接数(Least Connection)\n* 最少连接数慢启动时间(Least Connection Slow Start Time)\n* 基于代理的自适应负载均衡(Agent Based Adaptive Balancing)\n* 固定权重(Fixed Weighted)\n* 加权响应(Weighted Response)\n* 源IP哈希(Source IP Hash)\n\n---\n## 参考资料\n* Load Balancing (computing) WIKI：https://en.wikipedia.org/wiki/Load_balancing_(computing)\n* 四层/七层负载均衡区别：https://www.jianshu.com/p/fa937b8e6712\n* 软/硬件负载均衡产品知多少：https://www.cnblogs.com/lcword/p/5773296.html\n* 全局负载均衡与CDN网络简介：https://blog.csdn.net/u010340143/article/details/9062213\n* 大型网络-负载均衡架构：http://www.cnblogs.com/and/p/3366400.html\n* Nginx实现负载均衡+keepalived实现Nginx高可用：https://www.cnblogs.com/youzhibing/p/7327342.html\n* 正向代理&反向代理：https://blog.csdn.net/zt15732625878/article/details/78941268\n* 常见负载均衡算法：https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html","slug":"load-balancing","published":1,"updated":"2018-10-09T09:18:11.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiomd000euog4oh6jraft","content":"<hr>\n<h2 id=\"什么是负载均衡？\"><a href=\"#什么是负载均衡？\" class=\"headerlink\" title=\"什么是负载均衡？\"></a>什么是负载均衡？</h2><p>讲到负载均衡是什么，首先要讨论下负载均衡出现的背景。</p>\n<ul>\n<li>CPU的发展单核心高频-&gt;多核心多线程技术</li>\n<li>单体架构-&gt;集群架构-&gt;分布式架构</li>\n</ul>\n<hr>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><ul>\n<li>效率提升</li>\n<li>横向扩容（集群）  </li>\n<li>平衡、防止单体过载</li>\n<li>空间换时间</li>\n</ul>\n<hr>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>负载均衡（Load balancing）：在计算中，负载平衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>\n<p>将负载（工作任务）进行平衡、分摊到多个操作单元上进行执行。需要我们注意的是：它并不属于网络基础架构，而是属于一种网络优化设备。它是建立在现有的网络基础架构之上，给企业提供了更廉价更有效的扩展选择。</p>\n<p>个人总结：将负载进行平衡，将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备。</p>\n<hr>\n<h2 id=\"为了解决的问题\"><a href=\"#为了解决的问题\" class=\"headerlink\" title=\"为了解决的问题\"></a>为了解决的问题</h2><p>流量堵塞、效率缓慢、运行不畅，提高业务的处理能力，服务的高可用性。</p>\n<hr>\n<h2 id=\"硬件负载均衡-amp-软件负载均衡\"><a href=\"#硬件负载均衡-amp-软件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡&amp;软件负载均衡\"></a>硬件负载均衡&amp;软件负载均衡</h2><p>硬件负载均衡不做讨论。列举一些产品：</p>\n<ul>\n<li>F5 BIG-IP负载均衡器（LTM）</li>\n<li>思科</li>\n<li>Radware的AppDirector系列</li>\n<li>…</li>\n</ul>\n<hr>\n<h2 id=\"网络七层协议\"><a href=\"#网络七层协议\" class=\"headerlink\" title=\"网络七层协议\"></a>网络七层协议</h2><ol>\n<li>物理层 </li>\n<li>数据链路层</li>\n<li>网络层</li>\n<li>传输层</li>\n<li>会话层</li>\n<li>表示层</li>\n<li>应用层</li>\n</ol>\n<hr>\n<h2 id=\"负载均衡的场景\"><a href=\"#负载均衡的场景\" class=\"headerlink\" title=\"负载均衡的场景\"></a>负载均衡的场景</h2><h3 id=\"浏览器发送请求后发生了什么？\"><a href=\"#浏览器发送请求后发生了什么？\" class=\"headerlink\" title=\"浏览器发送请求后发生了什么？\"></a>浏览器发送请求后发生了什么？</h3><ul>\n<li>DNS服务器，DNS本身是一个基于UDP协议的网络协议，查询IP地址信息。</li>\n<li>浏览器获得真正的IP、port、通过TCP协议发起网络访问</li>\n<li>Web Server（协议处理、静态文件、动态内容）</li>\n<li>调用不同服务、不同接口等进行处理</li>\n<li>响应</li>\n</ul>\n<h3 id=\"全局负载均衡系统（GSLB）\"><a href=\"#全局负载均衡系统（GSLB）\" class=\"headerlink\" title=\"全局负载均衡系统（GSLB）\"></a>全局负载均衡系统（GSLB）</h3><p>全局负载均衡主要用于在多个区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度。</p>\n<ul>\n<li>内容分发网络（CDN）</li>\n<li><p>DNS轮询<br><img src=\"/image/loadbalancing/DNS.png\" alt=\"DNS-photo\"><br>利用DNS处理域名解析请求的同时进行负载均衡是另一种常用的方案。在DNS服务器中配置多个A记录，如：xxx IN A 114.100.80.1、xxx IN A 114.100.80.2、xxx IN A 114.100.80.3.<br>每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p>\n</li>\n<li><p>HTTP重定向</p>\n</li>\n</ul>\n<h3 id=\"服务器负载均衡系统（SLB）\"><a href=\"#服务器负载均衡系统（SLB）\" class=\"headerlink\" title=\"服务器负载均衡系统（SLB）\"></a>服务器负载均衡系统（SLB）</h3><ul>\n<li>数据链路层负载均衡<br><img src=\"/image/loadbalancing/LVS.png\" alt=\"LVS-photo\"></li>\n</ul>\n<p>数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。</p>\n<p>这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一样，从而达到负载均衡，这种负载均衡方式又称为直接路由方式（DR）.</p>\n<p>在上图中，用户请求到达负载均衡服务器后，负载均衡服务器将请求数据的目的mac地址修改为真是WEB服务器的mac地址，并不修改数据包目标IP地址，因此数据可以正常到达目标WEB服务器，该服务器在处理完数据后可以经过网管服务器而不是负载均衡服务器直接到达用户浏览器。</p>\n<p>使用三角传输模式的链路层负载均衡是目前大型网站所使用的最广的一种负载均衡手段。在linux平台上最好的链路层负载均衡开源产品是LVS(linux virtual server)。</p>\n<ul>\n<li>IP负载均衡（SNAT）<br><img src=\"/image/loadbalancing/IP.png\" alt=\"IP-photo\"></li>\n</ul>\n<p>IP负载均衡：即在网络层通过修改请求目标地址进行负载均衡。</p>\n<p>用户请求数据包到达负载均衡服务器后，负载均衡服务器在操作系统内核进行获取网络数据包，根据负载均衡算法计算得到一台真实的WEB服务器地址，然后将数据包的IP地址修改为真实的WEB服务器地址，不需要通过用户进程处理。真实的WEB服务器处理完毕后，相应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。</p>\n<p>这里的关键在于真实WEB服务器相应数据包如何返回给负载均衡服务器，一种是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址改为自身的IP，即源地址转换（SNAT），另一种方案是将负载均衡服务器同时作为真实物理服务器的网关服务器，这样所有的数据都会到达负载均衡服务器。</p>\n<p>IP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。但由于所有请求响应的数据包都需要经过负载均衡服务器，因此负载均衡的网卡带宽成为系统的瓶颈。</p>\n<hr>\n<h2 id=\"常用的负载均衡\"><a href=\"#常用的负载均衡\" class=\"headerlink\" title=\"常用的负载均衡\"></a>常用的负载均衡</h2><ul>\n<li>FW-F5-IHS-核心（三层）交换机-WAS<br><img src=\"/image/loadbalancing/F5_ISH_WAS.png\" alt=\"F5-photo\"></li>\n<li>VIP-Nginx-Keepalived-webserver<br><img src=\"/image/loadbalancing/Nginx-Keepalived.png\" alt=\"Nginx-photo\"></li>\n</ul>\n<hr>\n<h3 id=\"服务底层负载均衡\"><a href=\"#服务底层负载均衡\" class=\"headerlink\" title=\"服务底层负载均衡\"></a>服务底层负载均衡</h3><ul>\n<li>分布系统中服务的负载均衡，如SpringCloud Ribbon、Zookeeper。</li>\n</ul>\n<hr>\n<h2 id=\"网络分层中的负载均衡区别\"><a href=\"#网络分层中的负载均衡区别\" class=\"headerlink\" title=\"网络分层中的负载均衡区别\"></a>网络分层中的负载均衡区别</h2><p>服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡和七层负载均衡。</p>\n<ul>\n<li>技术原理上的区别</li>\n</ul>\n<p>四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP)，直接转发给该服务器。<br>TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>\n<p>七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。</p>\n<p><img src=\"/image/loadbalancing/loadbalancing_layer4&amp;7.jpeg\" alt=\"layer4&amp;7-photo\"></p>\n<ul>\n<li>应用场景的需求</li>\n</ul>\n<p>七层应用负载的好处，是使得整个网络更”智能化”, 例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术。<br>将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p>\n<ul>\n<li>安全性</li>\n</ul>\n<p>是否真的可以提高安全性</p>\n<p>是否有足够的灵活度</p>\n<hr>\n<h2 id=\"正向代理-amp-反向代理\"><a href=\"#正向代理-amp-反向代理\" class=\"headerlink\" title=\"正向代理&amp;反向代理\"></a>正向代理&amp;反向代理</h2><ul>\n<li><p>正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 </p>\n</li>\n<li><p>反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 </p>\n</li>\n</ul>\n<hr>\n<h2 id=\"服务端负载均衡-amp-客户端负载均衡\"><a href=\"#服务端负载均衡-amp-客户端负载均衡\" class=\"headerlink\" title=\"服务端负载均衡&amp;客户端负载均衡\"></a>服务端负载均衡&amp;客户端负载均衡</h2><hr>\n<h2 id=\"负载均衡服务\"><a href=\"#负载均衡服务\" class=\"headerlink\" title=\"负载均衡服务\"></a>负载均衡服务</h2><ul>\n<li>四层：F5、LVS</li>\n<li>七层：Nginx、HAproxy</li>\n<li>协调：Keepalived</li>\n</ul>\n<hr>\n<h2 id=\"负载均衡云服务\"><a href=\"#负载均衡云服务\" class=\"headerlink\" title=\"负载均衡云服务\"></a>负载均衡云服务</h2><ul>\n<li>阿里SLB</li>\n<li>Amazon ELB</li>\n<li>Citrix ADC</li>\n<li>腾讯 CLB</li>\n<li>Radware的AppDirector</li>\n</ul>\n<hr>\n<h2 id=\"负载均衡组件\"><a href=\"#负载均衡组件\" class=\"headerlink\" title=\"负载均衡组件\"></a>负载均衡组件</h2><ul>\n<li>zookeeper</li>\n<li>spring-cloud-ribbon客户端负载均衡</li>\n<li>spring-cloud-zuul实现反向代理和负载均衡</li>\n</ul>\n<hr>\n<h2 id=\"负载均衡策咯\"><a href=\"#负载均衡策咯\" class=\"headerlink\" title=\"负载均衡策咯\"></a>负载均衡策咯</h2><ul>\n<li>轮循(Round Robin) &amp; 加权轮循(Weighted Round Robin)</li>\n<li>最少连接数(Least Connection)</li>\n<li>最少连接数慢启动时间(Least Connection Slow Start Time)</li>\n<li>基于代理的自适应负载均衡(Agent Based Adaptive Balancing)</li>\n<li>固定权重(Fixed Weighted)</li>\n<li>加权响应(Weighted Response)</li>\n<li>源IP哈希(Source IP Hash)</li>\n</ul>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>Load Balancing (computing) WIKI：<a href=\"https://en.wikipedia.org/wiki/Load_balancing_(computing)\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Load_balancing_(computing)</a></li>\n<li>四层/七层负载均衡区别：<a href=\"https://www.jianshu.com/p/fa937b8e6712\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fa937b8e6712</a></li>\n<li>软/硬件负载均衡产品知多少：<a href=\"https://www.cnblogs.com/lcword/p/5773296.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lcword/p/5773296.html</a></li>\n<li>全局负载均衡与CDN网络简介：<a href=\"https://blog.csdn.net/u010340143/article/details/9062213\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010340143/article/details/9062213</a></li>\n<li>大型网络-负载均衡架构：<a href=\"http://www.cnblogs.com/and/p/3366400.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/and/p/3366400.html</a></li>\n<li>Nginx实现负载均衡+keepalived实现Nginx高可用：<a href=\"https://www.cnblogs.com/youzhibing/p/7327342.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/youzhibing/p/7327342.html</a></li>\n<li>正向代理&amp;反向代理：<a href=\"https://blog.csdn.net/zt15732625878/article/details/78941268\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zt15732625878/article/details/78941268</a></li>\n<li>常见负载均衡算法：<a href=\"https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"什么是负载均衡？\"><a href=\"#什么是负载均衡？\" class=\"headerlink\" title=\"什么是负载均衡？\"></a>什么是负载均衡？</h2><p>讲到负载均衡是什么，首先要讨论下负载均衡出现的背景。</p>\n<ul>\n<li>CPU的发展单核心高频-&gt;多核心多线程技术</li>\n<li>单体架构-&gt;集群架构-&gt;分布式架构</li>\n</ul>\n<hr>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><ul>\n<li>效率提升</li>\n<li>横向扩容（集群）  </li>\n<li>平衡、防止单体过载</li>\n<li>空间换时间</li>\n</ul>\n<hr>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>负载均衡（Load balancing）：在计算中，负载平衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p>\n<p>将负载（工作任务）进行平衡、分摊到多个操作单元上进行执行。需要我们注意的是：它并不属于网络基础架构，而是属于一种网络优化设备。它是建立在现有的网络基础架构之上，给企业提供了更廉价更有效的扩展选择。</p>\n<p>个人总结：将负载进行平衡，将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备。</p>\n<hr>\n<h2 id=\"为了解决的问题\"><a href=\"#为了解决的问题\" class=\"headerlink\" title=\"为了解决的问题\"></a>为了解决的问题</h2><p>流量堵塞、效率缓慢、运行不畅，提高业务的处理能力，服务的高可用性。</p>\n<hr>\n<h2 id=\"硬件负载均衡-amp-软件负载均衡\"><a href=\"#硬件负载均衡-amp-软件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡&amp;软件负载均衡\"></a>硬件负载均衡&amp;软件负载均衡</h2><p>硬件负载均衡不做讨论。列举一些产品：</p>\n<ul>\n<li>F5 BIG-IP负载均衡器（LTM）</li>\n<li>思科</li>\n<li>Radware的AppDirector系列</li>\n<li>…</li>\n</ul>\n<hr>\n<h2 id=\"网络七层协议\"><a href=\"#网络七层协议\" class=\"headerlink\" title=\"网络七层协议\"></a>网络七层协议</h2><ol>\n<li>物理层 </li>\n<li>数据链路层</li>\n<li>网络层</li>\n<li>传输层</li>\n<li>会话层</li>\n<li>表示层</li>\n<li>应用层</li>\n</ol>\n<hr>\n<h2 id=\"负载均衡的场景\"><a href=\"#负载均衡的场景\" class=\"headerlink\" title=\"负载均衡的场景\"></a>负载均衡的场景</h2><h3 id=\"浏览器发送请求后发生了什么？\"><a href=\"#浏览器发送请求后发生了什么？\" class=\"headerlink\" title=\"浏览器发送请求后发生了什么？\"></a>浏览器发送请求后发生了什么？</h3><ul>\n<li>DNS服务器，DNS本身是一个基于UDP协议的网络协议，查询IP地址信息。</li>\n<li>浏览器获得真正的IP、port、通过TCP协议发起网络访问</li>\n<li>Web Server（协议处理、静态文件、动态内容）</li>\n<li>调用不同服务、不同接口等进行处理</li>\n<li>响应</li>\n</ul>\n<h3 id=\"全局负载均衡系统（GSLB）\"><a href=\"#全局负载均衡系统（GSLB）\" class=\"headerlink\" title=\"全局负载均衡系统（GSLB）\"></a>全局负载均衡系统（GSLB）</h3><p>全局负载均衡主要用于在多个区域拥有自己服务器的站点，为了使全球用户只以一个IP地址或域名就能访问到离自己最近的服务器，从而获得最快的访问速度。</p>\n<ul>\n<li>内容分发网络（CDN）</li>\n<li><p>DNS轮询<br><img src=\"/image/loadbalancing/DNS.png\" alt=\"DNS-photo\"><br>利用DNS处理域名解析请求的同时进行负载均衡是另一种常用的方案。在DNS服务器中配置多个A记录，如：xxx IN A 114.100.80.1、xxx IN A 114.100.80.2、xxx IN A 114.100.80.3.<br>每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p>\n</li>\n<li><p>HTTP重定向</p>\n</li>\n</ul>\n<h3 id=\"服务器负载均衡系统（SLB）\"><a href=\"#服务器负载均衡系统（SLB）\" class=\"headerlink\" title=\"服务器负载均衡系统（SLB）\"></a>服务器负载均衡系统（SLB）</h3><ul>\n<li>数据链路层负载均衡<br><img src=\"/image/loadbalancing/LVS.png\" alt=\"LVS-photo\"></li>\n</ul>\n<p>数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。</p>\n<p>这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一样，从而达到负载均衡，这种负载均衡方式又称为直接路由方式（DR）.</p>\n<p>在上图中，用户请求到达负载均衡服务器后，负载均衡服务器将请求数据的目的mac地址修改为真是WEB服务器的mac地址，并不修改数据包目标IP地址，因此数据可以正常到达目标WEB服务器，该服务器在处理完数据后可以经过网管服务器而不是负载均衡服务器直接到达用户浏览器。</p>\n<p>使用三角传输模式的链路层负载均衡是目前大型网站所使用的最广的一种负载均衡手段。在linux平台上最好的链路层负载均衡开源产品是LVS(linux virtual server)。</p>\n<ul>\n<li>IP负载均衡（SNAT）<br><img src=\"/image/loadbalancing/IP.png\" alt=\"IP-photo\"></li>\n</ul>\n<p>IP负载均衡：即在网络层通过修改请求目标地址进行负载均衡。</p>\n<p>用户请求数据包到达负载均衡服务器后，负载均衡服务器在操作系统内核进行获取网络数据包，根据负载均衡算法计算得到一台真实的WEB服务器地址，然后将数据包的IP地址修改为真实的WEB服务器地址，不需要通过用户进程处理。真实的WEB服务器处理完毕后，相应数据包回到负载均衡服务器，负载均衡服务器再将数据包源地址修改为自身的IP地址发送给用户浏览器。</p>\n<p>这里的关键在于真实WEB服务器相应数据包如何返回给负载均衡服务器，一种是负载均衡服务器在修改目的IP地址的同时修改源地址，将数据包源地址改为自身的IP，即源地址转换（SNAT），另一种方案是将负载均衡服务器同时作为真实物理服务器的网关服务器，这样所有的数据都会到达负载均衡服务器。</p>\n<p>IP负载均衡在内核进程完成数据分发，较反向代理均衡有更好的处理性能。但由于所有请求响应的数据包都需要经过负载均衡服务器，因此负载均衡的网卡带宽成为系统的瓶颈。</p>\n<hr>\n<h2 id=\"常用的负载均衡\"><a href=\"#常用的负载均衡\" class=\"headerlink\" title=\"常用的负载均衡\"></a>常用的负载均衡</h2><ul>\n<li>FW-F5-IHS-核心（三层）交换机-WAS<br><img src=\"/image/loadbalancing/F5_ISH_WAS.png\" alt=\"F5-photo\"></li>\n<li>VIP-Nginx-Keepalived-webserver<br><img src=\"/image/loadbalancing/Nginx-Keepalived.png\" alt=\"Nginx-photo\"></li>\n</ul>\n<hr>\n<h3 id=\"服务底层负载均衡\"><a href=\"#服务底层负载均衡\" class=\"headerlink\" title=\"服务底层负载均衡\"></a>服务底层负载均衡</h3><ul>\n<li>分布系统中服务的负载均衡，如SpringCloud Ribbon、Zookeeper。</li>\n</ul>\n<hr>\n<h2 id=\"网络分层中的负载均衡区别\"><a href=\"#网络分层中的负载均衡区别\" class=\"headerlink\" title=\"网络分层中的负载均衡区别\"></a>网络分层中的负载均衡区别</h2><p>服务器负载均衡根据LB设备处理到的报文层次，分为四层服务器负载均衡和七层负载均衡。</p>\n<ul>\n<li>技术原理上的区别</li>\n</ul>\n<p>四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP)，直接转发给该服务器。<br>TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>\n<p>七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。<br>以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。</p>\n<p><img src=\"/image/loadbalancing/loadbalancing_layer4&amp;7.jpeg\" alt=\"layer4&amp;7-photo\"></p>\n<ul>\n<li>应用场景的需求</li>\n</ul>\n<p>七层应用负载的好处，是使得整个网络更”智能化”, 例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术。<br>将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。当然这只是七层应用的一个小案例，从技术原理上，这种方式可以对客户端的请求和服务器的响应进行任意意义上的修改，极大的提升了应用系统在网络层的灵活性。很多在后台，(例如Nginx或者Apache)上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。</p>\n<ul>\n<li>安全性</li>\n</ul>\n<p>是否真的可以提高安全性</p>\n<p>是否有足够的灵活度</p>\n<hr>\n<h2 id=\"正向代理-amp-反向代理\"><a href=\"#正向代理-amp-反向代理\" class=\"headerlink\" title=\"正向代理&amp;反向代理\"></a>正向代理&amp;反向代理</h2><ul>\n<li><p>正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 </p>\n</li>\n<li><p>反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 </p>\n</li>\n</ul>\n<hr>\n<h2 id=\"服务端负载均衡-amp-客户端负载均衡\"><a href=\"#服务端负载均衡-amp-客户端负载均衡\" class=\"headerlink\" title=\"服务端负载均衡&amp;客户端负载均衡\"></a>服务端负载均衡&amp;客户端负载均衡</h2><hr>\n<h2 id=\"负载均衡服务\"><a href=\"#负载均衡服务\" class=\"headerlink\" title=\"负载均衡服务\"></a>负载均衡服务</h2><ul>\n<li>四层：F5、LVS</li>\n<li>七层：Nginx、HAproxy</li>\n<li>协调：Keepalived</li>\n</ul>\n<hr>\n<h2 id=\"负载均衡云服务\"><a href=\"#负载均衡云服务\" class=\"headerlink\" title=\"负载均衡云服务\"></a>负载均衡云服务</h2><ul>\n<li>阿里SLB</li>\n<li>Amazon ELB</li>\n<li>Citrix ADC</li>\n<li>腾讯 CLB</li>\n<li>Radware的AppDirector</li>\n</ul>\n<hr>\n<h2 id=\"负载均衡组件\"><a href=\"#负载均衡组件\" class=\"headerlink\" title=\"负载均衡组件\"></a>负载均衡组件</h2><ul>\n<li>zookeeper</li>\n<li>spring-cloud-ribbon客户端负载均衡</li>\n<li>spring-cloud-zuul实现反向代理和负载均衡</li>\n</ul>\n<hr>\n<h2 id=\"负载均衡策咯\"><a href=\"#负载均衡策咯\" class=\"headerlink\" title=\"负载均衡策咯\"></a>负载均衡策咯</h2><ul>\n<li>轮循(Round Robin) &amp; 加权轮循(Weighted Round Robin)</li>\n<li>最少连接数(Least Connection)</li>\n<li>最少连接数慢启动时间(Least Connection Slow Start Time)</li>\n<li>基于代理的自适应负载均衡(Agent Based Adaptive Balancing)</li>\n<li>固定权重(Fixed Weighted)</li>\n<li>加权响应(Weighted Response)</li>\n<li>源IP哈希(Source IP Hash)</li>\n</ul>\n<hr>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li>Load Balancing (computing) WIKI：<a href=\"https://en.wikipedia.org/wiki/Load_balancing_(computing)\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Load_balancing_(computing)</a></li>\n<li>四层/七层负载均衡区别：<a href=\"https://www.jianshu.com/p/fa937b8e6712\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fa937b8e6712</a></li>\n<li>软/硬件负载均衡产品知多少：<a href=\"https://www.cnblogs.com/lcword/p/5773296.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lcword/p/5773296.html</a></li>\n<li>全局负载均衡与CDN网络简介：<a href=\"https://blog.csdn.net/u010340143/article/details/9062213\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010340143/article/details/9062213</a></li>\n<li>大型网络-负载均衡架构：<a href=\"http://www.cnblogs.com/and/p/3366400.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/and/p/3366400.html</a></li>\n<li>Nginx实现负载均衡+keepalived实现Nginx高可用：<a href=\"https://www.cnblogs.com/youzhibing/p/7327342.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/youzhibing/p/7327342.html</a></li>\n<li>正向代理&amp;反向代理：<a href=\"https://blog.csdn.net/zt15732625878/article/details/78941268\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zt15732625878/article/details/78941268</a></li>\n<li>常见负载均衡算法：<a href=\"https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/will-shun/archive/2017/09/22/7574644.html</a></li>\n</ul>\n"},{"title":"Thead Pool","date":"2018-10-31T02:00:00.000Z","_content":"\n# 线程模型分享 （上）\n\n本篇文章是公司大佬**约拿**上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。\n\n## 引言\n> 为什么有这篇文章？\n\n起先看我的目标是看netty的线程模型，但是在看netty的过程中，我发现很多知识点是互相关联的。比如netty的EventLoop，EventLoopGroup其实是继承自JDK的线程池。学习netty的线程模型前需要懂得预备知识。基于这个理由，我把预备内容部分也写下来。分享一共会分为上下两篇，这里是第上篇，这篇主要是先导，给【下篇】的知识打基础，有了上篇的基础再看下篇就容易多了。\n\n> 这篇文章会有什么内容？\n- JDK线程池的类继承层次\n- 构建线程池的几个核心要素\n- JDK线程池关键方法的分析\n- JDK线程池存在的问题\n- 常见的线程模型举例\n- 线程模型适用场景分析 \n- 线程竞争与锁\n\n> 文章目的\n- 可以自定义JDK线程池，了解JDK线程池的局限场景\n- 了解线程模型的原理及适用场景\n- 了解锁的目的及分类\n\n## 线程启动与停止\n> 如何启动线程\n\n这个比较基础的不说了\n\n> 如何停止线程\n\n1. 线程类有stop，suspend方法，但是被弃用了。\n- **stop** 会立即杀死线程，可能导致执行一半的程序被终结导致数据不一致的风险\n- **suspend** 会挂起线程，但是不会释放锁，可能会造成思索\n- 线程池有个 **shutdown** 方法只是阻止线程池接受新的线程 ，并不会停止已存在的线程。\n2. 正确的方法\n- 线程自己运行完成\n- 设置终止标志，在循环中检查这个标志\n\n\n## JDK线程池继承层次\n### 结构图\n![image](https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png)\n这个图上很多类不用看，因为都是Executors类的内部类，代理类，核心就是下图的几个接口和类。\n\n![image](https://user-images.githubusercontent.com/5201798/47539187-a74f8000-d901-11e8-9f94-f8f4be0477a0.png)\n\n\t\n### 线程池核心要素\n- 核心线程池大小 corePoolSize\n> 设置一个线程池中的核心线程数 如果设置allowCoreThreadTimeOut为false的情况下： 即使当线程池中的线程处于空闲状态，这些线程也不会被线程池中移除。 如果设置了allowCoreThreadTimeOut为true, 那么当核心线程在空闲了一段时间后依旧没有用于工作，那么将会从线程池中移除。 注意:(allowCoreThreadTimeOut默认为false，通常情况下也无需做修改)\n\n- 线程保持活跃时间\n> keepAliveTime:当线程池中的线程数量大于核心线程数，如果这些多出的线程在经过了keepAliveTime时间后，依然处于空闲状态，那么这些多出的空闲线程将会被结束其生命周期。\n\n- 时间单位unit\n> keepAliveTime的时间单位\n\n- 最大线程池大小 maximumPoolSize\n> 线程池中所允许创建最大线程数量，除了受JVM内存大小限制外，Linux下还受/proc/sys/kernel/pid_max（即系统允许的最大pid）、/proc/sys/kernel/threads-max（系统支持的最大线程数）、max_user_process（ulimit-u）（每个用户允许的最大进程数）、/proc/sys/vm/max_map_count（Linux支持虚拟内存，也就是交换空间,可以把磁盘的一部分作为RAM的扩展，逻辑存储和物理存储的映射就要保存在地址映射表中。max_map_count限制了线程可以拥有的VMAs ）\n\n- 拒绝策略handler\n> 当线程池中的线程数量达到最大并且阻塞队列也已经满了无法再添加任务时，线程池所采取的处理策略，JDK有四种内建的拒绝策略，下面会讲到。\n\n- 等待队列workQueue\n> 用于存放任务的阻塞队列，当线程池中的核心线程都处在执行任务时，提交的任务将被存储在workQueue进行缓冲。该队列只能存放通过execute方法提交的Runnable任务，如果是个ScheduledThreadPoolExecutor，那么这个队列不仅需要阻塞，而且还是个优先队列。\n\n### 核心代码分析  \nThreadPoolExecutor 一个根正苗红的线程池继承类。\n- 我们看看他的excute方法\n```\n这里是调用\nint corePoolSize = 1;\nint maximumPoolSize = 2;\nlong keepAliveTime = 60;\nTimeUnit unit = TimeUnit.SECONDS;\nBlockingQueue<Runnable> workQueue = new LinkedBlockingDeque<>();\n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime\n        , unit, workQueue, Executors.defaultThreadFactory(), new RejectedExecutionHandler() {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        throw new RejectedExecutionException(\"Task \" + r.toString() +\n                \" rejected from \" +\n                e.toString());\n    }\n});\n\nthreadPoolExecutor.execute(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"execute!\");\n    }\n});\n=========================\n\n看看execute的源码\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    // workerCountOf 从ctl中取工作线程的数量，这里有一定的技巧性，下面详细讲一下\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 看当前线程池状态是否Running，这里也是从ctl取值，有点意思\n    // 把任务用offer方法塞进工作队列，如果插入成功，则返回ture\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 二次检查线程池状态是否为Running，以及从任务队列获取当前任务是否成功\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            // addWorker方法里通过两个for循环通过ctl判断线程池的当前状态是否能新增线程，通过CAS机制修改线程池状态。最后新建worker对象，插入worker队列。\n            addWorker(null, false);\n    }\n    // 线程池的线程数量不够了，增加线程，增加失败的话就拒绝这次execute调用\n    else if (!addWorker(command, false))\n        // reject方法里其实是调用定义线程池的时候构造函数传入的handler，JDK内建了四个拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy，含义分别是：抛出RejectedExecutionException异常、直接忽略提交的任务、把之前提交的任务移除，添加新的任务、让当前线程直接处理这个任务。用户也可以实现RejectedExecutionHandler接口，完成自己的拒绝策略。\n        reject(command);\n    }\n```\n\n- DefaultThreadFactory  \n```\nstatic class DefaultThreadFactory implements ThreadFactory {\n    private static final AtomicInteger poolNumber = new AtomicInteger(1);\n    private final ThreadGroup group;\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String namePrefix;\n\n    DefaultThreadFactory() {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n                              Thread.currentThread().getThreadGroup();\n        namePrefix = \"pool-\" +\n                      poolNumber.getAndIncrement() +\n                     \"-thread-\";\n    }\n\n    // 核心是这个newThread方法\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                              namePrefix + threadNumber.getAndIncrement(),\n                              0);\n        if (t.isDaemon())\n            t.setDaemon(false);\n        if (t.getPriority() != Thread.NORM_PRIORITY)\n            t.setPriority(Thread.NORM_PRIORITY);\n        return t;\n    }\n}\n```\n- ctl是如何存储线程状态和数量的\n```\n定义\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n\n上面那串定义看了可能有点懵，源码中使用了一个AtomicInteger对将当前线程的工作状态和工作线程数量(有效线程数)使用同一个整数进行包装。\n为了将两个数值包装在同一个整数中，它将32位的高3位表示线程的状态值，而后29位来表示线程的数量。\n其实这样设计的理由很简单，因为线程的状态和数量往往需要同时更新，然而线程池天生处在一个并发的环境下，那么当对2个变量进行修改时，那么就势必需要通过锁来进行线程安全的处理，从而保证2个变量修改具备原子性；但是这种做法对于性能的影响是非常严重的，因此在ThreadPoolExecutor将两个变量的分别包装在一个变量中，最后的并发操作发生在AtomicInteger上，而AtomicInteger恰恰就是具有一个无锁原子操作类,这样既可以解决线程安全的问题，又可以规避避免所的使用，从而提供性能。\n```\n- ScheduledThreadPoolExecutor如何实现调度\n```\nTODO\n优先队列\n```\n        \n### JDK线程池存在的问题\n- FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n- CachedThreadPool 和 ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 \n- 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n- ScheduledExecutorService并发执行大量调度时候有瓶颈，大并发量的线程调度应该用时间环模式。 \n\n~~不要感觉自己写几千行的类是很烂的代码，ThreadPoolExecutor也有2100多行（含注释）~~\n\n## 线程竞争\n### 线程竞争的定义\n在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。这里涉及到线程锁\n\n### 用锁控制线程间的竞争\n> 这里介绍锁的基本概念以及常见分类，详细在另外的时间再做。\n\n- 共享锁/排它锁 \n\n```\n共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。\n共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。 \n在这里理解共享锁的时候，不是任意时刻都允许多线程持有共享锁的，而是在某些特殊情况下才允许多线程持有共享锁，在某些情况下不允许多个线程持有共享锁，否则，如果没有前提条件任意时刻都允许线程任意持有共享锁，则共享锁的存在无意义的。例如读写锁中的读锁，只有当没有写锁和写锁请求的时候，就可以允许多个线程同时持有读锁。这里的前提条件就是“没有写锁和写锁请求”，而不是任意时刻都允许多线程持有共享读锁。\n```\n- 悲观锁/乐观锁  \n\n```\n主要用于数据库数据的操作中，而对于线程锁中较为少见。\n悲观锁和乐观锁是一种加锁思想。对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。\n对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。\n```\n- 可重入锁/不可重入\n\n```\n这两个概念是从同一个线程在已经持有锁的前提下能否再次持有锁的角度来区分的。\n对于可重入锁，如果该线程已经获取到锁且未释放的情况下允许再次获取该锁访问临界区资源。此种情况主要是用在递归调用的情况下和不同的临界区使用相同的锁的情况下。\n对于不可重入锁，则不允许同一线程在持有锁的情况下再次获取该锁并访问临界区资源。对于不可重入锁，使用的时候需要小心以免造成死锁。\n```\n- 公平锁/非公平锁\n\n```\n这两个概念主要使用线程获取锁的顺序角度来区分的。\n对于公平锁，所有等待的线程按照按照请求锁的先后循序分别依次获取锁。\n对于非公平锁，等待线程的线程获取锁的顺序和请求的先后不是对应关系。有可能是随机的获取锁，也有可能按照其他策略获取锁，总之不是按照FIFO的顺序获取锁。\n在使用ReentrantLock的时候可以通过构造方法主动选择是实现公平锁还是非公平锁。\n```\n- 自旋锁/非自旋锁\n\n```\n这两种概念是从线程等待的处理机制来区分的。\n自旋锁在进行锁请求等待的时候不进行wait挂起，不释放CPU资源，执行while空循环。直至获取锁访问临界区资源。适用于等待锁时间较短的情景，如果等待时间较长，则会耗费大量的CPU资源。而如果等待时间较短则可以节约大量的线程切换资源。\n非自旋锁在进行锁等待的时候会释放CPU资源，可以通多sleep wait 或者CPU中断切换上下文，切换该线程。在线程等待时间较长的情况下可以选择此种实现机制。\n除此之外还有一种介于两者之间的锁机制——自适应自旋锁。当线程进行等待的时候先进性自旋等待，在自旋一定时间(次数)之后如果依旧没有持有锁则挂起等待。在jvm中synchronized锁已经使用该机制进行处理锁等待的情况。\n在工作中可以根据不同的情况选取合适的锁进行使用。无论使用哪种锁，其目的都是保证程序能够按照要求顺利执行，避免数据混乱情况的发生。\n```\n详细的[参考](https://www.cnblogs.com/PerkinsZhu/p/7392006.html)这里\n### 锁的弊端\n不管是何种锁，本质上都是对资源的访问加以限制，让同一时间只有一个线程访问资源。在高并发的时候，锁往往会成为系统的瓶颈，更不用说同时带来的死锁风险。\n\n### 不用锁解决线程安全的方式\n我们接下来讨论有无高效解决线程竞争的模式，避免锁带来的以上问题。\n\n## 常见线程模型\n\n### 线程模型的定义\n线程模型决定了应用或框架如何执行代码，所以选择正确的线程模型是很重要的事情。通俗的讲，如果同样给你一定数量的线程如（100个），分析实际的业务场景，如何让它们的效率最大化。这就是选取线程模型应该做的事情。\n> 同时线程模型也指线程映射到操作系统进程的模型 https://blog.csdn.net/lyc201219/article/details/79228575\n\n- Future模型\n\n结合Callable接口配合使用，Callable是类似于Runnable的接口。Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。如果不使用Future模型，就需要使用到一个全局变量来保存子线程处理之后的结果。子线程处理结束之后，把结果保存在全局变量中供主线程进行调用。一旦涉及到全局能量便存在着多线程读写全局变量错误的风险。\n\n```\nExecutorService executorService = Executors.newFixedThreadPool(5);\nFuture<?> future = executorService.submit(new Callable<Object>() {\n    @Override\n    public Object call() throws Exception {\n\n        return null;\n    }\n});\nObject o = future.get();\n```\n- fork&join 模型\n\n该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果\n\n```\n/**\n * 将num*2 用frok&join的思想做\n */\nstatic class ResultTask extends RecursiveTask<Integer> {\n    private int num;\n\n    public ResultTask(int num) {\n        this.num = num;\n    }\n\n    @Override\n    protected Integer compute() {\n        if (num < 10) {\n            return num * 2;\n        } else {\n            //对任务进行拆分，注意这里不仅仅可以一分为二进行拆分，也可以拆为多个子任务\n            int temp = num / 2;\n            ResultTask left = new ResultTask(temp);\n            ResultTask right = new ResultTask(num - temp);\n            left.fork();\n            right.fork();\n            //对子任务处理的结果进行合并\n            int result = left.join() + right.join();\n            return result;\n        }\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinTask<Integer> future = pool.submit(new ResultTask(100));\n    try {\n        Integer integer = future.get();\n        System.out.println(integer);\n        pool.awaitTermination(1000, TimeUnit.MILLISECONDS);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    pool.shutdown();\n}\n```\n- 生产者消费者模型\n\n生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题\n\n- master-worker模型\n\nmaster-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master\n\n- actor消息模型\n\nactor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。\n\nactor并发模型的应用场景？\n适合有状态或者称可变状态的业务场景，如果用DDD术语，适合聚合根，具体案例如订单，订单有状态，比如未付款未发货，已经付款未发货，已付款已发货，导致订单状态的变化是事件行为，比如付款行为导致顶大状态切换到\"已经付款未发货\"。\n\nactor的原理\n行为导致状态变化，行为执行是依靠线程，比如用户发出一个付款的请求，服务器后端派出一个线程来执行付款请求，携带付款的金额和银行卡等等信息，当付款请求被成功完成后，线程还要做的事情就是改变订单状态，这时线程访问订单的一个方法比如changeState。如果后台有管理员同时修改这个订单状态，那么实际有两个线程共同访问同一个数据，这时就必须锁，比如我们在changeState方法前加上sychronized这样同步语法。使用同步语法坏处是每次只能一个线程进行处理，如同上厕所，只有一个蹲坑，人多就必须排队，这种情况性能很低。\n\n避免changeState方法被外部两个线程同时占用访问，那么我们自己设计专门的线程守护订单状态，而不是普通方法代码，普通方法代码比较弱势，容易被外部线程hold住，而我们设计的这个对象没有普通方法，只有线程，这样就变成Order的守护线程和外部访问请求线程的通讯问题了。Actor采取的这种类似消息机制的方式，实际在守护线程和外部线程之间有一个队列，俗称信箱，外部线程只要把请求放入，守护线程就读取进行处理。这种异步高效方式是Actor基本原理，以ERlang和Scala语言为主要特征，他们封装得更好，类似将消息队列微观化了。\n参考[使用Akka Actor和Java 8构建反应式应用](http://www.infoq.com/cn/articles/Building-Reactive-Applications-with-Akka)\n\n- reactor模型\n\n一图胜千言，来看看Doug Lea大神画的图（Scalable IO in Java）\n![image](https://images2018.cnblogs.com/blog/1424165/201808/1424165-20180803142242491-1328318201.png)\n\n\n## 参考资料\n- https://www.jianshu.com/p/20b7327f9f56 ThreadPoolExecutor源码分析\n- https://blog.csdn.net/wangjinnan16/article/details/78377642  Netty4实战第十五章：选择正确的线程模型\n- https://www.cnblogs.com/PerkinsZhu/p/7570775.html 常见线程模型介绍\n- http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf Scalable IO in Java","source":"_posts/线程池线程模型.md","raw":"---\ntitle: Thead Pool\ndate: 2018-10-31 10:00:00\ntags:\ncategories: Java\n---\n\n# 线程模型分享 （上）\n\n本篇文章是公司大佬**约拿**上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。\n\n## 引言\n> 为什么有这篇文章？\n\n起先看我的目标是看netty的线程模型，但是在看netty的过程中，我发现很多知识点是互相关联的。比如netty的EventLoop，EventLoopGroup其实是继承自JDK的线程池。学习netty的线程模型前需要懂得预备知识。基于这个理由，我把预备内容部分也写下来。分享一共会分为上下两篇，这里是第上篇，这篇主要是先导，给【下篇】的知识打基础，有了上篇的基础再看下篇就容易多了。\n\n> 这篇文章会有什么内容？\n- JDK线程池的类继承层次\n- 构建线程池的几个核心要素\n- JDK线程池关键方法的分析\n- JDK线程池存在的问题\n- 常见的线程模型举例\n- 线程模型适用场景分析 \n- 线程竞争与锁\n\n> 文章目的\n- 可以自定义JDK线程池，了解JDK线程池的局限场景\n- 了解线程模型的原理及适用场景\n- 了解锁的目的及分类\n\n## 线程启动与停止\n> 如何启动线程\n\n这个比较基础的不说了\n\n> 如何停止线程\n\n1. 线程类有stop，suspend方法，但是被弃用了。\n- **stop** 会立即杀死线程，可能导致执行一半的程序被终结导致数据不一致的风险\n- **suspend** 会挂起线程，但是不会释放锁，可能会造成思索\n- 线程池有个 **shutdown** 方法只是阻止线程池接受新的线程 ，并不会停止已存在的线程。\n2. 正确的方法\n- 线程自己运行完成\n- 设置终止标志，在循环中检查这个标志\n\n\n## JDK线程池继承层次\n### 结构图\n![image](https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png)\n这个图上很多类不用看，因为都是Executors类的内部类，代理类，核心就是下图的几个接口和类。\n\n![image](https://user-images.githubusercontent.com/5201798/47539187-a74f8000-d901-11e8-9f94-f8f4be0477a0.png)\n\n\t\n### 线程池核心要素\n- 核心线程池大小 corePoolSize\n> 设置一个线程池中的核心线程数 如果设置allowCoreThreadTimeOut为false的情况下： 即使当线程池中的线程处于空闲状态，这些线程也不会被线程池中移除。 如果设置了allowCoreThreadTimeOut为true, 那么当核心线程在空闲了一段时间后依旧没有用于工作，那么将会从线程池中移除。 注意:(allowCoreThreadTimeOut默认为false，通常情况下也无需做修改)\n\n- 线程保持活跃时间\n> keepAliveTime:当线程池中的线程数量大于核心线程数，如果这些多出的线程在经过了keepAliveTime时间后，依然处于空闲状态，那么这些多出的空闲线程将会被结束其生命周期。\n\n- 时间单位unit\n> keepAliveTime的时间单位\n\n- 最大线程池大小 maximumPoolSize\n> 线程池中所允许创建最大线程数量，除了受JVM内存大小限制外，Linux下还受/proc/sys/kernel/pid_max（即系统允许的最大pid）、/proc/sys/kernel/threads-max（系统支持的最大线程数）、max_user_process（ulimit-u）（每个用户允许的最大进程数）、/proc/sys/vm/max_map_count（Linux支持虚拟内存，也就是交换空间,可以把磁盘的一部分作为RAM的扩展，逻辑存储和物理存储的映射就要保存在地址映射表中。max_map_count限制了线程可以拥有的VMAs ）\n\n- 拒绝策略handler\n> 当线程池中的线程数量达到最大并且阻塞队列也已经满了无法再添加任务时，线程池所采取的处理策略，JDK有四种内建的拒绝策略，下面会讲到。\n\n- 等待队列workQueue\n> 用于存放任务的阻塞队列，当线程池中的核心线程都处在执行任务时，提交的任务将被存储在workQueue进行缓冲。该队列只能存放通过execute方法提交的Runnable任务，如果是个ScheduledThreadPoolExecutor，那么这个队列不仅需要阻塞，而且还是个优先队列。\n\n### 核心代码分析  \nThreadPoolExecutor 一个根正苗红的线程池继承类。\n- 我们看看他的excute方法\n```\n这里是调用\nint corePoolSize = 1;\nint maximumPoolSize = 2;\nlong keepAliveTime = 60;\nTimeUnit unit = TimeUnit.SECONDS;\nBlockingQueue<Runnable> workQueue = new LinkedBlockingDeque<>();\n\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime\n        , unit, workQueue, Executors.defaultThreadFactory(), new RejectedExecutionHandler() {\n    @Override\n    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        throw new RejectedExecutionException(\"Task \" + r.toString() +\n                \" rejected from \" +\n                e.toString());\n    }\n});\n\nthreadPoolExecutor.execute(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"execute!\");\n    }\n});\n=========================\n\n看看execute的源码\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    // workerCountOf 从ctl中取工作线程的数量，这里有一定的技巧性，下面详细讲一下\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 看当前线程池状态是否Running，这里也是从ctl取值，有点意思\n    // 把任务用offer方法塞进工作队列，如果插入成功，则返回ture\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 二次检查线程池状态是否为Running，以及从任务队列获取当前任务是否成功\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            // addWorker方法里通过两个for循环通过ctl判断线程池的当前状态是否能新增线程，通过CAS机制修改线程池状态。最后新建worker对象，插入worker队列。\n            addWorker(null, false);\n    }\n    // 线程池的线程数量不够了，增加线程，增加失败的话就拒绝这次execute调用\n    else if (!addWorker(command, false))\n        // reject方法里其实是调用定义线程池的时候构造函数传入的handler，JDK内建了四个拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy，含义分别是：抛出RejectedExecutionException异常、直接忽略提交的任务、把之前提交的任务移除，添加新的任务、让当前线程直接处理这个任务。用户也可以实现RejectedExecutionHandler接口，完成自己的拒绝策略。\n        reject(command);\n    }\n```\n\n- DefaultThreadFactory  \n```\nstatic class DefaultThreadFactory implements ThreadFactory {\n    private static final AtomicInteger poolNumber = new AtomicInteger(1);\n    private final ThreadGroup group;\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    private final String namePrefix;\n\n    DefaultThreadFactory() {\n        SecurityManager s = System.getSecurityManager();\n        group = (s != null) ? s.getThreadGroup() :\n                              Thread.currentThread().getThreadGroup();\n        namePrefix = \"pool-\" +\n                      poolNumber.getAndIncrement() +\n                     \"-thread-\";\n    }\n\n    // 核心是这个newThread方法\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                              namePrefix + threadNumber.getAndIncrement(),\n                              0);\n        if (t.isDaemon())\n            t.setDaemon(false);\n        if (t.getPriority() != Thread.NORM_PRIORITY)\n            t.setPriority(Thread.NORM_PRIORITY);\n        return t;\n    }\n}\n```\n- ctl是如何存储线程状态和数量的\n```\n定义\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n\n上面那串定义看了可能有点懵，源码中使用了一个AtomicInteger对将当前线程的工作状态和工作线程数量(有效线程数)使用同一个整数进行包装。\n为了将两个数值包装在同一个整数中，它将32位的高3位表示线程的状态值，而后29位来表示线程的数量。\n其实这样设计的理由很简单，因为线程的状态和数量往往需要同时更新，然而线程池天生处在一个并发的环境下，那么当对2个变量进行修改时，那么就势必需要通过锁来进行线程安全的处理，从而保证2个变量修改具备原子性；但是这种做法对于性能的影响是非常严重的，因此在ThreadPoolExecutor将两个变量的分别包装在一个变量中，最后的并发操作发生在AtomicInteger上，而AtomicInteger恰恰就是具有一个无锁原子操作类,这样既可以解决线程安全的问题，又可以规避避免所的使用，从而提供性能。\n```\n- ScheduledThreadPoolExecutor如何实现调度\n```\nTODO\n优先队列\n```\n        \n### JDK线程池存在的问题\n- FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n- CachedThreadPool 和 ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 \n- 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n- ScheduledExecutorService并发执行大量调度时候有瓶颈，大并发量的线程调度应该用时间环模式。 \n\n~~不要感觉自己写几千行的类是很烂的代码，ThreadPoolExecutor也有2100多行（含注释）~~\n\n## 线程竞争\n### 线程竞争的定义\n在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。这里涉及到线程锁\n\n### 用锁控制线程间的竞争\n> 这里介绍锁的基本概念以及常见分类，详细在另外的时间再做。\n\n- 共享锁/排它锁 \n\n```\n共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。\n共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。 \n在这里理解共享锁的时候，不是任意时刻都允许多线程持有共享锁的，而是在某些特殊情况下才允许多线程持有共享锁，在某些情况下不允许多个线程持有共享锁，否则，如果没有前提条件任意时刻都允许线程任意持有共享锁，则共享锁的存在无意义的。例如读写锁中的读锁，只有当没有写锁和写锁请求的时候，就可以允许多个线程同时持有读锁。这里的前提条件就是“没有写锁和写锁请求”，而不是任意时刻都允许多线程持有共享读锁。\n```\n- 悲观锁/乐观锁  \n\n```\n主要用于数据库数据的操作中，而对于线程锁中较为少见。\n悲观锁和乐观锁是一种加锁思想。对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。\n对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。\n```\n- 可重入锁/不可重入\n\n```\n这两个概念是从同一个线程在已经持有锁的前提下能否再次持有锁的角度来区分的。\n对于可重入锁，如果该线程已经获取到锁且未释放的情况下允许再次获取该锁访问临界区资源。此种情况主要是用在递归调用的情况下和不同的临界区使用相同的锁的情况下。\n对于不可重入锁，则不允许同一线程在持有锁的情况下再次获取该锁并访问临界区资源。对于不可重入锁，使用的时候需要小心以免造成死锁。\n```\n- 公平锁/非公平锁\n\n```\n这两个概念主要使用线程获取锁的顺序角度来区分的。\n对于公平锁，所有等待的线程按照按照请求锁的先后循序分别依次获取锁。\n对于非公平锁，等待线程的线程获取锁的顺序和请求的先后不是对应关系。有可能是随机的获取锁，也有可能按照其他策略获取锁，总之不是按照FIFO的顺序获取锁。\n在使用ReentrantLock的时候可以通过构造方法主动选择是实现公平锁还是非公平锁。\n```\n- 自旋锁/非自旋锁\n\n```\n这两种概念是从线程等待的处理机制来区分的。\n自旋锁在进行锁请求等待的时候不进行wait挂起，不释放CPU资源，执行while空循环。直至获取锁访问临界区资源。适用于等待锁时间较短的情景，如果等待时间较长，则会耗费大量的CPU资源。而如果等待时间较短则可以节约大量的线程切换资源。\n非自旋锁在进行锁等待的时候会释放CPU资源，可以通多sleep wait 或者CPU中断切换上下文，切换该线程。在线程等待时间较长的情况下可以选择此种实现机制。\n除此之外还有一种介于两者之间的锁机制——自适应自旋锁。当线程进行等待的时候先进性自旋等待，在自旋一定时间(次数)之后如果依旧没有持有锁则挂起等待。在jvm中synchronized锁已经使用该机制进行处理锁等待的情况。\n在工作中可以根据不同的情况选取合适的锁进行使用。无论使用哪种锁，其目的都是保证程序能够按照要求顺利执行，避免数据混乱情况的发生。\n```\n详细的[参考](https://www.cnblogs.com/PerkinsZhu/p/7392006.html)这里\n### 锁的弊端\n不管是何种锁，本质上都是对资源的访问加以限制，让同一时间只有一个线程访问资源。在高并发的时候，锁往往会成为系统的瓶颈，更不用说同时带来的死锁风险。\n\n### 不用锁解决线程安全的方式\n我们接下来讨论有无高效解决线程竞争的模式，避免锁带来的以上问题。\n\n## 常见线程模型\n\n### 线程模型的定义\n线程模型决定了应用或框架如何执行代码，所以选择正确的线程模型是很重要的事情。通俗的讲，如果同样给你一定数量的线程如（100个），分析实际的业务场景，如何让它们的效率最大化。这就是选取线程模型应该做的事情。\n> 同时线程模型也指线程映射到操作系统进程的模型 https://blog.csdn.net/lyc201219/article/details/79228575\n\n- Future模型\n\n结合Callable接口配合使用，Callable是类似于Runnable的接口。Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。如果不使用Future模型，就需要使用到一个全局变量来保存子线程处理之后的结果。子线程处理结束之后，把结果保存在全局变量中供主线程进行调用。一旦涉及到全局能量便存在着多线程读写全局变量错误的风险。\n\n```\nExecutorService executorService = Executors.newFixedThreadPool(5);\nFuture<?> future = executorService.submit(new Callable<Object>() {\n    @Override\n    public Object call() throws Exception {\n\n        return null;\n    }\n});\nObject o = future.get();\n```\n- fork&join 模型\n\n该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果\n\n```\n/**\n * 将num*2 用frok&join的思想做\n */\nstatic class ResultTask extends RecursiveTask<Integer> {\n    private int num;\n\n    public ResultTask(int num) {\n        this.num = num;\n    }\n\n    @Override\n    protected Integer compute() {\n        if (num < 10) {\n            return num * 2;\n        } else {\n            //对任务进行拆分，注意这里不仅仅可以一分为二进行拆分，也可以拆为多个子任务\n            int temp = num / 2;\n            ResultTask left = new ResultTask(temp);\n            ResultTask right = new ResultTask(num - temp);\n            left.fork();\n            right.fork();\n            //对子任务处理的结果进行合并\n            int result = left.join() + right.join();\n            return result;\n        }\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinTask<Integer> future = pool.submit(new ResultTask(100));\n    try {\n        Integer integer = future.get();\n        System.out.println(integer);\n        pool.awaitTermination(1000, TimeUnit.MILLISECONDS);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    pool.shutdown();\n}\n```\n- 生产者消费者模型\n\n生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题\n\n- master-worker模型\n\nmaster-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master\n\n- actor消息模型\n\nactor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。\n\nactor并发模型的应用场景？\n适合有状态或者称可变状态的业务场景，如果用DDD术语，适合聚合根，具体案例如订单，订单有状态，比如未付款未发货，已经付款未发货，已付款已发货，导致订单状态的变化是事件行为，比如付款行为导致顶大状态切换到\"已经付款未发货\"。\n\nactor的原理\n行为导致状态变化，行为执行是依靠线程，比如用户发出一个付款的请求，服务器后端派出一个线程来执行付款请求，携带付款的金额和银行卡等等信息，当付款请求被成功完成后，线程还要做的事情就是改变订单状态，这时线程访问订单的一个方法比如changeState。如果后台有管理员同时修改这个订单状态，那么实际有两个线程共同访问同一个数据，这时就必须锁，比如我们在changeState方法前加上sychronized这样同步语法。使用同步语法坏处是每次只能一个线程进行处理，如同上厕所，只有一个蹲坑，人多就必须排队，这种情况性能很低。\n\n避免changeState方法被外部两个线程同时占用访问，那么我们自己设计专门的线程守护订单状态，而不是普通方法代码，普通方法代码比较弱势，容易被外部线程hold住，而我们设计的这个对象没有普通方法，只有线程，这样就变成Order的守护线程和外部访问请求线程的通讯问题了。Actor采取的这种类似消息机制的方式，实际在守护线程和外部线程之间有一个队列，俗称信箱，外部线程只要把请求放入，守护线程就读取进行处理。这种异步高效方式是Actor基本原理，以ERlang和Scala语言为主要特征，他们封装得更好，类似将消息队列微观化了。\n参考[使用Akka Actor和Java 8构建反应式应用](http://www.infoq.com/cn/articles/Building-Reactive-Applications-with-Akka)\n\n- reactor模型\n\n一图胜千言，来看看Doug Lea大神画的图（Scalable IO in Java）\n![image](https://images2018.cnblogs.com/blog/1424165/201808/1424165-20180803142242491-1328318201.png)\n\n\n## 参考资料\n- https://www.jianshu.com/p/20b7327f9f56 ThreadPoolExecutor源码分析\n- https://blog.csdn.net/wangjinnan16/article/details/78377642  Netty4实战第十五章：选择正确的线程模型\n- https://www.cnblogs.com/PerkinsZhu/p/7570775.html 常见线程模型介绍\n- http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf Scalable IO in Java","slug":"线程池线程模型","published":1,"updated":"2018-10-31T03:47:05.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xionw000huog4po20o7a5","content":"<h1 id=\"线程模型分享-（上）\"><a href=\"#线程模型分享-（上）\" class=\"headerlink\" title=\"线程模型分享 （上）\"></a>线程模型分享 （上）</h1><p>本篇文章是公司大佬<strong>约拿</strong>上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><blockquote>\n<p>为什么有这篇文章？</p>\n</blockquote>\n<p>起先看我的目标是看netty的线程模型，但是在看netty的过程中，我发现很多知识点是互相关联的。比如netty的EventLoop，EventLoopGroup其实是继承自JDK的线程池。学习netty的线程模型前需要懂得预备知识。基于这个理由，我把预备内容部分也写下来。分享一共会分为上下两篇，这里是第上篇，这篇主要是先导，给【下篇】的知识打基础，有了上篇的基础再看下篇就容易多了。</p>\n<blockquote>\n<p>这篇文章会有什么内容？</p>\n<ul>\n<li>JDK线程池的类继承层次</li>\n<li>构建线程池的几个核心要素</li>\n<li>JDK线程池关键方法的分析</li>\n<li>JDK线程池存在的问题</li>\n<li>常见的线程模型举例</li>\n<li>线程模型适用场景分析 </li>\n<li>线程竞争与锁</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>文章目的</p>\n<ul>\n<li>可以自定义JDK线程池，了解JDK线程池的局限场景</li>\n<li>了解线程模型的原理及适用场景</li>\n<li>了解锁的目的及分类</li>\n</ul>\n</blockquote>\n<h2 id=\"线程启动与停止\"><a href=\"#线程启动与停止\" class=\"headerlink\" title=\"线程启动与停止\"></a>线程启动与停止</h2><blockquote>\n<p>如何启动线程</p>\n</blockquote>\n<p>这个比较基础的不说了</p>\n<blockquote>\n<p>如何停止线程</p>\n</blockquote>\n<ol>\n<li>线程类有stop，suspend方法，但是被弃用了。</li>\n</ol>\n<ul>\n<li><strong>stop</strong> 会立即杀死线程，可能导致执行一半的程序被终结导致数据不一致的风险</li>\n<li><strong>suspend</strong> 会挂起线程，但是不会释放锁，可能会造成思索</li>\n<li>线程池有个 <strong>shutdown</strong> 方法只是阻止线程池接受新的线程 ，并不会停止已存在的线程。</li>\n</ul>\n<ol start=\"2\">\n<li>正确的方法</li>\n</ol>\n<ul>\n<li>线程自己运行完成</li>\n<li>设置终止标志，在循环中检查这个标志</li>\n</ul>\n<h2 id=\"JDK线程池继承层次\"><a href=\"#JDK线程池继承层次\" class=\"headerlink\" title=\"JDK线程池继承层次\"></a>JDK线程池继承层次</h2><h3 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h3><p><img src=\"https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png\" alt=\"image\"><br>这个图上很多类不用看，因为都是Executors类的内部类，代理类，核心就是下图的几个接口和类。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5201798/47539187-a74f8000-d901-11e8-9f94-f8f4be0477a0.png\" alt=\"image\"></p>\n<h3 id=\"线程池核心要素\"><a href=\"#线程池核心要素\" class=\"headerlink\" title=\"线程池核心要素\"></a>线程池核心要素</h3><ul>\n<li><p>核心线程池大小 corePoolSize</p>\n<blockquote>\n<p>设置一个线程池中的核心线程数 如果设置allowCoreThreadTimeOut为false的情况下： 即使当线程池中的线程处于空闲状态，这些线程也不会被线程池中移除。 如果设置了allowCoreThreadTimeOut为true, 那么当核心线程在空闲了一段时间后依旧没有用于工作，那么将会从线程池中移除。 注意:(allowCoreThreadTimeOut默认为false，通常情况下也无需做修改)</p>\n</blockquote>\n</li>\n<li><p>线程保持活跃时间</p>\n<blockquote>\n<p>keepAliveTime:当线程池中的线程数量大于核心线程数，如果这些多出的线程在经过了keepAliveTime时间后，依然处于空闲状态，那么这些多出的空闲线程将会被结束其生命周期。</p>\n</blockquote>\n</li>\n<li><p>时间单位unit</p>\n<blockquote>\n<p>keepAliveTime的时间单位</p>\n</blockquote>\n</li>\n<li><p>最大线程池大小 maximumPoolSize</p>\n<blockquote>\n<p>线程池中所允许创建最大线程数量，除了受JVM内存大小限制外，Linux下还受/proc/sys/kernel/pid_max（即系统允许的最大pid）、/proc/sys/kernel/threads-max（系统支持的最大线程数）、max_user_process（ulimit-u）（每个用户允许的最大进程数）、/proc/sys/vm/max_map_count（Linux支持虚拟内存，也就是交换空间,可以把磁盘的一部分作为RAM的扩展，逻辑存储和物理存储的映射就要保存在地址映射表中。max_map_count限制了线程可以拥有的VMAs ）</p>\n</blockquote>\n</li>\n<li><p>拒绝策略handler</p>\n<blockquote>\n<p>当线程池中的线程数量达到最大并且阻塞队列也已经满了无法再添加任务时，线程池所采取的处理策略，JDK有四种内建的拒绝策略，下面会讲到。</p>\n</blockquote>\n</li>\n<li><p>等待队列workQueue</p>\n<blockquote>\n<p>用于存放任务的阻塞队列，当线程池中的核心线程都处在执行任务时，提交的任务将被存储在workQueue进行缓冲。该队列只能存放通过execute方法提交的Runnable任务，如果是个ScheduledThreadPoolExecutor，那么这个队列不仅需要阻塞，而且还是个优先队列。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"核心代码分析\"><a href=\"#核心代码分析\" class=\"headerlink\" title=\"核心代码分析\"></a>核心代码分析</h3><p>ThreadPoolExecutor 一个根正苗红的线程池继承类。</p>\n<ul>\n<li><p>我们看看他的excute方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里是调用</span><br><span class=\"line\">int corePoolSize = 1;</span><br><span class=\"line\">int maximumPoolSize = 2;</span><br><span class=\"line\">long keepAliveTime = 60;</span><br><span class=\"line\">TimeUnit unit = TimeUnit.SECONDS;</span><br><span class=\"line\">BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime</span><br><span class=\"line\">        , unit, workQueue, Executors.defaultThreadFactory(), new RejectedExecutionHandler() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class=\"line\">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class=\"line\">                &quot; rejected from &quot; +</span><br><span class=\"line\">                e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;execute!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">=========================</span><br><span class=\"line\"></span><br><span class=\"line\">看看execute的源码</span><br><span class=\"line\">public void execute(Runnable command) &#123;</span><br><span class=\"line\">    if (command == null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    int c = ctl.get();</span><br><span class=\"line\">    // workerCountOf 从ctl中取工作线程的数量，这里有一定的技巧性，下面详细讲一下</span><br><span class=\"line\">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        if (addWorker(command, true))</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 看当前线程池状态是否Running，这里也是从ctl取值，有点意思</span><br><span class=\"line\">    // 把任务用offer方法塞进工作队列，如果插入成功，则返回ture</span><br><span class=\"line\">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        int recheck = ctl.get();</span><br><span class=\"line\">        // 二次检查线程池状态是否为Running，以及从任务队列获取当前任务是否成功</span><br><span class=\"line\">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        else if (workerCountOf(recheck) == 0)</span><br><span class=\"line\">            // addWorker方法里通过两个for循环通过ctl判断线程池的当前状态是否能新增线程，通过CAS机制修改线程池状态。最后新建worker对象，插入worker队列。</span><br><span class=\"line\">            addWorker(null, false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 线程池的线程数量不够了，增加线程，增加失败的话就拒绝这次execute调用</span><br><span class=\"line\">    else if (!addWorker(command, false))</span><br><span class=\"line\">        // reject方法里其实是调用定义线程池的时候构造函数传入的handler，JDK内建了四个拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy，含义分别是：抛出RejectedExecutionException异常、直接忽略提交的任务、把之前提交的任务移除，添加新的任务、让当前线程直接处理这个任务。用户也可以实现RejectedExecutionHandler接口，完成自己的拒绝策略。</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DefaultThreadFactory  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class=\"line\">    private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br><span class=\"line\">    private final ThreadGroup group;</span><br><span class=\"line\">    private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br><span class=\"line\">    private final String namePrefix;</span><br><span class=\"line\"></span><br><span class=\"line\">    DefaultThreadFactory() &#123;</span><br><span class=\"line\">        SecurityManager s = System.getSecurityManager();</span><br><span class=\"line\">        group = (s != null) ? s.getThreadGroup() :</span><br><span class=\"line\">                              Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">        namePrefix = &quot;pool-&quot; +</span><br><span class=\"line\">                      poolNumber.getAndIncrement() +</span><br><span class=\"line\">                     &quot;-thread-&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 核心是这个newThread方法</span><br><span class=\"line\">    public Thread newThread(Runnable r) &#123;</span><br><span class=\"line\">        Thread t = new Thread(group, r,</span><br><span class=\"line\">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class=\"line\">                              0);</span><br><span class=\"line\">        if (t.isDaemon())</span><br><span class=\"line\">            t.setDaemon(false);</span><br><span class=\"line\">        if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">        return t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ctl是如何存储线程状态和数量的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义</span><br><span class=\"line\">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class=\"line\">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class=\"line\">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// runState is stored in the high-order bits</span><br><span class=\"line\">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">// Packing and unpacking ctl</span><br><span class=\"line\">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class=\"line\">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">上面那串定义看了可能有点懵，源码中使用了一个AtomicInteger对将当前线程的工作状态和工作线程数量(有效线程数)使用同一个整数进行包装。</span><br><span class=\"line\">为了将两个数值包装在同一个整数中，它将32位的高3位表示线程的状态值，而后29位来表示线程的数量。</span><br><span class=\"line\">其实这样设计的理由很简单，因为线程的状态和数量往往需要同时更新，然而线程池天生处在一个并发的环境下，那么当对2个变量进行修改时，那么就势必需要通过锁来进行线程安全的处理，从而保证2个变量修改具备原子性；但是这种做法对于性能的影响是非常严重的，因此在ThreadPoolExecutor将两个变量的分别包装在一个变量中，最后的并发操作发生在AtomicInteger上，而AtomicInteger恰恰就是具有一个无锁原子操作类,这样既可以解决线程安全的问题，又可以规避避免所的使用，从而提供性能。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ScheduledThreadPoolExecutor如何实现调度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br><span class=\"line\">优先队列</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"JDK线程池存在的问题\"><a href=\"#JDK线程池存在的问题\" class=\"headerlink\" title=\"JDK线程池存在的问题\"></a>JDK线程池存在的问题</h3><ul>\n<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>\n<li>CachedThreadPool 和 ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 </li>\n<li>多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</li>\n<li>ScheduledExecutorService并发执行大量调度时候有瓶颈，大并发量的线程调度应该用时间环模式。 </li>\n</ul>\n<p><del>不要感觉自己写几千行的类是很烂的代码，ThreadPoolExecutor也有2100多行（含注释）</del></p>\n<h2 id=\"线程竞争\"><a href=\"#线程竞争\" class=\"headerlink\" title=\"线程竞争\"></a>线程竞争</h2><h3 id=\"线程竞争的定义\"><a href=\"#线程竞争的定义\" class=\"headerlink\" title=\"线程竞争的定义\"></a>线程竞争的定义</h3><p>在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。这里涉及到线程锁</p>\n<h3 id=\"用锁控制线程间的竞争\"><a href=\"#用锁控制线程间的竞争\" class=\"headerlink\" title=\"用锁控制线程间的竞争\"></a>用锁控制线程间的竞争</h3><blockquote>\n<p>这里介绍锁的基本概念以及常见分类，详细在另外的时间再做。</p>\n</blockquote>\n<ul>\n<li>共享锁/排它锁 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。</span><br><span class=\"line\">共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。 </span><br><span class=\"line\">在这里理解共享锁的时候，不是任意时刻都允许多线程持有共享锁的，而是在某些特殊情况下才允许多线程持有共享锁，在某些情况下不允许多个线程持有共享锁，否则，如果没有前提条件任意时刻都允许线程任意持有共享锁，则共享锁的存在无意义的。例如读写锁中的读锁，只有当没有写锁和写锁请求的时候，就可以允许多个线程同时持有读锁。这里的前提条件就是“没有写锁和写锁请求”，而不是任意时刻都允许多线程持有共享读锁。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>悲观锁/乐观锁  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要用于数据库数据的操作中，而对于线程锁中较为少见。</span><br><span class=\"line\">悲观锁和乐观锁是一种加锁思想。对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。</span><br><span class=\"line\">对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可重入锁/不可重入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这两个概念是从同一个线程在已经持有锁的前提下能否再次持有锁的角度来区分的。</span><br><span class=\"line\">对于可重入锁，如果该线程已经获取到锁且未释放的情况下允许再次获取该锁访问临界区资源。此种情况主要是用在递归调用的情况下和不同的临界区使用相同的锁的情况下。</span><br><span class=\"line\">对于不可重入锁，则不允许同一线程在持有锁的情况下再次获取该锁并访问临界区资源。对于不可重入锁，使用的时候需要小心以免造成死锁。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>公平锁/非公平锁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这两个概念主要使用线程获取锁的顺序角度来区分的。</span><br><span class=\"line\">对于公平锁，所有等待的线程按照按照请求锁的先后循序分别依次获取锁。</span><br><span class=\"line\">对于非公平锁，等待线程的线程获取锁的顺序和请求的先后不是对应关系。有可能是随机的获取锁，也有可能按照其他策略获取锁，总之不是按照FIFO的顺序获取锁。</span><br><span class=\"line\">在使用ReentrantLock的时候可以通过构造方法主动选择是实现公平锁还是非公平锁。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自旋锁/非自旋锁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这两种概念是从线程等待的处理机制来区分的。</span><br><span class=\"line\">自旋锁在进行锁请求等待的时候不进行wait挂起，不释放CPU资源，执行while空循环。直至获取锁访问临界区资源。适用于等待锁时间较短的情景，如果等待时间较长，则会耗费大量的CPU资源。而如果等待时间较短则可以节约大量的线程切换资源。</span><br><span class=\"line\">非自旋锁在进行锁等待的时候会释放CPU资源，可以通多sleep wait 或者CPU中断切换上下文，切换该线程。在线程等待时间较长的情况下可以选择此种实现机制。</span><br><span class=\"line\">除此之外还有一种介于两者之间的锁机制——自适应自旋锁。当线程进行等待的时候先进性自旋等待，在自旋一定时间(次数)之后如果依旧没有持有锁则挂起等待。在jvm中synchronized锁已经使用该机制进行处理锁等待的情况。</span><br><span class=\"line\">在工作中可以根据不同的情况选取合适的锁进行使用。无论使用哪种锁，其目的都是保证程序能够按照要求顺利执行，避免数据混乱情况的发生。</span><br></pre></td></tr></table></figure>\n<p>详细的<a href=\"https://www.cnblogs.com/PerkinsZhu/p/7392006.html\" target=\"_blank\" rel=\"noopener\">参考</a>这里</p>\n<h3 id=\"锁的弊端\"><a href=\"#锁的弊端\" class=\"headerlink\" title=\"锁的弊端\"></a>锁的弊端</h3><p>不管是何种锁，本质上都是对资源的访问加以限制，让同一时间只有一个线程访问资源。在高并发的时候，锁往往会成为系统的瓶颈，更不用说同时带来的死锁风险。</p>\n<h3 id=\"不用锁解决线程安全的方式\"><a href=\"#不用锁解决线程安全的方式\" class=\"headerlink\" title=\"不用锁解决线程安全的方式\"></a>不用锁解决线程安全的方式</h3><p>我们接下来讨论有无高效解决线程竞争的模式，避免锁带来的以上问题。</p>\n<h2 id=\"常见线程模型\"><a href=\"#常见线程模型\" class=\"headerlink\" title=\"常见线程模型\"></a>常见线程模型</h2><h3 id=\"线程模型的定义\"><a href=\"#线程模型的定义\" class=\"headerlink\" title=\"线程模型的定义\"></a>线程模型的定义</h3><p>线程模型决定了应用或框架如何执行代码，所以选择正确的线程模型是很重要的事情。通俗的讲，如果同样给你一定数量的线程如（100个），分析实际的业务场景，如何让它们的效率最大化。这就是选取线程模型应该做的事情。</p>\n<blockquote>\n<p>同时线程模型也指线程映射到操作系统进程的模型 <a href=\"https://blog.csdn.net/lyc201219/article/details/79228575\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lyc201219/article/details/79228575</a></p>\n</blockquote>\n<ul>\n<li>Future模型</li>\n</ul>\n<p>结合Callable接口配合使用，Callable是类似于Runnable的接口。Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。如果不使用Future模型，就需要使用到一个全局变量来保存子线程处理之后的结果。子线程处理结束之后，把结果保存在全局变量中供主线程进行调用。一旦涉及到全局能量便存在着多线程读写全局变量错误的风险。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class=\"line\">Future&lt;?&gt; future = executorService.submit(new Callable&lt;Object&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object call() throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Object o = future.get();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fork&amp;join 模型</li>\n</ul>\n<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 将num*2 用frok&amp;join的思想做</span><br><span class=\"line\"> */</span><br><span class=\"line\">static class ResultTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class=\"line\">    private int num;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ResultTask(int num) &#123;</span><br><span class=\"line\">        this.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Integer compute() &#123;</span><br><span class=\"line\">        if (num &lt; 10) &#123;</span><br><span class=\"line\">            return num * 2;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //对任务进行拆分，注意这里不仅仅可以一分为二进行拆分，也可以拆为多个子任务</span><br><span class=\"line\">            int temp = num / 2;</span><br><span class=\"line\">            ResultTask left = new ResultTask(temp);</span><br><span class=\"line\">            ResultTask right = new ResultTask(num - temp);</span><br><span class=\"line\">            left.fork();</span><br><span class=\"line\">            right.fork();</span><br><span class=\"line\">            //对子任务处理的结果进行合并</span><br><span class=\"line\">            int result = left.join() + right.join();</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">    ForkJoinPool pool = new ForkJoinPool();</span><br><span class=\"line\">    ForkJoinTask&lt;Integer&gt; future = pool.submit(new ResultTask(100));</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Integer integer = future.get();</span><br><span class=\"line\">        System.out.println(integer);</span><br><span class=\"line\">        pool.awaitTermination(1000, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pool.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生产者消费者模型</li>\n</ul>\n<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题</p>\n<ul>\n<li>master-worker模型</li>\n</ul>\n<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master</p>\n<ul>\n<li>actor消息模型</li>\n</ul>\n<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。</p>\n<p>actor并发模型的应用场景？<br>适合有状态或者称可变状态的业务场景，如果用DDD术语，适合聚合根，具体案例如订单，订单有状态，比如未付款未发货，已经付款未发货，已付款已发货，导致订单状态的变化是事件行为，比如付款行为导致顶大状态切换到”已经付款未发货”。</p>\n<p>actor的原理<br>行为导致状态变化，行为执行是依靠线程，比如用户发出一个付款的请求，服务器后端派出一个线程来执行付款请求，携带付款的金额和银行卡等等信息，当付款请求被成功完成后，线程还要做的事情就是改变订单状态，这时线程访问订单的一个方法比如changeState。如果后台有管理员同时修改这个订单状态，那么实际有两个线程共同访问同一个数据，这时就必须锁，比如我们在changeState方法前加上sychronized这样同步语法。使用同步语法坏处是每次只能一个线程进行处理，如同上厕所，只有一个蹲坑，人多就必须排队，这种情况性能很低。</p>\n<p>避免changeState方法被外部两个线程同时占用访问，那么我们自己设计专门的线程守护订单状态，而不是普通方法代码，普通方法代码比较弱势，容易被外部线程hold住，而我们设计的这个对象没有普通方法，只有线程，这样就变成Order的守护线程和外部访问请求线程的通讯问题了。Actor采取的这种类似消息机制的方式，实际在守护线程和外部线程之间有一个队列，俗称信箱，外部线程只要把请求放入，守护线程就读取进行处理。这种异步高效方式是Actor基本原理，以ERlang和Scala语言为主要特征，他们封装得更好，类似将消息队列微观化了。<br>参考<a href=\"http://www.infoq.com/cn/articles/Building-Reactive-Applications-with-Akka\" target=\"_blank\" rel=\"noopener\">使用Akka Actor和Java 8构建反应式应用</a></p>\n<ul>\n<li>reactor模型</li>\n</ul>\n<p>一图胜千言，来看看Doug Lea大神画的图（Scalable IO in Java）<br><img src=\"https://images2018.cnblogs.com/blog/1424165/201808/1424165-20180803142242491-1328318201.png\" alt=\"image\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/20b7327f9f56\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/20b7327f9f56</a> ThreadPoolExecutor源码分析</li>\n<li><a href=\"https://blog.csdn.net/wangjinnan16/article/details/78377642\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wangjinnan16/article/details/78377642</a>  Netty4实战第十五章：选择正确的线程模型</li>\n<li><a href=\"https://www.cnblogs.com/PerkinsZhu/p/7570775.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/PerkinsZhu/p/7570775.html</a> 常见线程模型介绍</li>\n<li><a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\" target=\"_blank\" rel=\"noopener\">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a> Scalable IO in Java</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"线程模型分享-（上）\"><a href=\"#线程模型分享-（上）\" class=\"headerlink\" title=\"线程模型分享 （上）\"></a>线程模型分享 （上）</h1><p>本篇文章是公司大佬<strong>约拿</strong>上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><blockquote>\n<p>为什么有这篇文章？</p>\n</blockquote>\n<p>起先看我的目标是看netty的线程模型，但是在看netty的过程中，我发现很多知识点是互相关联的。比如netty的EventLoop，EventLoopGroup其实是继承自JDK的线程池。学习netty的线程模型前需要懂得预备知识。基于这个理由，我把预备内容部分也写下来。分享一共会分为上下两篇，这里是第上篇，这篇主要是先导，给【下篇】的知识打基础，有了上篇的基础再看下篇就容易多了。</p>\n<blockquote>\n<p>这篇文章会有什么内容？</p>\n<ul>\n<li>JDK线程池的类继承层次</li>\n<li>构建线程池的几个核心要素</li>\n<li>JDK线程池关键方法的分析</li>\n<li>JDK线程池存在的问题</li>\n<li>常见的线程模型举例</li>\n<li>线程模型适用场景分析 </li>\n<li>线程竞争与锁</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>文章目的</p>\n<ul>\n<li>可以自定义JDK线程池，了解JDK线程池的局限场景</li>\n<li>了解线程模型的原理及适用场景</li>\n<li>了解锁的目的及分类</li>\n</ul>\n</blockquote>\n<h2 id=\"线程启动与停止\"><a href=\"#线程启动与停止\" class=\"headerlink\" title=\"线程启动与停止\"></a>线程启动与停止</h2><blockquote>\n<p>如何启动线程</p>\n</blockquote>\n<p>这个比较基础的不说了</p>\n<blockquote>\n<p>如何停止线程</p>\n</blockquote>\n<ol>\n<li>线程类有stop，suspend方法，但是被弃用了。</li>\n</ol>\n<ul>\n<li><strong>stop</strong> 会立即杀死线程，可能导致执行一半的程序被终结导致数据不一致的风险</li>\n<li><strong>suspend</strong> 会挂起线程，但是不会释放锁，可能会造成思索</li>\n<li>线程池有个 <strong>shutdown</strong> 方法只是阻止线程池接受新的线程 ，并不会停止已存在的线程。</li>\n</ul>\n<ol start=\"2\">\n<li>正确的方法</li>\n</ol>\n<ul>\n<li>线程自己运行完成</li>\n<li>设置终止标志，在循环中检查这个标志</li>\n</ul>\n<h2 id=\"JDK线程池继承层次\"><a href=\"#JDK线程池继承层次\" class=\"headerlink\" title=\"JDK线程池继承层次\"></a>JDK线程池继承层次</h2><h3 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h3><p><img src=\"https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png\" alt=\"image\"><br>这个图上很多类不用看，因为都是Executors类的内部类，代理类，核心就是下图的几个接口和类。</p>\n<p><img src=\"https://user-images.githubusercontent.com/5201798/47539187-a74f8000-d901-11e8-9f94-f8f4be0477a0.png\" alt=\"image\"></p>\n<h3 id=\"线程池核心要素\"><a href=\"#线程池核心要素\" class=\"headerlink\" title=\"线程池核心要素\"></a>线程池核心要素</h3><ul>\n<li><p>核心线程池大小 corePoolSize</p>\n<blockquote>\n<p>设置一个线程池中的核心线程数 如果设置allowCoreThreadTimeOut为false的情况下： 即使当线程池中的线程处于空闲状态，这些线程也不会被线程池中移除。 如果设置了allowCoreThreadTimeOut为true, 那么当核心线程在空闲了一段时间后依旧没有用于工作，那么将会从线程池中移除。 注意:(allowCoreThreadTimeOut默认为false，通常情况下也无需做修改)</p>\n</blockquote>\n</li>\n<li><p>线程保持活跃时间</p>\n<blockquote>\n<p>keepAliveTime:当线程池中的线程数量大于核心线程数，如果这些多出的线程在经过了keepAliveTime时间后，依然处于空闲状态，那么这些多出的空闲线程将会被结束其生命周期。</p>\n</blockquote>\n</li>\n<li><p>时间单位unit</p>\n<blockquote>\n<p>keepAliveTime的时间单位</p>\n</blockquote>\n</li>\n<li><p>最大线程池大小 maximumPoolSize</p>\n<blockquote>\n<p>线程池中所允许创建最大线程数量，除了受JVM内存大小限制外，Linux下还受/proc/sys/kernel/pid_max（即系统允许的最大pid）、/proc/sys/kernel/threads-max（系统支持的最大线程数）、max_user_process（ulimit-u）（每个用户允许的最大进程数）、/proc/sys/vm/max_map_count（Linux支持虚拟内存，也就是交换空间,可以把磁盘的一部分作为RAM的扩展，逻辑存储和物理存储的映射就要保存在地址映射表中。max_map_count限制了线程可以拥有的VMAs ）</p>\n</blockquote>\n</li>\n<li><p>拒绝策略handler</p>\n<blockquote>\n<p>当线程池中的线程数量达到最大并且阻塞队列也已经满了无法再添加任务时，线程池所采取的处理策略，JDK有四种内建的拒绝策略，下面会讲到。</p>\n</blockquote>\n</li>\n<li><p>等待队列workQueue</p>\n<blockquote>\n<p>用于存放任务的阻塞队列，当线程池中的核心线程都处在执行任务时，提交的任务将被存储在workQueue进行缓冲。该队列只能存放通过execute方法提交的Runnable任务，如果是个ScheduledThreadPoolExecutor，那么这个队列不仅需要阻塞，而且还是个优先队列。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"核心代码分析\"><a href=\"#核心代码分析\" class=\"headerlink\" title=\"核心代码分析\"></a>核心代码分析</h3><p>ThreadPoolExecutor 一个根正苗红的线程池继承类。</p>\n<ul>\n<li><p>我们看看他的excute方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这里是调用</span><br><span class=\"line\">int corePoolSize = 1;</span><br><span class=\"line\">int maximumPoolSize = 2;</span><br><span class=\"line\">long keepAliveTime = 60;</span><br><span class=\"line\">TimeUnit unit = TimeUnit.SECONDS;</span><br><span class=\"line\">BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime</span><br><span class=\"line\">        , unit, workQueue, Executors.defaultThreadFactory(), new RejectedExecutionHandler() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class=\"line\">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class=\"line\">                &quot; rejected from &quot; +</span><br><span class=\"line\">                e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;execute!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">=========================</span><br><span class=\"line\"></span><br><span class=\"line\">看看execute的源码</span><br><span class=\"line\">public void execute(Runnable command) &#123;</span><br><span class=\"line\">    if (command == null)</span><br><span class=\"line\">        throw new NullPointerException();</span><br><span class=\"line\">    int c = ctl.get();</span><br><span class=\"line\">    // workerCountOf 从ctl中取工作线程的数量，这里有一定的技巧性，下面详细讲一下</span><br><span class=\"line\">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        if (addWorker(command, true))</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 看当前线程池状态是否Running，这里也是从ctl取值，有点意思</span><br><span class=\"line\">    // 把任务用offer方法塞进工作队列，如果插入成功，则返回ture</span><br><span class=\"line\">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        int recheck = ctl.get();</span><br><span class=\"line\">        // 二次检查线程池状态是否为Running，以及从任务队列获取当前任务是否成功</span><br><span class=\"line\">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        else if (workerCountOf(recheck) == 0)</span><br><span class=\"line\">            // addWorker方法里通过两个for循环通过ctl判断线程池的当前状态是否能新增线程，通过CAS机制修改线程池状态。最后新建worker对象，插入worker队列。</span><br><span class=\"line\">            addWorker(null, false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 线程池的线程数量不够了，增加线程，增加失败的话就拒绝这次execute调用</span><br><span class=\"line\">    else if (!addWorker(command, false))</span><br><span class=\"line\">        // reject方法里其实是调用定义线程池的时候构造函数传入的handler，JDK内建了四个拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy，含义分别是：抛出RejectedExecutionException异常、直接忽略提交的任务、把之前提交的任务移除，添加新的任务、让当前线程直接处理这个任务。用户也可以实现RejectedExecutionHandler接口，完成自己的拒绝策略。</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>DefaultThreadFactory  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class=\"line\">    private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br><span class=\"line\">    private final ThreadGroup group;</span><br><span class=\"line\">    private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br><span class=\"line\">    private final String namePrefix;</span><br><span class=\"line\"></span><br><span class=\"line\">    DefaultThreadFactory() &#123;</span><br><span class=\"line\">        SecurityManager s = System.getSecurityManager();</span><br><span class=\"line\">        group = (s != null) ? s.getThreadGroup() :</span><br><span class=\"line\">                              Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">        namePrefix = &quot;pool-&quot; +</span><br><span class=\"line\">                      poolNumber.getAndIncrement() +</span><br><span class=\"line\">                     &quot;-thread-&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 核心是这个newThread方法</span><br><span class=\"line\">    public Thread newThread(Runnable r) &#123;</span><br><span class=\"line\">        Thread t = new Thread(group, r,</span><br><span class=\"line\">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class=\"line\">                              0);</span><br><span class=\"line\">        if (t.isDaemon())</span><br><span class=\"line\">            t.setDaemon(false);</span><br><span class=\"line\">        if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">        return t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ctl是如何存储线程状态和数量的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义</span><br><span class=\"line\">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class=\"line\">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class=\"line\">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// runState is stored in the high-order bits</span><br><span class=\"line\">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">// Packing and unpacking ctl</span><br><span class=\"line\">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class=\"line\">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">上面那串定义看了可能有点懵，源码中使用了一个AtomicInteger对将当前线程的工作状态和工作线程数量(有效线程数)使用同一个整数进行包装。</span><br><span class=\"line\">为了将两个数值包装在同一个整数中，它将32位的高3位表示线程的状态值，而后29位来表示线程的数量。</span><br><span class=\"line\">其实这样设计的理由很简单，因为线程的状态和数量往往需要同时更新，然而线程池天生处在一个并发的环境下，那么当对2个变量进行修改时，那么就势必需要通过锁来进行线程安全的处理，从而保证2个变量修改具备原子性；但是这种做法对于性能的影响是非常严重的，因此在ThreadPoolExecutor将两个变量的分别包装在一个变量中，最后的并发操作发生在AtomicInteger上，而AtomicInteger恰恰就是具有一个无锁原子操作类,这样既可以解决线程安全的问题，又可以规避避免所的使用，从而提供性能。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ScheduledThreadPoolExecutor如何实现调度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TODO</span><br><span class=\"line\">优先队列</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"JDK线程池存在的问题\"><a href=\"#JDK线程池存在的问题\" class=\"headerlink\" title=\"JDK线程池存在的问题\"></a>JDK线程池存在的问题</h3><ul>\n<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>\n<li>CachedThreadPool 和 ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 </li>\n<li>多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</li>\n<li>ScheduledExecutorService并发执行大量调度时候有瓶颈，大并发量的线程调度应该用时间环模式。 </li>\n</ul>\n<p><del>不要感觉自己写几千行的类是很烂的代码，ThreadPoolExecutor也有2100多行（含注释）</del></p>\n<h2 id=\"线程竞争\"><a href=\"#线程竞争\" class=\"headerlink\" title=\"线程竞争\"></a>线程竞争</h2><h3 id=\"线程竞争的定义\"><a href=\"#线程竞争的定义\" class=\"headerlink\" title=\"线程竞争的定义\"></a>线程竞争的定义</h3><p>在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。这里涉及到线程锁</p>\n<h3 id=\"用锁控制线程间的竞争\"><a href=\"#用锁控制线程间的竞争\" class=\"headerlink\" title=\"用锁控制线程间的竞争\"></a>用锁控制线程间的竞争</h3><blockquote>\n<p>这里介绍锁的基本概念以及常见分类，详细在另外的时间再做。</p>\n</blockquote>\n<ul>\n<li>共享锁/排它锁 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。</span><br><span class=\"line\">共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。 </span><br><span class=\"line\">在这里理解共享锁的时候，不是任意时刻都允许多线程持有共享锁的，而是在某些特殊情况下才允许多线程持有共享锁，在某些情况下不允许多个线程持有共享锁，否则，如果没有前提条件任意时刻都允许线程任意持有共享锁，则共享锁的存在无意义的。例如读写锁中的读锁，只有当没有写锁和写锁请求的时候，就可以允许多个线程同时持有读锁。这里的前提条件就是“没有写锁和写锁请求”，而不是任意时刻都允许多线程持有共享读锁。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>悲观锁/乐观锁  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主要用于数据库数据的操作中，而对于线程锁中较为少见。</span><br><span class=\"line\">悲观锁和乐观锁是一种加锁思想。对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。</span><br><span class=\"line\">对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可重入锁/不可重入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这两个概念是从同一个线程在已经持有锁的前提下能否再次持有锁的角度来区分的。</span><br><span class=\"line\">对于可重入锁，如果该线程已经获取到锁且未释放的情况下允许再次获取该锁访问临界区资源。此种情况主要是用在递归调用的情况下和不同的临界区使用相同的锁的情况下。</span><br><span class=\"line\">对于不可重入锁，则不允许同一线程在持有锁的情况下再次获取该锁并访问临界区资源。对于不可重入锁，使用的时候需要小心以免造成死锁。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>公平锁/非公平锁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这两个概念主要使用线程获取锁的顺序角度来区分的。</span><br><span class=\"line\">对于公平锁，所有等待的线程按照按照请求锁的先后循序分别依次获取锁。</span><br><span class=\"line\">对于非公平锁，等待线程的线程获取锁的顺序和请求的先后不是对应关系。有可能是随机的获取锁，也有可能按照其他策略获取锁，总之不是按照FIFO的顺序获取锁。</span><br><span class=\"line\">在使用ReentrantLock的时候可以通过构造方法主动选择是实现公平锁还是非公平锁。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自旋锁/非自旋锁</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这两种概念是从线程等待的处理机制来区分的。</span><br><span class=\"line\">自旋锁在进行锁请求等待的时候不进行wait挂起，不释放CPU资源，执行while空循环。直至获取锁访问临界区资源。适用于等待锁时间较短的情景，如果等待时间较长，则会耗费大量的CPU资源。而如果等待时间较短则可以节约大量的线程切换资源。</span><br><span class=\"line\">非自旋锁在进行锁等待的时候会释放CPU资源，可以通多sleep wait 或者CPU中断切换上下文，切换该线程。在线程等待时间较长的情况下可以选择此种实现机制。</span><br><span class=\"line\">除此之外还有一种介于两者之间的锁机制——自适应自旋锁。当线程进行等待的时候先进性自旋等待，在自旋一定时间(次数)之后如果依旧没有持有锁则挂起等待。在jvm中synchronized锁已经使用该机制进行处理锁等待的情况。</span><br><span class=\"line\">在工作中可以根据不同的情况选取合适的锁进行使用。无论使用哪种锁，其目的都是保证程序能够按照要求顺利执行，避免数据混乱情况的发生。</span><br></pre></td></tr></table></figure>\n<p>详细的<a href=\"https://www.cnblogs.com/PerkinsZhu/p/7392006.html\" target=\"_blank\" rel=\"noopener\">参考</a>这里</p>\n<h3 id=\"锁的弊端\"><a href=\"#锁的弊端\" class=\"headerlink\" title=\"锁的弊端\"></a>锁的弊端</h3><p>不管是何种锁，本质上都是对资源的访问加以限制，让同一时间只有一个线程访问资源。在高并发的时候，锁往往会成为系统的瓶颈，更不用说同时带来的死锁风险。</p>\n<h3 id=\"不用锁解决线程安全的方式\"><a href=\"#不用锁解决线程安全的方式\" class=\"headerlink\" title=\"不用锁解决线程安全的方式\"></a>不用锁解决线程安全的方式</h3><p>我们接下来讨论有无高效解决线程竞争的模式，避免锁带来的以上问题。</p>\n<h2 id=\"常见线程模型\"><a href=\"#常见线程模型\" class=\"headerlink\" title=\"常见线程模型\"></a>常见线程模型</h2><h3 id=\"线程模型的定义\"><a href=\"#线程模型的定义\" class=\"headerlink\" title=\"线程模型的定义\"></a>线程模型的定义</h3><p>线程模型决定了应用或框架如何执行代码，所以选择正确的线程模型是很重要的事情。通俗的讲，如果同样给你一定数量的线程如（100个），分析实际的业务场景，如何让它们的效率最大化。这就是选取线程模型应该做的事情。</p>\n<blockquote>\n<p>同时线程模型也指线程映射到操作系统进程的模型 <a href=\"https://blog.csdn.net/lyc201219/article/details/79228575\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lyc201219/article/details/79228575</a></p>\n</blockquote>\n<ul>\n<li>Future模型</li>\n</ul>\n<p>结合Callable接口配合使用，Callable是类似于Runnable的接口。Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。如果不使用Future模型，就需要使用到一个全局变量来保存子线程处理之后的结果。子线程处理结束之后，把结果保存在全局变量中供主线程进行调用。一旦涉及到全局能量便存在着多线程读写全局变量错误的风险。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class=\"line\">Future&lt;?&gt; future = executorService.submit(new Callable&lt;Object&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object call() throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Object o = future.get();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fork&amp;join 模型</li>\n</ul>\n<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 将num*2 用frok&amp;join的思想做</span><br><span class=\"line\"> */</span><br><span class=\"line\">static class ResultTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class=\"line\">    private int num;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ResultTask(int num) &#123;</span><br><span class=\"line\">        this.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected Integer compute() &#123;</span><br><span class=\"line\">        if (num &lt; 10) &#123;</span><br><span class=\"line\">            return num * 2;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //对任务进行拆分，注意这里不仅仅可以一分为二进行拆分，也可以拆为多个子任务</span><br><span class=\"line\">            int temp = num / 2;</span><br><span class=\"line\">            ResultTask left = new ResultTask(temp);</span><br><span class=\"line\">            ResultTask right = new ResultTask(num - temp);</span><br><span class=\"line\">            left.fork();</span><br><span class=\"line\">            right.fork();</span><br><span class=\"line\">            //对子任务处理的结果进行合并</span><br><span class=\"line\">            int result = left.join() + right.join();</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">    ForkJoinPool pool = new ForkJoinPool();</span><br><span class=\"line\">    ForkJoinTask&lt;Integer&gt; future = pool.submit(new ResultTask(100));</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        Integer integer = future.get();</span><br><span class=\"line\">        System.out.println(integer);</span><br><span class=\"line\">        pool.awaitTermination(1000, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pool.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生产者消费者模型</li>\n</ul>\n<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题</p>\n<ul>\n<li>master-worker模型</li>\n</ul>\n<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master</p>\n<ul>\n<li>actor消息模型</li>\n</ul>\n<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。</p>\n<p>actor并发模型的应用场景？<br>适合有状态或者称可变状态的业务场景，如果用DDD术语，适合聚合根，具体案例如订单，订单有状态，比如未付款未发货，已经付款未发货，已付款已发货，导致订单状态的变化是事件行为，比如付款行为导致顶大状态切换到”已经付款未发货”。</p>\n<p>actor的原理<br>行为导致状态变化，行为执行是依靠线程，比如用户发出一个付款的请求，服务器后端派出一个线程来执行付款请求，携带付款的金额和银行卡等等信息，当付款请求被成功完成后，线程还要做的事情就是改变订单状态，这时线程访问订单的一个方法比如changeState。如果后台有管理员同时修改这个订单状态，那么实际有两个线程共同访问同一个数据，这时就必须锁，比如我们在changeState方法前加上sychronized这样同步语法。使用同步语法坏处是每次只能一个线程进行处理，如同上厕所，只有一个蹲坑，人多就必须排队，这种情况性能很低。</p>\n<p>避免changeState方法被外部两个线程同时占用访问，那么我们自己设计专门的线程守护订单状态，而不是普通方法代码，普通方法代码比较弱势，容易被外部线程hold住，而我们设计的这个对象没有普通方法，只有线程，这样就变成Order的守护线程和外部访问请求线程的通讯问题了。Actor采取的这种类似消息机制的方式，实际在守护线程和外部线程之间有一个队列，俗称信箱，外部线程只要把请求放入，守护线程就读取进行处理。这种异步高效方式是Actor基本原理，以ERlang和Scala语言为主要特征，他们封装得更好，类似将消息队列微观化了。<br>参考<a href=\"http://www.infoq.com/cn/articles/Building-Reactive-Applications-with-Akka\" target=\"_blank\" rel=\"noopener\">使用Akka Actor和Java 8构建反应式应用</a></p>\n<ul>\n<li>reactor模型</li>\n</ul>\n<p>一图胜千言，来看看Doug Lea大神画的图（Scalable IO in Java）<br><img src=\"https://images2018.cnblogs.com/blog/1424165/201808/1424165-20180803142242491-1328318201.png\" alt=\"image\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/20b7327f9f56\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/20b7327f9f56</a> ThreadPoolExecutor源码分析</li>\n<li><a href=\"https://blog.csdn.net/wangjinnan16/article/details/78377642\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wangjinnan16/article/details/78377642</a>  Netty4实战第十五章：选择正确的线程模型</li>\n<li><a href=\"https://www.cnblogs.com/PerkinsZhu/p/7570775.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/PerkinsZhu/p/7570775.html</a> 常见线程模型介绍</li>\n<li><a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\" target=\"_blank\" rel=\"noopener\">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a> Scalable IO in Java</li>\n</ul>\n"},{"title":"Stream","date":"2018-11-19T02:53:00.000Z","_content":"\n>最近在学习JAVA8 Stream的API，找到了这篇文章，觉得内容很好就抄了过来，文章来源：https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/\n\n# 为什么需要 Stream\n\nStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。\n\n## 什么是聚合操作\n\n在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：\n* 客户每月平均消费金额\n* 最昂贵的在售商品\n* 本周完成的有效订单（排除了无效的）\n* 取十个数据样本作为首页推荐\n\n但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：\n\neg1. Java 7 的排序、取值实现\n```java\nList<Transaction> groceryTransactions = new Arraylist<>();\nfor (Transaction t : transactions) {\n    if (t.getType() == Transaction.GROCERY) {\n        groceryTransactions.add(t);\n    }\n}\nCollections.sort(groceryTransactions, new Comparator() {\n    public int compare(Transaction t1, Transaction t2) {\n        return t2.getValue().compareTo(t1.getValue());\n    }\n});\nList<Integer> transactionIds = new ArrayList<>();\nfor (Transaction t : groceryTransactions) {\n    transactionsIds.add(t.getId());\n}\n```\n\n而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。\n\neg2. Java 8 的排序、取值实现\n```java\nList<Integer> transactionsIds = transactions.parallelStream().\n    filter(t -> t.getType() == Transaction.GROCERY).\n    sorted(comparing(Transaction::getValue).reversed()).\n    map(Transaction::getId).\n    collect(toList());\n```\n\n# Stream 总览\n\n## 什么是流\n\nStream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。\n\nStream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。\n\n而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：\n\n1. 1.0-1.4 中的 java.lang.Thread\n2. 5.0 中的 java.util.concurrent\n3. 6.0 中的 Phasers 等\n4. 7.0 中的 Fork/Join 框架\n5. 8.0 中的 Lambda\n\nStream 的另外一大特点是，数据源本身可以是无限的。\n\n## 流的构成\n\n当我们使用一个流的时候，通常包括三个基本步骤：\n\n获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。\n\n流管道 (Stream Pipeline) 的构成\n\n![StreamPipeline-photo](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png)\n\n### 有多种方式生成 Stream Source：\n\n#### 从 Collection 和数组\n\n* Collection.stream()\n* Collection.parallelStream()\n* Arrays.stream(T array) or Stream.of()\n\n#### 从 BufferedReader\n\n* java.io.BufferedReader.lines()\n\n#### 静态工厂\n\n* java.util.stream.IntStream.range()\n* java.nio.file.Files.walk()\n\n#### 自己构建\n\n* java.util.Spliterator\n\n#### 其它\n\n* Random.ints()\n* BitSet.stream()\n* Pattern.splitAsStream(java.lang.CharSequence)\n* JarFile.stream()\n\n### 流的操作类型分为两种：\n\n* ***Intermediate***：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。\n\n* ***Terminal***：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。\n\n在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。\n\n还有一种操作被称为 ***short-circuiting***。用以指：\n\n* 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。\n* 对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。\n\n当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。\n\neg3. 一个流操作的示例\n```java\nint sum = widgets.stream()\n    .filter(w -> w.getColor() == RED)\n    .mapToInt(w -> w.getWeight())\n    .sum();\n```\n\nstream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。\n\n# 流的使用详解\n\n简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。\n\n## 流的构造与转换\n\n下面提供最常见的几种构造 Stream 的样例。\n\neg4. 构造流的几种常见方法\n```java\n// 1. Individual values\nStream stream = Stream.of(\"a\", \"b\", \"c\");\n// 2. Arrays\nString [] strArray = new String[] {\"a\", \"b\", \"c\"};\nstream = Stream.of(strArray);\nstream = Arrays.stream(strArray);\n// 3. Collections\nList<String> list = Arrays.asList(strArray);\nstream = list.stream();\n```\n\n需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：\n\nIntStream、LongStream、DoubleStream。当然我们也可以用 Stream<Integer>、Stream<Long> >、Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。\n\nJava 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。\n\neg5. 数值流的构造\n```java\nIntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);\nIntStream.range(1, 3).forEach(System.out::println);\nIntStream.rangeClosed(1, 3).forEach(System.out::println);\n```\n\neg6. 流转换为其它数据结构\n```java\n// 1. Array\nString[] strArray1 = stream.toArray(String[]::new);\n// 2. Collection\nList<String> list1 = stream.collect(Collectors.toList());\nList<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));\nSet set1 = stream.collect(Collectors.toSet());\nStack stack1 = stream.collect(Collectors.toCollection(Stack::new));\n// 3. String\nString str = stream.collect(Collectors.joining()).toString();\n```\n\n一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。\n\n## 流的操作\n\n接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。\n\n* Intermediate：\n\n    map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered\n\n* Terminal：\n\n    forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator\n\n* Short-circuiting：\n\n    anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit\n\n### map/flatMap\n\n我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。\n\neg7. 转换大写\n```java\nList<String> output = wordList.stream().\nmap(String::toUpperCase).\ncollect(Collectors.toList());\n```\n\n这段代码把所有的单词转换为大写。\n\neg8. 平方数\n```java\nList<Integer> nums = Arrays.asList(1, 2, 3, 4);\nList<Integer> squareNums = nums.stream().\nmap(n -> n * n).\ncollect(Collectors.toList());\n```\n\n这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。\n\n从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。\n\neg9. 一对多\n```java\nStream<List<Integer>> inputStream = Stream.of(\n Arrays.asList(1),\n Arrays.asList(2, 3),\n Arrays.asList(4, 5, 6)\n );\nStream<Integer> outputStream = inputStream.\nflatMap((childList) -> childList.stream());\n```\n\nflatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。\n\n### filter\n\nfilter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。\n\neg10. 留下偶数\n```java\nInteger[] sixNums = {1, 2, 3, 4, 5, 6};\nInteger[] evens =\nStream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);\n```\n\n经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。\n\neg11. 把单词挑出来\n```java\nList<String> output = reader.lines().\n    flatMap(line -> Stream.of(line.split(REGEXP))).\n    filter(word -> word.length() > 0).\n    collect(Collectors.toList());\n```\n\n这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。\n\n\n### forEach\n\nforEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。\n\neg12. 打印姓名（forEach 和 pre-java8 的对比）\n```java\n// Java 8\nroster.stream()\n    .filter(p -> p.getGender() == Person.Sex.MALE)\n    .forEach(p -> System.out.println(p.getName()));\n// Pre-Java 8\nfor (Person p : roster) {\n    if (p.getGender() == Person.Sex.MALE) {\n        System.out.println(p.getName());\n    }\n}\n```\n对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。\n\n但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。\n\n另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：\n\n```java\nstream.forEach(element -> doOneThing(element));\nstream.forEa\nch(element -> doAnotherThing(element));\n```\n\n相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。\n\neg13. peek 对每个元素执行操作并返回一个新的 Stream\n```java\nStream.of(\"one\", \"two\", \"three\", \"four\")\n    .filter(e -> e.length() > 3)\n    .peek(e -> System.out.println(\"Filtered value: \" + e))\n    .map(String::toUpperCase)\n    .peek(e -> System.out.println(\"Mapped value: \" + e))\n    .collect(Collectors.toList());\n ```\n\nforEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。\n\n### findFirst\n\n这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。\n\n这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。\n\neg14. Optional 的两个用例\n```java\nString strA = \" abcd \", strB = null;\nprint(strA);\nprint(\"\");\nprint(strB);\ngetLength(strA);\ngetLength(\"\");\ngetLength(strB);\npublic static void print(String text) {\n    // Java 8\n    Optional.ofNullable(text).ifPresent(System.out::println);\n    // Pre-Java 8\n    if (text != null) {\n        System.out.println(text);\n    }\n }\npublic static int getLength(String text) {\n    // Java 8\n    return Optional.ofNullable(text).map(String::length).orElse(-1);\n    // Pre-Java 8\n    // return if (text != null) ? text.length() : -1;\n};\n```\n在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。\n\nStream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。\n\n### reduce\n\n这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于\n\nInteger sum = integers.reduce(0, (a, b) -> a+b); 或\n\nInteger sum = integers.reduce(0, Integer::sum);\n\n也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。\n\neg15. reduce 的用例\n```java\n// 字符串连接，concat = \"ABCD\"\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat); \n// 求最小值，minValue = -3.0\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); \n// 求和，sumValue = 10, 有起始值\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n// 求和，sumValue = 10, 无起始值\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n// 过滤，字符串连接，concat = \"ace\"\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\n    filter(x -> x.compareTo(\"Z\") > 0).\n    reduce(\"\", String::concat);\n```\n\n上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。\n\n### limit/skip\n\nlimit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。\n\neg16. limit 和 skip 对运行次数的影响\n```java        \npublic void testLimitAndSkip () {\n    List<Person> persons = new ArrayList();\n    for (int i = 1; i <= 10000; i++) {\n        Person person = new Person(i, \"name\" + i);\n        persons.add(person);\n    }\n    List<String> personList2 = persons.stream().\n            map(Person::getName).limit(10).skip(3).collect(Collectors.toList());\n    System.out.println(personList2);\n}\nprivate class Person {\n    public int no;\n    private String name;\n\n    public Person(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public String getName() {\n        System.out.println(name);\n        return name;\n    }\n}\n```\n\n输出结果为：\n```java\nname1\nname2\nname3\nname4\nname5\nname6\nname7\nname8\nname9\nname10\n[name4, name5, name6, name7, name8, name9, name10]\n```\n这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。\n\n有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。\n\neg17. limit 和 skip 对 sorted 后的运行次数无影响\n```java\nList<Person> persons = new ArrayList();\nfor (int i = 1; i <= 5; i++) {\n    Person person = new Person(i, \"name\" + i);\n    persons.add(person);\n}\nList<Person> personList2 = persons.stream().sorted((p1, p2) ->\n    p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());\nSystem.out.println(personList2);\n```\n\n上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：\n```java\nname2\nname1\nname3\nname2\nname4\nname3\nname5\nname4\n[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]\n```\n\n即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。\n\n最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。\n\n### sorted\n\n对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：\n\neg18. 优化：排序前进行 limit 和 skip\n```java\nList<Person> persons = new ArrayList();\nfor (int i = 1; i <= 5; i++) {\n    Person person = new Person(i, \"name\" + i);\n    persons.add(person);\n}\nList<Person> personList2 = persons.stream().limit(2).sorted((p1, p2) -> p1.getName().compareTo(p2.getName())).collect(Collectors.toList());\nSystem.out.println(personList2);\n```\n\n结果会简单很多：\n\n```java\nname2\nname1\n[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]\n```\n\n当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。\n\n### min/max/distinct\n\nmin 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。\n\neg19. 找出最长一行的长度\n```java\nBufferedReader br = new BufferedReader(new FileReader(\"c:\\\\SUService.log\"));\nint longest = br.lines().\n    mapToInt(String::length).\n    max().\n    getAsInt();\nbr.close();\nSystem.out.println(longest);\n```\n\n下面的例子则使用 distinct 来找出不重复的单词。\n\neg20. 找出全文的单词，转小写，并排序\n```java\nList<String> words = br.lines().\nflatMap(line -> Stream.of(line.split(\" \"))).\nfilter(word -> word.length() > 0).\nmap(String::toLowerCase).\ndistinct().\nsorted().\ncollect(Collectors.toList());\nbr.close();\nSystem.out.println(words);\n```\n\n### Match\n\nStream 有三个 match 方法，从语义上说：\n\n* allMatch：Stream 中全部元素符合传入的 predicate，返回 true\n* anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true\n* noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true\n\n它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。\n\neg21. 使用 Match\n```java\nList<Person> persons = new ArrayList();\npersons.add(new Person(1, \"name\" + 1, 10));\npersons.add(new Person(2, \"name\" + 2, 21));\npersons.add(new Person(3, \"name\" + 3, 34));\npersons.add(new Person(4, \"name\" + 4, 6));\npersons.add(new Person(5, \"name\" + 5, 55));\nboolean isAllAdult = persons.stream().allMatch(p -> p.getAge() > 18);\nSystem.out.println(\"All are adult? \" + isAllAdult);\nboolean isThereAnyChild = persons.stream().anyMatch(p -> p.getAge() < 12);\nSystem.out.println(\"Any child? \" + isThereAnyChild);\n```\n输出结果：\n```java\nAll are adult? false\nAny child? true\n```\n\n## 进阶：自己生成流\n\n### Stream.generate\n\n通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。\n\neg22. 生成 10 个随机整数\n```java\nRandom seed = new Random();\nSupplier<Integer> random = seed::nextInt;\nStream.generate(random).limit(10).forEach(System.out::println);\n//Another way\nIntStream.generate(() -> (int) (System.nanoTime() % 100)).\nlimit(10).forEach(System.out::println);\n```\n\nStream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。\n\neg23. 自实现 Supplier\n```java\nStream.generate(new PersonSupplier()).\n        limit(10).\n        forEach(p -> System.out.println(p.getName() + \", \" + p.getAge()));\nprivate class PersonSupplier implements Supplier<Person> {\n    private int index = 0;\n    private Random random = new Random();\n    @Override\n    public Person get() {\n        return new Person(index++, \"StormTestUser\" + index, random.nextInt(100));\n    }\n}\n```\n\n输出结果：\n```java\nStormTestUser1, 9\nStormTestUser2, 12\nStormTestUser3, 88\nStormTestUser4, 51\nStormTestUser5, 22\nStormTestUser6, 28\nStormTestUser7, 81\nStormTestUser8, 51\nStormTestUser9, 4\nStormTestUser10, 76\n```\n\n### Stream.iterate\n\niterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。\n\neg24. 生成一个等差数列\n```java\nStream.iterate(0, n -> n + 3).limit(10). forEach(x -> System.out.print(x + \" \"));\n```\n\n输出结果：\n```java\n0 3 6 9 12 15 18 21 24 27\n```\n\n与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。\n\n## 进阶：用 Collectors 来进行 reduction 操作\n\njava.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。\n\n### groupingBy/partitioningBy\n\neg25. 按照年龄归组\n```java\nMap<Integer, List<Person>> personGroups = Stream.generate(new PersonSupplier()).\n        limit(100).\n        collect(Collectors.groupingBy(Person::getAge));\nIterator it = personGroups.entrySet().iterator();\nwhile (it.hasNext()) {\n    Map.Entry<Integer, List<Person>> persons = (Map.Entry) it.next();\n    System.out.println(\"Age \" + persons.getKey() + \" = \" + persons.getValue().size());\n}\n```\n\n上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：\n\n```java\nAge 0 = 2\nAge 1 = 2\nAge 5 = 2\nAge 8 = 1\nAge 9 = 1\nAge 11 = 2\n……\n```\n\neg26. 按照未成年人和成年人归组\n```java\nMap<Boolean, List<Person>> children = Stream.generate(new PersonSupplier()).\n    limit(100).\n    collect(Collectors.partitioningBy(p -> p.getAge() < 18));\nSystem.out.println(\"Children number: \" + children.get(true).size());\nSystem.out.println(\"Adult number: \" + children.get(false).size());\n```\n\n输出结果：\n\n```java\nChildren number: 23 \nAdult number: 77\n```\n\n在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。\n\n# 结束语\n\n总之，Stream 的特性可以归纳为：\n\n* 不是数据结构\n    它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。\n\n    它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。\n\n* 所有 Stream 的操作必须以 lambda 表达式为参数\n\n* 不支持索引访问\n\n    你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。\n\n* 很容易生成数组或者 List\n\n* 惰性化\n\n    很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。\n\n    Intermediate 操作永远是惰性化的。\n\n* 并行能力\n\n    当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。\n\n* 可以是无限的\n\n    集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。","source":"_posts/Stream.md","raw":"---\ntitle: Stream\ndate: 2018-11-19 10:53:00\ntags:\ncategories: Java\n---\n\n>最近在学习JAVA8 Stream的API，找到了这篇文章，觉得内容很好就抄了过来，文章来源：https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/\n\n# 为什么需要 Stream\n\nStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。\n\n## 什么是聚合操作\n\n在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：\n* 客户每月平均消费金额\n* 最昂贵的在售商品\n* 本周完成的有效订单（排除了无效的）\n* 取十个数据样本作为首页推荐\n\n但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：\n\neg1. Java 7 的排序、取值实现\n```java\nList<Transaction> groceryTransactions = new Arraylist<>();\nfor (Transaction t : transactions) {\n    if (t.getType() == Transaction.GROCERY) {\n        groceryTransactions.add(t);\n    }\n}\nCollections.sort(groceryTransactions, new Comparator() {\n    public int compare(Transaction t1, Transaction t2) {\n        return t2.getValue().compareTo(t1.getValue());\n    }\n});\nList<Integer> transactionIds = new ArrayList<>();\nfor (Transaction t : groceryTransactions) {\n    transactionsIds.add(t.getId());\n}\n```\n\n而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。\n\neg2. Java 8 的排序、取值实现\n```java\nList<Integer> transactionsIds = transactions.parallelStream().\n    filter(t -> t.getType() == Transaction.GROCERY).\n    sorted(comparing(Transaction::getValue).reversed()).\n    map(Transaction::getId).\n    collect(toList());\n```\n\n# Stream 总览\n\n## 什么是流\n\nStream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。\n\nStream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。\n\n而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：\n\n1. 1.0-1.4 中的 java.lang.Thread\n2. 5.0 中的 java.util.concurrent\n3. 6.0 中的 Phasers 等\n4. 7.0 中的 Fork/Join 框架\n5. 8.0 中的 Lambda\n\nStream 的另外一大特点是，数据源本身可以是无限的。\n\n## 流的构成\n\n当我们使用一个流的时候，通常包括三个基本步骤：\n\n获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。\n\n流管道 (Stream Pipeline) 的构成\n\n![StreamPipeline-photo](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png)\n\n### 有多种方式生成 Stream Source：\n\n#### 从 Collection 和数组\n\n* Collection.stream()\n* Collection.parallelStream()\n* Arrays.stream(T array) or Stream.of()\n\n#### 从 BufferedReader\n\n* java.io.BufferedReader.lines()\n\n#### 静态工厂\n\n* java.util.stream.IntStream.range()\n* java.nio.file.Files.walk()\n\n#### 自己构建\n\n* java.util.Spliterator\n\n#### 其它\n\n* Random.ints()\n* BitSet.stream()\n* Pattern.splitAsStream(java.lang.CharSequence)\n* JarFile.stream()\n\n### 流的操作类型分为两种：\n\n* ***Intermediate***：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。\n\n* ***Terminal***：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。\n\n在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。\n\n还有一种操作被称为 ***short-circuiting***。用以指：\n\n* 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。\n* 对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。\n\n当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。\n\neg3. 一个流操作的示例\n```java\nint sum = widgets.stream()\n    .filter(w -> w.getColor() == RED)\n    .mapToInt(w -> w.getWeight())\n    .sum();\n```\n\nstream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。\n\n# 流的使用详解\n\n简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。\n\n## 流的构造与转换\n\n下面提供最常见的几种构造 Stream 的样例。\n\neg4. 构造流的几种常见方法\n```java\n// 1. Individual values\nStream stream = Stream.of(\"a\", \"b\", \"c\");\n// 2. Arrays\nString [] strArray = new String[] {\"a\", \"b\", \"c\"};\nstream = Stream.of(strArray);\nstream = Arrays.stream(strArray);\n// 3. Collections\nList<String> list = Arrays.asList(strArray);\nstream = list.stream();\n```\n\n需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：\n\nIntStream、LongStream、DoubleStream。当然我们也可以用 Stream<Integer>、Stream<Long> >、Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。\n\nJava 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。\n\neg5. 数值流的构造\n```java\nIntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);\nIntStream.range(1, 3).forEach(System.out::println);\nIntStream.rangeClosed(1, 3).forEach(System.out::println);\n```\n\neg6. 流转换为其它数据结构\n```java\n// 1. Array\nString[] strArray1 = stream.toArray(String[]::new);\n// 2. Collection\nList<String> list1 = stream.collect(Collectors.toList());\nList<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));\nSet set1 = stream.collect(Collectors.toSet());\nStack stack1 = stream.collect(Collectors.toCollection(Stack::new));\n// 3. String\nString str = stream.collect(Collectors.joining()).toString();\n```\n\n一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。\n\n## 流的操作\n\n接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。\n\n* Intermediate：\n\n    map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered\n\n* Terminal：\n\n    forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator\n\n* Short-circuiting：\n\n    anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit\n\n### map/flatMap\n\n我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。\n\neg7. 转换大写\n```java\nList<String> output = wordList.stream().\nmap(String::toUpperCase).\ncollect(Collectors.toList());\n```\n\n这段代码把所有的单词转换为大写。\n\neg8. 平方数\n```java\nList<Integer> nums = Arrays.asList(1, 2, 3, 4);\nList<Integer> squareNums = nums.stream().\nmap(n -> n * n).\ncollect(Collectors.toList());\n```\n\n这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。\n\n从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。\n\neg9. 一对多\n```java\nStream<List<Integer>> inputStream = Stream.of(\n Arrays.asList(1),\n Arrays.asList(2, 3),\n Arrays.asList(4, 5, 6)\n );\nStream<Integer> outputStream = inputStream.\nflatMap((childList) -> childList.stream());\n```\n\nflatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。\n\n### filter\n\nfilter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。\n\neg10. 留下偶数\n```java\nInteger[] sixNums = {1, 2, 3, 4, 5, 6};\nInteger[] evens =\nStream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);\n```\n\n经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。\n\neg11. 把单词挑出来\n```java\nList<String> output = reader.lines().\n    flatMap(line -> Stream.of(line.split(REGEXP))).\n    filter(word -> word.length() > 0).\n    collect(Collectors.toList());\n```\n\n这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。\n\n\n### forEach\n\nforEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。\n\neg12. 打印姓名（forEach 和 pre-java8 的对比）\n```java\n// Java 8\nroster.stream()\n    .filter(p -> p.getGender() == Person.Sex.MALE)\n    .forEach(p -> System.out.println(p.getName()));\n// Pre-Java 8\nfor (Person p : roster) {\n    if (p.getGender() == Person.Sex.MALE) {\n        System.out.println(p.getName());\n    }\n}\n```\n对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。\n\n但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。\n\n另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：\n\n```java\nstream.forEach(element -> doOneThing(element));\nstream.forEa\nch(element -> doAnotherThing(element));\n```\n\n相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。\n\neg13. peek 对每个元素执行操作并返回一个新的 Stream\n```java\nStream.of(\"one\", \"two\", \"three\", \"four\")\n    .filter(e -> e.length() > 3)\n    .peek(e -> System.out.println(\"Filtered value: \" + e))\n    .map(String::toUpperCase)\n    .peek(e -> System.out.println(\"Mapped value: \" + e))\n    .collect(Collectors.toList());\n ```\n\nforEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。\n\n### findFirst\n\n这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。\n\n这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。\n\neg14. Optional 的两个用例\n```java\nString strA = \" abcd \", strB = null;\nprint(strA);\nprint(\"\");\nprint(strB);\ngetLength(strA);\ngetLength(\"\");\ngetLength(strB);\npublic static void print(String text) {\n    // Java 8\n    Optional.ofNullable(text).ifPresent(System.out::println);\n    // Pre-Java 8\n    if (text != null) {\n        System.out.println(text);\n    }\n }\npublic static int getLength(String text) {\n    // Java 8\n    return Optional.ofNullable(text).map(String::length).orElse(-1);\n    // Pre-Java 8\n    // return if (text != null) ? text.length() : -1;\n};\n```\n在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。\n\nStream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。\n\n### reduce\n\n这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于\n\nInteger sum = integers.reduce(0, (a, b) -> a+b); 或\n\nInteger sum = integers.reduce(0, Integer::sum);\n\n也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。\n\neg15. reduce 的用例\n```java\n// 字符串连接，concat = \"ABCD\"\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat); \n// 求最小值，minValue = -3.0\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); \n// 求和，sumValue = 10, 有起始值\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n// 求和，sumValue = 10, 无起始值\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n// 过滤，字符串连接，concat = \"ace\"\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\n    filter(x -> x.compareTo(\"Z\") > 0).\n    reduce(\"\", String::concat);\n```\n\n上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。\n\n### limit/skip\n\nlimit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。\n\neg16. limit 和 skip 对运行次数的影响\n```java        \npublic void testLimitAndSkip () {\n    List<Person> persons = new ArrayList();\n    for (int i = 1; i <= 10000; i++) {\n        Person person = new Person(i, \"name\" + i);\n        persons.add(person);\n    }\n    List<String> personList2 = persons.stream().\n            map(Person::getName).limit(10).skip(3).collect(Collectors.toList());\n    System.out.println(personList2);\n}\nprivate class Person {\n    public int no;\n    private String name;\n\n    public Person(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public String getName() {\n        System.out.println(name);\n        return name;\n    }\n}\n```\n\n输出结果为：\n```java\nname1\nname2\nname3\nname4\nname5\nname6\nname7\nname8\nname9\nname10\n[name4, name5, name6, name7, name8, name9, name10]\n```\n这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。\n\n有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。\n\neg17. limit 和 skip 对 sorted 后的运行次数无影响\n```java\nList<Person> persons = new ArrayList();\nfor (int i = 1; i <= 5; i++) {\n    Person person = new Person(i, \"name\" + i);\n    persons.add(person);\n}\nList<Person> personList2 = persons.stream().sorted((p1, p2) ->\n    p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());\nSystem.out.println(personList2);\n```\n\n上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：\n```java\nname2\nname1\nname3\nname2\nname4\nname3\nname5\nname4\n[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]\n```\n\n即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。\n\n最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。\n\n### sorted\n\n对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：\n\neg18. 优化：排序前进行 limit 和 skip\n```java\nList<Person> persons = new ArrayList();\nfor (int i = 1; i <= 5; i++) {\n    Person person = new Person(i, \"name\" + i);\n    persons.add(person);\n}\nList<Person> personList2 = persons.stream().limit(2).sorted((p1, p2) -> p1.getName().compareTo(p2.getName())).collect(Collectors.toList());\nSystem.out.println(personList2);\n```\n\n结果会简单很多：\n\n```java\nname2\nname1\n[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]\n```\n\n当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。\n\n### min/max/distinct\n\nmin 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。\n\neg19. 找出最长一行的长度\n```java\nBufferedReader br = new BufferedReader(new FileReader(\"c:\\\\SUService.log\"));\nint longest = br.lines().\n    mapToInt(String::length).\n    max().\n    getAsInt();\nbr.close();\nSystem.out.println(longest);\n```\n\n下面的例子则使用 distinct 来找出不重复的单词。\n\neg20. 找出全文的单词，转小写，并排序\n```java\nList<String> words = br.lines().\nflatMap(line -> Stream.of(line.split(\" \"))).\nfilter(word -> word.length() > 0).\nmap(String::toLowerCase).\ndistinct().\nsorted().\ncollect(Collectors.toList());\nbr.close();\nSystem.out.println(words);\n```\n\n### Match\n\nStream 有三个 match 方法，从语义上说：\n\n* allMatch：Stream 中全部元素符合传入的 predicate，返回 true\n* anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true\n* noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true\n\n它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。\n\neg21. 使用 Match\n```java\nList<Person> persons = new ArrayList();\npersons.add(new Person(1, \"name\" + 1, 10));\npersons.add(new Person(2, \"name\" + 2, 21));\npersons.add(new Person(3, \"name\" + 3, 34));\npersons.add(new Person(4, \"name\" + 4, 6));\npersons.add(new Person(5, \"name\" + 5, 55));\nboolean isAllAdult = persons.stream().allMatch(p -> p.getAge() > 18);\nSystem.out.println(\"All are adult? \" + isAllAdult);\nboolean isThereAnyChild = persons.stream().anyMatch(p -> p.getAge() < 12);\nSystem.out.println(\"Any child? \" + isThereAnyChild);\n```\n输出结果：\n```java\nAll are adult? false\nAny child? true\n```\n\n## 进阶：自己生成流\n\n### Stream.generate\n\n通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。\n\neg22. 生成 10 个随机整数\n```java\nRandom seed = new Random();\nSupplier<Integer> random = seed::nextInt;\nStream.generate(random).limit(10).forEach(System.out::println);\n//Another way\nIntStream.generate(() -> (int) (System.nanoTime() % 100)).\nlimit(10).forEach(System.out::println);\n```\n\nStream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。\n\neg23. 自实现 Supplier\n```java\nStream.generate(new PersonSupplier()).\n        limit(10).\n        forEach(p -> System.out.println(p.getName() + \", \" + p.getAge()));\nprivate class PersonSupplier implements Supplier<Person> {\n    private int index = 0;\n    private Random random = new Random();\n    @Override\n    public Person get() {\n        return new Person(index++, \"StormTestUser\" + index, random.nextInt(100));\n    }\n}\n```\n\n输出结果：\n```java\nStormTestUser1, 9\nStormTestUser2, 12\nStormTestUser3, 88\nStormTestUser4, 51\nStormTestUser5, 22\nStormTestUser6, 28\nStormTestUser7, 81\nStormTestUser8, 51\nStormTestUser9, 4\nStormTestUser10, 76\n```\n\n### Stream.iterate\n\niterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。\n\neg24. 生成一个等差数列\n```java\nStream.iterate(0, n -> n + 3).limit(10). forEach(x -> System.out.print(x + \" \"));\n```\n\n输出结果：\n```java\n0 3 6 9 12 15 18 21 24 27\n```\n\n与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。\n\n## 进阶：用 Collectors 来进行 reduction 操作\n\njava.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。\n\n### groupingBy/partitioningBy\n\neg25. 按照年龄归组\n```java\nMap<Integer, List<Person>> personGroups = Stream.generate(new PersonSupplier()).\n        limit(100).\n        collect(Collectors.groupingBy(Person::getAge));\nIterator it = personGroups.entrySet().iterator();\nwhile (it.hasNext()) {\n    Map.Entry<Integer, List<Person>> persons = (Map.Entry) it.next();\n    System.out.println(\"Age \" + persons.getKey() + \" = \" + persons.getValue().size());\n}\n```\n\n上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：\n\n```java\nAge 0 = 2\nAge 1 = 2\nAge 5 = 2\nAge 8 = 1\nAge 9 = 1\nAge 11 = 2\n……\n```\n\neg26. 按照未成年人和成年人归组\n```java\nMap<Boolean, List<Person>> children = Stream.generate(new PersonSupplier()).\n    limit(100).\n    collect(Collectors.partitioningBy(p -> p.getAge() < 18));\nSystem.out.println(\"Children number: \" + children.get(true).size());\nSystem.out.println(\"Adult number: \" + children.get(false).size());\n```\n\n输出结果：\n\n```java\nChildren number: 23 \nAdult number: 77\n```\n\n在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。\n\n# 结束语\n\n总之，Stream 的特性可以归纳为：\n\n* 不是数据结构\n    它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。\n\n    它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。\n\n* 所有 Stream 的操作必须以 lambda 表达式为参数\n\n* 不支持索引访问\n\n    你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。\n\n* 很容易生成数组或者 List\n\n* 惰性化\n\n    很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。\n\n    Intermediate 操作永远是惰性化的。\n\n* 并行能力\n\n    当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。\n\n* 可以是无限的\n\n    集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。","slug":"Stream","published":1,"updated":"2018-11-21T06:06:07.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0xiooa000juog4t8l3ysm6","content":"<blockquote>\n<p>最近在学习JAVA8 Stream的API，找到了这篇文章，觉得内容很好就抄了过来，文章来源：<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>\n</blockquote>\n<h1 id=\"为什么需要-Stream\"><a href=\"#为什么需要-Stream\" class=\"headerlink\" title=\"为什么需要 Stream\"></a>为什么需要 Stream</h1><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>\n<h2 id=\"什么是聚合操作\"><a href=\"#什么是聚合操作\" class=\"headerlink\" title=\"什么是聚合操作\"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p>\n<ul>\n<li>客户每月平均消费金额</li>\n<li>最昂贵的在售商品</li>\n<li>本周完成的有效订单（排除了无效的）</li>\n<li>取十个数据样本作为首页推荐</li>\n</ul>\n<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p>\n<p>eg1. Java 7 的排序、取值实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Transaction&gt; groceryTransactions = <span class=\"keyword\">new</span> Arraylist&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Transaction t : transactions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.getType() == Transaction.GROCERY) &#123;</span><br><span class=\"line\">        groceryTransactions.add(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Collections.sort(groceryTransactions, <span class=\"keyword\">new</span> Comparator() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Transaction t1, Transaction t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t2.getValue().compareTo(t1.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">List&lt;Integer&gt; transactionIds = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Transaction t : groceryTransactions) &#123;</span><br><span class=\"line\">    transactionsIds.add(t.getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p>\n<p>eg2. Java 8 的排序、取值实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; transactionsIds = transactions.parallelStream().</span><br><span class=\"line\">    filter(t -&gt; t.getType() == Transaction.GROCERY).</span><br><span class=\"line\">    sorted(comparing(Transaction::getValue).reversed()).</span><br><span class=\"line\">    map(Transaction::getId).</span><br><span class=\"line\">    collect(toList());</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Stream-总览\"><a href=\"#Stream-总览\" class=\"headerlink\" title=\"Stream 总览\"></a>Stream 总览</h1><h2 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>\n<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>\n<ol>\n<li>1.0-1.4 中的 java.lang.Thread</li>\n<li>5.0 中的 java.util.concurrent</li>\n<li>6.0 中的 Phasers 等</li>\n<li>7.0 中的 Fork/Join 框架</li>\n<li>8.0 中的 Lambda</li>\n</ol>\n<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>\n<h2 id=\"流的构成\"><a href=\"#流的构成\" class=\"headerlink\" title=\"流的构成\"></a>流的构成</h2><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>\n<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p>\n<p>流管道 (Stream Pipeline) 的构成</p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png\" alt=\"StreamPipeline-photo\"></p>\n<h3 id=\"有多种方式生成-Stream-Source：\"><a href=\"#有多种方式生成-Stream-Source：\" class=\"headerlink\" title=\"有多种方式生成 Stream Source：\"></a>有多种方式生成 Stream Source：</h3><h4 id=\"从-Collection-和数组\"><a href=\"#从-Collection-和数组\" class=\"headerlink\" title=\"从 Collection 和数组\"></a>从 Collection 和数组</h4><ul>\n<li>Collection.stream()</li>\n<li>Collection.parallelStream()</li>\n<li>Arrays.stream(T array) or Stream.of()</li>\n</ul>\n<h4 id=\"从-BufferedReader\"><a href=\"#从-BufferedReader\" class=\"headerlink\" title=\"从 BufferedReader\"></a>从 BufferedReader</h4><ul>\n<li>java.io.BufferedReader.lines()</li>\n</ul>\n<h4 id=\"静态工厂\"><a href=\"#静态工厂\" class=\"headerlink\" title=\"静态工厂\"></a>静态工厂</h4><ul>\n<li>java.util.stream.IntStream.range()</li>\n<li>java.nio.file.Files.walk()</li>\n</ul>\n<h4 id=\"自己构建\"><a href=\"#自己构建\" class=\"headerlink\" title=\"自己构建\"></a>自己构建</h4><ul>\n<li>java.util.Spliterator</li>\n</ul>\n<h4 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h4><ul>\n<li>Random.ints()</li>\n<li>BitSet.stream()</li>\n<li>Pattern.splitAsStream(java.lang.CharSequence)</li>\n<li>JarFile.stream()</li>\n</ul>\n<h3 id=\"流的操作类型分为两种：\"><a href=\"#流的操作类型分为两种：\" class=\"headerlink\" title=\"流的操作类型分为两种：\"></a>流的操作类型分为两种：</h3><ul>\n<li><p><strong><em>Intermediate</em></strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>\n</li>\n<li><p><strong><em>Terminal</em></strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>\n</li>\n</ul>\n<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>\n<p>还有一种操作被称为 <strong><em>short-circuiting</em></strong>。用以指：</p>\n<ul>\n<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>\n<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>\n</ul>\n<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>\n<p>eg3. 一个流操作的示例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = widgets.stream()</span><br><span class=\"line\">    .filter(w -&gt; w.getColor() == RED)</span><br><span class=\"line\">    .mapToInt(w -&gt; w.getWeight())</span><br><span class=\"line\">    .sum();</span><br></pre></td></tr></table></figure></p>\n<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p>\n<h1 id=\"流的使用详解\"><a href=\"#流的使用详解\" class=\"headerlink\" title=\"流的使用详解\"></a>流的使用详解</h1><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>\n<h2 id=\"流的构造与转换\"><a href=\"#流的构造与转换\" class=\"headerlink\" title=\"流的构造与转换\"></a>流的构造与转换</h2><p>下面提供最常见的几种构造 Stream 的样例。</p>\n<p>eg4. 构造流的几种常见方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Individual values</span></span><br><span class=\"line\">Stream stream = Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2. Arrays</span></span><br><span class=\"line\">String [] strArray = <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">stream = Stream.of(strArray);</span><br><span class=\"line\">stream = Arrays.stream(strArray);</span><br><span class=\"line\"><span class=\"comment\">// 3. Collections</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class=\"line\">stream = list.stream();</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p>\n<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p>\n<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p>\n<p>eg5. 数值流的构造<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntStream.of(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;).forEach(System.out::println);</span><br><span class=\"line\">IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>\n<p>eg6. 流转换为其它数据结构<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Array</span></span><br><span class=\"line\">String[] strArray1 = stream.toArray(String[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2. Collection</span></span><br><span class=\"line\">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class=\"line\">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class=\"keyword\">new</span>));</span><br><span class=\"line\">Set set1 = stream.collect(Collectors.toSet());</span><br><span class=\"line\">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class=\"keyword\">new</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3. String</span></span><br><span class=\"line\">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure></p>\n<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>\n<h2 id=\"流的操作\"><a href=\"#流的操作\" class=\"headerlink\" title=\"流的操作\"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>\n<ul>\n<li><p>Intermediate：</p>\n<p>  map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p>\n</li>\n<li><p>Terminal：</p>\n<p>  forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>\n</li>\n<li><p>Short-circuiting：</p>\n<p>  anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>\n</li>\n</ul>\n<h3 id=\"map-flatMap\"><a href=\"#map-flatMap\" class=\"headerlink\" title=\"map/flatMap\"></a>map/flatMap</h3><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>\n<p>eg7. 转换大写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = wordList.stream().</span><br><span class=\"line\">map(String::toUpperCase).</span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>这段代码把所有的单词转换为大写。</p>\n<p>eg8. 平方数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class=\"line\">map(n -&gt; n * n).</span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p>\n<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>\n<p>eg9. 一对多<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class=\"line\"> Arrays.asList(<span class=\"number\">1</span>),</span><br><span class=\"line\"> Arrays.asList(<span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> Arrays.asList(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"> );</span><br><span class=\"line\">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class=\"line\">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure></p>\n<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>\n<p>eg10. 留下偶数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] sixNums = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">Integer[] evens =</span><br><span class=\"line\">Stream.of(sixNums).filter(n -&gt; n%<span class=\"number\">2</span> == <span class=\"number\">0</span>).toArray(Integer[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure></p>\n<p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p>\n<p>eg11. 把单词挑出来<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = reader.lines().</span><br><span class=\"line\">    flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class=\"line\">    filter(word -&gt; word.length() &gt; <span class=\"number\">0</span>).</span><br><span class=\"line\">    collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p>\n<p>eg12. 打印姓名（forEach 和 pre-java8 的对比）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java 8</span></span><br><span class=\"line\">roster.stream()</span><br><span class=\"line\">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class=\"line\">    .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class=\"line\"><span class=\"comment\">// Pre-Java 8</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Person p : roster) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class=\"line\">        System.out.println(p.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p>\n<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>\n<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream.forEach(element -&gt; doOneThing(element));</span><br><span class=\"line\">stream.forEa</span><br><span class=\"line\">ch(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>\n<p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p>\n<p>eg13. peek 对每个元素执行操作并返回一个新的 Stream<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>, <span class=\"string\">\"three\"</span>, <span class=\"string\">\"four\"</span>)</span><br><span class=\"line\">    .filter(e -&gt; e.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">    .peek(e -&gt; System.out.println(<span class=\"string\">\"Filtered value: \"</span> + e))</span><br><span class=\"line\">    .map(String::toUpperCase)</span><br><span class=\"line\">    .peek(e -&gt; System.out.println(<span class=\"string\">\"Mapped value: \"</span> + e))</span><br><span class=\"line\">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>\n<h3 id=\"findFirst\"><a href=\"#findFirst\" class=\"headerlink\" title=\"findFirst\"></a>findFirst</h3><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>\n<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p>\n<p>eg14. Optional 的两个用例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String strA = <span class=\"string\">\" abcd \"</span>, strB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">print(strA);</span><br><span class=\"line\">print(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">print(strB);</span><br><span class=\"line\">getLength(strA);</span><br><span class=\"line\">getLength(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">getLength(strB);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Java 8</span></span><br><span class=\"line\">    Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class=\"line\">    <span class=\"comment\">// Pre-Java 8</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Java 8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(text).map(String::length).orElse(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Pre-Java 8</span></span><br><span class=\"line\">    <span class=\"comment\">// return if (text != null) ? text.length() : -1;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>\n<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p>\n<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p>\n<p>Integer sum = integers.reduce(0, Integer::sum);</p>\n<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>\n<p>eg15. reduce 的用例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串连接，concat = \"ABCD\"</span></span><br><span class=\"line\">String concat = Stream.of(<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>).reduce(<span class=\"string\">\"\"</span>, String::concat); </span><br><span class=\"line\"><span class=\"comment\">// 求最小值，minValue = -3.0</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> minValue = Stream.of(-<span class=\"number\">1.5</span>, <span class=\"number\">1.0</span>, -<span class=\"number\">3.0</span>, -<span class=\"number\">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class=\"line\"><span class=\"comment\">// 求和，sumValue = 10, 有起始值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sumValue = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\"><span class=\"comment\">// 求和，sumValue = 10, 无起始值</span></span><br><span class=\"line\">sumValue = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).reduce(Integer::sum).get();</span><br><span class=\"line\"><span class=\"comment\">// 过滤，字符串连接，concat = \"ace\"</span></span><br><span class=\"line\">concat = Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"F\"</span>).</span><br><span class=\"line\">    filter(x -&gt; x.compareTo(<span class=\"string\">\"Z\"</span>) &gt; <span class=\"number\">0</span>).</span><br><span class=\"line\">    reduce(<span class=\"string\">\"\"</span>, String::concat);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>\n<h3 id=\"limit-skip\"><a href=\"#limit-skip\" class=\"headerlink\" title=\"limit/skip\"></a>limit/skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>\n<p>eg16. limit 和 skip 对运行次数的影响<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLimitAndSkip</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">        Person person = <span class=\"keyword\">new</span> Person(i, <span class=\"string\">\"name\"</span> + i);</span><br><span class=\"line\">        persons.add(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;String&gt; personList2 = persons.stream().</span><br><span class=\"line\">            map(Person::getName).limit(<span class=\"number\">10</span>).skip(<span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(personList2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> no;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> no, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no = no;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果为：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name1</span><br><span class=\"line\">name2</span><br><span class=\"line\">name3</span><br><span class=\"line\">name4</span><br><span class=\"line\">name5</span><br><span class=\"line\">name6</span><br><span class=\"line\">name7</span><br><span class=\"line\">name8</span><br><span class=\"line\">name9</span><br><span class=\"line\">name10</span><br><span class=\"line\">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure></p>\n<p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p>\n<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p>\n<p>eg17. limit 和 skip 对 sorted 后的运行次数无影响<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    Person person = <span class=\"keyword\">new</span> Person(i, <span class=\"string\">\"name\"</span> + i);</span><br><span class=\"line\">    persons.add(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;</span><br><span class=\"line\">    p1.getName().compareTo(p2.getName())).limit(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure></p>\n<p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\">name1</span><br><span class=\"line\">name3</span><br><span class=\"line\">name2</span><br><span class=\"line\">name4</span><br><span class=\"line\">name3</span><br><span class=\"line\">name5</span><br><span class=\"line\">name4</span><br><span class=\"line\">[stream.StreamDW$Person@<span class=\"number\">816f</span>27d, stream.StreamDW$Person@<span class=\"number\">87</span>aac27]</span><br></pre></td></tr></table></figure></p>\n<p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p>\n<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p>\n<h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p>\n<p>eg18. 优化：排序前进行 limit 和 skip<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    Person person = <span class=\"keyword\">new</span> Person(i, <span class=\"string\">\"name\"</span> + i);</span><br><span class=\"line\">    persons.add(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().limit(<span class=\"number\">2</span>).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure></p>\n<p>结果会简单很多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\">name1</span><br><span class=\"line\">[stream.StreamDW$Person@<span class=\"number\">6</span>ce253f1, stream.StreamDW$Person@<span class=\"number\">53</span>d8d10a]</span><br></pre></td></tr></table></figure>\n<p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p>\n<h3 id=\"min-max-distinct\"><a href=\"#min-max-distinct\" class=\"headerlink\" title=\"min/max/distinct\"></a>min/max/distinct</h3><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p>\n<p>eg19. 找出最长一行的长度<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"c:\\\\SUService.log\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">int</span> longest = br.lines().</span><br><span class=\"line\">    mapToInt(String::length).</span><br><span class=\"line\">    max().</span><br><span class=\"line\">    getAsInt();</span><br><span class=\"line\">br.close();</span><br><span class=\"line\">System.out.println(longest);</span><br></pre></td></tr></table></figure></p>\n<p>下面的例子则使用 distinct 来找出不重复的单词。</p>\n<p>eg20. 找出全文的单词，转小写，并排序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; words = br.lines().</span><br><span class=\"line\">flatMap(line -&gt; Stream.of(line.split(<span class=\"string\">\" \"</span>))).</span><br><span class=\"line\">filter(word -&gt; word.length() &gt; <span class=\"number\">0</span>).</span><br><span class=\"line\">map(String::toLowerCase).</span><br><span class=\"line\">distinct().</span><br><span class=\"line\">sorted().</span><br><span class=\"line\">collect(Collectors.toList());</span><br><span class=\"line\">br.close();</span><br><span class=\"line\">System.out.println(words);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Match\"><a href=\"#Match\" class=\"headerlink\" title=\"Match\"></a>Match</h3><p>Stream 有三个 match 方法，从语义上说：</p>\n<ul>\n<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>\n<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>\n<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>\n</ul>\n<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p>\n<p>eg21. 使用 Match<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">1</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">1</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">2</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">2</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">3</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">3</span>, <span class=\"number\">34</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">4</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">4</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">5</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">5</span>, <span class=\"number\">55</span>));</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isAllAdult = persons.stream().allMatch(p -&gt; p.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"All are adult? \"</span> + isAllAdult);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isThereAnyChild = persons.stream().anyMatch(p -&gt; p.getAge() &lt; <span class=\"number\">12</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Any child? \"</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">All are adult? <span class=\"keyword\">false</span></span><br><span class=\"line\">Any child? <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"进阶：自己生成流\"><a href=\"#进阶：自己生成流\" class=\"headerlink\" title=\"进阶：自己生成流\"></a>进阶：自己生成流</h2><h3 id=\"Stream-generate\"><a href=\"#Stream-generate\" class=\"headerlink\" title=\"Stream.generate\"></a>Stream.generate</h3><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p>\n<p>eg22. 生成 10 个随机整数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random seed = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class=\"line\">Stream.generate(random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//Another way</span></span><br><span class=\"line\">IntStream.generate(() -&gt; (<span class=\"keyword\">int</span>) (System.nanoTime() % <span class=\"number\">100</span>)).</span><br><span class=\"line\">limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>\n<p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p>\n<p>eg23. 自实现 Supplier<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.generate(<span class=\"keyword\">new</span> PersonSupplier()).</span><br><span class=\"line\">        limit(<span class=\"number\">10</span>).</span><br><span class=\"line\">        forEach(p -&gt; System.out.println(p.getName() + <span class=\"string\">\", \"</span> + p.getAge()));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">Person</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(index++, <span class=\"string\">\"StormTestUser\"</span> + index, random.nextInt(<span class=\"number\">100</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormTestUser1, <span class=\"number\">9</span></span><br><span class=\"line\">StormTestUser2, <span class=\"number\">12</span></span><br><span class=\"line\">StormTestUser3, <span class=\"number\">88</span></span><br><span class=\"line\">StormTestUser4, <span class=\"number\">51</span></span><br><span class=\"line\">StormTestUser5, <span class=\"number\">22</span></span><br><span class=\"line\">StormTestUser6, <span class=\"number\">28</span></span><br><span class=\"line\">StormTestUser7, <span class=\"number\">81</span></span><br><span class=\"line\">StormTestUser8, <span class=\"number\">51</span></span><br><span class=\"line\">StormTestUser9, <span class=\"number\">4</span></span><br><span class=\"line\">StormTestUser10, <span class=\"number\">76</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Stream-iterate\"><a href=\"#Stream-iterate\" class=\"headerlink\" title=\"Stream.iterate\"></a>Stream.iterate</h3><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p>\n<p>eg24. 生成一个等差数列<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>, n -&gt; n + <span class=\"number\">3</span>).limit(<span class=\"number\">10</span>). forEach(x -&gt; System.out.print(x + <span class=\"string\">\" \"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">3</span> <span class=\"number\">6</span> <span class=\"number\">9</span> <span class=\"number\">12</span> <span class=\"number\">15</span> <span class=\"number\">18</span> <span class=\"number\">21</span> <span class=\"number\">24</span> <span class=\"number\">27</span></span><br></pre></td></tr></table></figure></p>\n<p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>\n<h2 id=\"进阶：用-Collectors-来进行-reduction-操作\"><a href=\"#进阶：用-Collectors-来进行-reduction-操作\" class=\"headerlink\" title=\"进阶：用 Collectors 来进行 reduction 操作\"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p>\n<h3 id=\"groupingBy-partitioningBy\"><a href=\"#groupingBy-partitioningBy\" class=\"headerlink\" title=\"groupingBy/partitioningBy\"></a>groupingBy/partitioningBy</h3><p>eg25. 按照年龄归组<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(<span class=\"keyword\">new</span> PersonSupplier()).</span><br><span class=\"line\">        limit(<span class=\"number\">100</span>).</span><br><span class=\"line\">        collect(Collectors.groupingBy(Person::getAge));</span><br><span class=\"line\">Iterator it = personGroups.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Age \"</span> + persons.getKey() + <span class=\"string\">\" = \"</span> + persons.getValue().size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Age <span class=\"number\">0</span> = <span class=\"number\">2</span></span><br><span class=\"line\">Age <span class=\"number\">1</span> = <span class=\"number\">2</span></span><br><span class=\"line\">Age <span class=\"number\">5</span> = <span class=\"number\">2</span></span><br><span class=\"line\">Age <span class=\"number\">8</span> = <span class=\"number\">1</span></span><br><span class=\"line\">Age <span class=\"number\">9</span> = <span class=\"number\">1</span></span><br><span class=\"line\">Age <span class=\"number\">11</span> = <span class=\"number\">2</span></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n<p>eg26. 按照未成年人和成年人归组<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(<span class=\"keyword\">new</span> PersonSupplier()).</span><br><span class=\"line\">    limit(<span class=\"number\">100</span>).</span><br><span class=\"line\">    collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; <span class=\"number\">18</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Children number: \"</span> + children.get(<span class=\"keyword\">true</span>).size());</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Adult number: \"</span> + children.get(<span class=\"keyword\">false</span>).size());</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Children number: <span class=\"number\">23</span> </span><br><span class=\"line\">Adult number: <span class=\"number\">77</span></span><br></pre></td></tr></table></figure>\n<p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p>\n<h1 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h1><p>总之，Stream 的特性可以归纳为：</p>\n<ul>\n<li><p>不是数据结构<br>  它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p>\n<p>  它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p>\n</li>\n<li><p>所有 Stream 的操作必须以 lambda 表达式为参数</p>\n</li>\n<li><p>不支持索引访问</p>\n<p>  你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</p>\n</li>\n<li><p>很容易生成数组或者 List</p>\n</li>\n<li><p>惰性化</p>\n<p>  很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</p>\n<p>  Intermediate 操作永远是惰性化的。</p>\n</li>\n<li><p>并行能力</p>\n<p>  当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</p>\n</li>\n<li><p>可以是无限的</p>\n<p>  集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近在学习JAVA8 Stream的API，找到了这篇文章，觉得内容很好就抄了过来，文章来源：<a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>\n</blockquote>\n<h1 id=\"为什么需要-Stream\"><a href=\"#为什么需要-Stream\" class=\"headerlink\" title=\"为什么需要 Stream\"></a>为什么需要 Stream</h1><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>\n<h2 id=\"什么是聚合操作\"><a href=\"#什么是聚合操作\" class=\"headerlink\" title=\"什么是聚合操作\"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p>\n<ul>\n<li>客户每月平均消费金额</li>\n<li>最昂贵的在售商品</li>\n<li>本周完成的有效订单（排除了无效的）</li>\n<li>取十个数据样本作为首页推荐</li>\n</ul>\n<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p>\n<p>eg1. Java 7 的排序、取值实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Transaction&gt; groceryTransactions = <span class=\"keyword\">new</span> Arraylist&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Transaction t : transactions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.getType() == Transaction.GROCERY) &#123;</span><br><span class=\"line\">        groceryTransactions.add(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Collections.sort(groceryTransactions, <span class=\"keyword\">new</span> Comparator() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Transaction t1, Transaction t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t2.getValue().compareTo(t1.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">List&lt;Integer&gt; transactionIds = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Transaction t : groceryTransactions) &#123;</span><br><span class=\"line\">    transactionsIds.add(t.getId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p>\n<p>eg2. Java 8 的排序、取值实现<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; transactionsIds = transactions.parallelStream().</span><br><span class=\"line\">    filter(t -&gt; t.getType() == Transaction.GROCERY).</span><br><span class=\"line\">    sorted(comparing(Transaction::getValue).reversed()).</span><br><span class=\"line\">    map(Transaction::getId).</span><br><span class=\"line\">    collect(toList());</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Stream-总览\"><a href=\"#Stream-总览\" class=\"headerlink\" title=\"Stream 总览\"></a>Stream 总览</h1><h2 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>\n<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>\n<ol>\n<li>1.0-1.4 中的 java.lang.Thread</li>\n<li>5.0 中的 java.util.concurrent</li>\n<li>6.0 中的 Phasers 等</li>\n<li>7.0 中的 Fork/Join 框架</li>\n<li>8.0 中的 Lambda</li>\n</ol>\n<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>\n<h2 id=\"流的构成\"><a href=\"#流的构成\" class=\"headerlink\" title=\"流的构成\"></a>流的构成</h2><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>\n<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p>\n<p>流管道 (Stream Pipeline) 的构成</p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png\" alt=\"StreamPipeline-photo\"></p>\n<h3 id=\"有多种方式生成-Stream-Source：\"><a href=\"#有多种方式生成-Stream-Source：\" class=\"headerlink\" title=\"有多种方式生成 Stream Source：\"></a>有多种方式生成 Stream Source：</h3><h4 id=\"从-Collection-和数组\"><a href=\"#从-Collection-和数组\" class=\"headerlink\" title=\"从 Collection 和数组\"></a>从 Collection 和数组</h4><ul>\n<li>Collection.stream()</li>\n<li>Collection.parallelStream()</li>\n<li>Arrays.stream(T array) or Stream.of()</li>\n</ul>\n<h4 id=\"从-BufferedReader\"><a href=\"#从-BufferedReader\" class=\"headerlink\" title=\"从 BufferedReader\"></a>从 BufferedReader</h4><ul>\n<li>java.io.BufferedReader.lines()</li>\n</ul>\n<h4 id=\"静态工厂\"><a href=\"#静态工厂\" class=\"headerlink\" title=\"静态工厂\"></a>静态工厂</h4><ul>\n<li>java.util.stream.IntStream.range()</li>\n<li>java.nio.file.Files.walk()</li>\n</ul>\n<h4 id=\"自己构建\"><a href=\"#自己构建\" class=\"headerlink\" title=\"自己构建\"></a>自己构建</h4><ul>\n<li>java.util.Spliterator</li>\n</ul>\n<h4 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h4><ul>\n<li>Random.ints()</li>\n<li>BitSet.stream()</li>\n<li>Pattern.splitAsStream(java.lang.CharSequence)</li>\n<li>JarFile.stream()</li>\n</ul>\n<h3 id=\"流的操作类型分为两种：\"><a href=\"#流的操作类型分为两种：\" class=\"headerlink\" title=\"流的操作类型分为两种：\"></a>流的操作类型分为两种：</h3><ul>\n<li><p><strong><em>Intermediate</em></strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>\n</li>\n<li><p><strong><em>Terminal</em></strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>\n</li>\n</ul>\n<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>\n<p>还有一种操作被称为 <strong><em>short-circuiting</em></strong>。用以指：</p>\n<ul>\n<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>\n<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>\n</ul>\n<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>\n<p>eg3. 一个流操作的示例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum = widgets.stream()</span><br><span class=\"line\">    .filter(w -&gt; w.getColor() == RED)</span><br><span class=\"line\">    .mapToInt(w -&gt; w.getWeight())</span><br><span class=\"line\">    .sum();</span><br></pre></td></tr></table></figure></p>\n<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p>\n<h1 id=\"流的使用详解\"><a href=\"#流的使用详解\" class=\"headerlink\" title=\"流的使用详解\"></a>流的使用详解</h1><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>\n<h2 id=\"流的构造与转换\"><a href=\"#流的构造与转换\" class=\"headerlink\" title=\"流的构造与转换\"></a>流的构造与转换</h2><p>下面提供最常见的几种构造 Stream 的样例。</p>\n<p>eg4. 构造流的几种常见方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Individual values</span></span><br><span class=\"line\">Stream stream = Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2. Arrays</span></span><br><span class=\"line\">String [] strArray = <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">stream = Stream.of(strArray);</span><br><span class=\"line\">stream = Arrays.stream(strArray);</span><br><span class=\"line\"><span class=\"comment\">// 3. Collections</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class=\"line\">stream = list.stream();</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p>\n<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p>\n<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p>\n<p>eg5. 数值流的构造<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntStream.of(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;).forEach(System.out::println);</span><br><span class=\"line\">IntStream.range(<span class=\"number\">1</span>, <span class=\"number\">3</span>).forEach(System.out::println);</span><br><span class=\"line\">IntStream.rangeClosed(<span class=\"number\">1</span>, <span class=\"number\">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>\n<p>eg6. 流转换为其它数据结构<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. Array</span></span><br><span class=\"line\">String[] strArray1 = stream.toArray(String[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\"><span class=\"comment\">// 2. Collection</span></span><br><span class=\"line\">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class=\"line\">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class=\"keyword\">new</span>));</span><br><span class=\"line\">Set set1 = stream.collect(Collectors.toSet());</span><br><span class=\"line\">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class=\"keyword\">new</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3. String</span></span><br><span class=\"line\">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure></p>\n<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>\n<h2 id=\"流的操作\"><a href=\"#流的操作\" class=\"headerlink\" title=\"流的操作\"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>\n<ul>\n<li><p>Intermediate：</p>\n<p>  map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p>\n</li>\n<li><p>Terminal：</p>\n<p>  forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>\n</li>\n<li><p>Short-circuiting：</p>\n<p>  anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>\n</li>\n</ul>\n<h3 id=\"map-flatMap\"><a href=\"#map-flatMap\" class=\"headerlink\" title=\"map/flatMap\"></a>map/flatMap</h3><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>\n<p>eg7. 转换大写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = wordList.stream().</span><br><span class=\"line\">map(String::toUpperCase).</span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>这段代码把所有的单词转换为大写。</p>\n<p>eg8. 平方数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class=\"line\">map(n -&gt; n * n).</span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p>\n<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>\n<p>eg9. 一对多<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class=\"line\"> Arrays.asList(<span class=\"number\">1</span>),</span><br><span class=\"line\"> Arrays.asList(<span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> Arrays.asList(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"> );</span><br><span class=\"line\">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class=\"line\">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure></p>\n<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>\n<p>eg10. 留下偶数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] sixNums = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">Integer[] evens =</span><br><span class=\"line\">Stream.of(sixNums).filter(n -&gt; n%<span class=\"number\">2</span> == <span class=\"number\">0</span>).toArray(Integer[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure></p>\n<p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p>\n<p>eg11. 把单词挑出来<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = reader.lines().</span><br><span class=\"line\">    flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class=\"line\">    filter(word -&gt; word.length() &gt; <span class=\"number\">0</span>).</span><br><span class=\"line\">    collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p>\n<p>eg12. 打印姓名（forEach 和 pre-java8 的对比）<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java 8</span></span><br><span class=\"line\">roster.stream()</span><br><span class=\"line\">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class=\"line\">    .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class=\"line\"><span class=\"comment\">// Pre-Java 8</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Person p : roster) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class=\"line\">        System.out.println(p.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p>\n<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>\n<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream.forEach(element -&gt; doOneThing(element));</span><br><span class=\"line\">stream.forEa</span><br><span class=\"line\">ch(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>\n<p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p>\n<p>eg13. peek 对每个元素执行操作并返回一个新的 Stream<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">\"one\"</span>, <span class=\"string\">\"two\"</span>, <span class=\"string\">\"three\"</span>, <span class=\"string\">\"four\"</span>)</span><br><span class=\"line\">    .filter(e -&gt; e.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">    .peek(e -&gt; System.out.println(<span class=\"string\">\"Filtered value: \"</span> + e))</span><br><span class=\"line\">    .map(String::toUpperCase)</span><br><span class=\"line\">    .peek(e -&gt; System.out.println(<span class=\"string\">\"Mapped value: \"</span> + e))</span><br><span class=\"line\">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>\n<p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>\n<h3 id=\"findFirst\"><a href=\"#findFirst\" class=\"headerlink\" title=\"findFirst\"></a>findFirst</h3><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>\n<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p>\n<p>eg14. Optional 的两个用例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String strA = <span class=\"string\">\" abcd \"</span>, strB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">print(strA);</span><br><span class=\"line\">print(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">print(strB);</span><br><span class=\"line\">getLength(strA);</span><br><span class=\"line\">getLength(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">getLength(strB);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Java 8</span></span><br><span class=\"line\">    Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class=\"line\">    <span class=\"comment\">// Pre-Java 8</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getLength</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Java 8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Optional.ofNullable(text).map(String::length).orElse(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Pre-Java 8</span></span><br><span class=\"line\">    <span class=\"comment\">// return if (text != null) ? text.length() : -1;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>\n<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h3><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p>\n<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p>\n<p>Integer sum = integers.reduce(0, Integer::sum);</p>\n<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>\n<p>eg15. reduce 的用例<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串连接，concat = \"ABCD\"</span></span><br><span class=\"line\">String concat = Stream.of(<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>).reduce(<span class=\"string\">\"\"</span>, String::concat); </span><br><span class=\"line\"><span class=\"comment\">// 求最小值，minValue = -3.0</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> minValue = Stream.of(-<span class=\"number\">1.5</span>, <span class=\"number\">1.0</span>, -<span class=\"number\">3.0</span>, -<span class=\"number\">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class=\"line\"><span class=\"comment\">// 求和，sumValue = 10, 有起始值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sumValue = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\"><span class=\"comment\">// 求和，sumValue = 10, 无起始值</span></span><br><span class=\"line\">sumValue = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>).reduce(Integer::sum).get();</span><br><span class=\"line\"><span class=\"comment\">// 过滤，字符串连接，concat = \"ace\"</span></span><br><span class=\"line\">concat = Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"F\"</span>).</span><br><span class=\"line\">    filter(x -&gt; x.compareTo(<span class=\"string\">\"Z\"</span>) &gt; <span class=\"number\">0</span>).</span><br><span class=\"line\">    reduce(<span class=\"string\">\"\"</span>, String::concat);</span><br></pre></td></tr></table></figure></p>\n<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>\n<h3 id=\"limit-skip\"><a href=\"#limit-skip\" class=\"headerlink\" title=\"limit/skip\"></a>limit/skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>\n<p>eg16. limit 和 skip 对运行次数的影响<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLimitAndSkip</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">        Person person = <span class=\"keyword\">new</span> Person(i, <span class=\"string\">\"name\"</span> + i);</span><br><span class=\"line\">        persons.add(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;String&gt; personList2 = persons.stream().</span><br><span class=\"line\">            map(Person::getName).limit(<span class=\"number\">10</span>).skip(<span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(personList2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> no;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">int</span> no, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.no = no;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果为：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name1</span><br><span class=\"line\">name2</span><br><span class=\"line\">name3</span><br><span class=\"line\">name4</span><br><span class=\"line\">name5</span><br><span class=\"line\">name6</span><br><span class=\"line\">name7</span><br><span class=\"line\">name8</span><br><span class=\"line\">name9</span><br><span class=\"line\">name10</span><br><span class=\"line\">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure></p>\n<p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p>\n<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p>\n<p>eg17. limit 和 skip 对 sorted 后的运行次数无影响<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    Person person = <span class=\"keyword\">new</span> Person(i, <span class=\"string\">\"name\"</span> + i);</span><br><span class=\"line\">    persons.add(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;</span><br><span class=\"line\">    p1.getName().compareTo(p2.getName())).limit(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure></p>\n<p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\">name1</span><br><span class=\"line\">name3</span><br><span class=\"line\">name2</span><br><span class=\"line\">name4</span><br><span class=\"line\">name3</span><br><span class=\"line\">name5</span><br><span class=\"line\">name4</span><br><span class=\"line\">[stream.StreamDW$Person@<span class=\"number\">816f</span>27d, stream.StreamDW$Person@<span class=\"number\">87</span>aac27]</span><br></pre></td></tr></table></figure></p>\n<p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p>\n<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p>\n<h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p>\n<p>eg18. 优化：排序前进行 limit 和 skip<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    Person person = <span class=\"keyword\">new</span> Person(i, <span class=\"string\">\"name\"</span> + i);</span><br><span class=\"line\">    persons.add(person);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().limit(<span class=\"number\">2</span>).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure></p>\n<p>结果会简单很多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\">name1</span><br><span class=\"line\">[stream.StreamDW$Person@<span class=\"number\">6</span>ce253f1, stream.StreamDW$Person@<span class=\"number\">53</span>d8d10a]</span><br></pre></td></tr></table></figure>\n<p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p>\n<h3 id=\"min-max-distinct\"><a href=\"#min-max-distinct\" class=\"headerlink\" title=\"min/max/distinct\"></a>min/max/distinct</h3><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p>\n<p>eg19. 找出最长一行的长度<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"c:\\\\SUService.log\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">int</span> longest = br.lines().</span><br><span class=\"line\">    mapToInt(String::length).</span><br><span class=\"line\">    max().</span><br><span class=\"line\">    getAsInt();</span><br><span class=\"line\">br.close();</span><br><span class=\"line\">System.out.println(longest);</span><br></pre></td></tr></table></figure></p>\n<p>下面的例子则使用 distinct 来找出不重复的单词。</p>\n<p>eg20. 找出全文的单词，转小写，并排序<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; words = br.lines().</span><br><span class=\"line\">flatMap(line -&gt; Stream.of(line.split(<span class=\"string\">\" \"</span>))).</span><br><span class=\"line\">filter(word -&gt; word.length() &gt; <span class=\"number\">0</span>).</span><br><span class=\"line\">map(String::toLowerCase).</span><br><span class=\"line\">distinct().</span><br><span class=\"line\">sorted().</span><br><span class=\"line\">collect(Collectors.toList());</span><br><span class=\"line\">br.close();</span><br><span class=\"line\">System.out.println(words);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Match\"><a href=\"#Match\" class=\"headerlink\" title=\"Match\"></a>Match</h3><p>Stream 有三个 match 方法，从语义上说：</p>\n<ul>\n<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>\n<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>\n<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>\n</ul>\n<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p>\n<p>eg21. 使用 Match<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">1</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">1</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">2</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">2</span>, <span class=\"number\">21</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">3</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">3</span>, <span class=\"number\">34</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">4</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">4</span>, <span class=\"number\">6</span>));</span><br><span class=\"line\">persons.add(<span class=\"keyword\">new</span> Person(<span class=\"number\">5</span>, <span class=\"string\">\"name\"</span> + <span class=\"number\">5</span>, <span class=\"number\">55</span>));</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isAllAdult = persons.stream().allMatch(p -&gt; p.getAge() &gt; <span class=\"number\">18</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"All are adult? \"</span> + isAllAdult);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isThereAnyChild = persons.stream().anyMatch(p -&gt; p.getAge() &lt; <span class=\"number\">12</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Any child? \"</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">All are adult? <span class=\"keyword\">false</span></span><br><span class=\"line\">Any child? <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"进阶：自己生成流\"><a href=\"#进阶：自己生成流\" class=\"headerlink\" title=\"进阶：自己生成流\"></a>进阶：自己生成流</h2><h3 id=\"Stream-generate\"><a href=\"#Stream-generate\" class=\"headerlink\" title=\"Stream.generate\"></a>Stream.generate</h3><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p>\n<p>eg22. 生成 10 个随机整数<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random seed = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class=\"line\">Stream.generate(random).limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//Another way</span></span><br><span class=\"line\">IntStream.generate(() -&gt; (<span class=\"keyword\">int</span>) (System.nanoTime() % <span class=\"number\">100</span>)).</span><br><span class=\"line\">limit(<span class=\"number\">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>\n<p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p>\n<p>eg23. 自实现 Supplier<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.generate(<span class=\"keyword\">new</span> PersonSupplier()).</span><br><span class=\"line\">        limit(<span class=\"number\">10</span>).</span><br><span class=\"line\">        forEach(p -&gt; System.out.println(p.getName() + <span class=\"string\">\", \"</span> + p.getAge()));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">Person</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Person <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Person(index++, <span class=\"string\">\"StormTestUser\"</span> + index, random.nextInt(<span class=\"number\">100</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormTestUser1, <span class=\"number\">9</span></span><br><span class=\"line\">StormTestUser2, <span class=\"number\">12</span></span><br><span class=\"line\">StormTestUser3, <span class=\"number\">88</span></span><br><span class=\"line\">StormTestUser4, <span class=\"number\">51</span></span><br><span class=\"line\">StormTestUser5, <span class=\"number\">22</span></span><br><span class=\"line\">StormTestUser6, <span class=\"number\">28</span></span><br><span class=\"line\">StormTestUser7, <span class=\"number\">81</span></span><br><span class=\"line\">StormTestUser8, <span class=\"number\">51</span></span><br><span class=\"line\">StormTestUser9, <span class=\"number\">4</span></span><br><span class=\"line\">StormTestUser10, <span class=\"number\">76</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Stream-iterate\"><a href=\"#Stream-iterate\" class=\"headerlink\" title=\"Stream.iterate\"></a>Stream.iterate</h3><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p>\n<p>eg24. 生成一个等差数列<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.iterate(<span class=\"number\">0</span>, n -&gt; n + <span class=\"number\">3</span>).limit(<span class=\"number\">10</span>). forEach(x -&gt; System.out.print(x + <span class=\"string\">\" \"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">3</span> <span class=\"number\">6</span> <span class=\"number\">9</span> <span class=\"number\">12</span> <span class=\"number\">15</span> <span class=\"number\">18</span> <span class=\"number\">21</span> <span class=\"number\">24</span> <span class=\"number\">27</span></span><br></pre></td></tr></table></figure></p>\n<p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>\n<h2 id=\"进阶：用-Collectors-来进行-reduction-操作\"><a href=\"#进阶：用-Collectors-来进行-reduction-操作\" class=\"headerlink\" title=\"进阶：用 Collectors 来进行 reduction 操作\"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p>\n<h3 id=\"groupingBy-partitioningBy\"><a href=\"#groupingBy-partitioningBy\" class=\"headerlink\" title=\"groupingBy/partitioningBy\"></a>groupingBy/partitioningBy</h3><p>eg25. 按照年龄归组<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(<span class=\"keyword\">new</span> PersonSupplier()).</span><br><span class=\"line\">        limit(<span class=\"number\">100</span>).</span><br><span class=\"line\">        collect(Collectors.groupingBy(Person::getAge));</span><br><span class=\"line\">Iterator it = personGroups.entrySet().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Age \"</span> + persons.getKey() + <span class=\"string\">\" = \"</span> + persons.getValue().size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Age <span class=\"number\">0</span> = <span class=\"number\">2</span></span><br><span class=\"line\">Age <span class=\"number\">1</span> = <span class=\"number\">2</span></span><br><span class=\"line\">Age <span class=\"number\">5</span> = <span class=\"number\">2</span></span><br><span class=\"line\">Age <span class=\"number\">8</span> = <span class=\"number\">1</span></span><br><span class=\"line\">Age <span class=\"number\">9</span> = <span class=\"number\">1</span></span><br><span class=\"line\">Age <span class=\"number\">11</span> = <span class=\"number\">2</span></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n<p>eg26. 按照未成年人和成年人归组<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(<span class=\"keyword\">new</span> PersonSupplier()).</span><br><span class=\"line\">    limit(<span class=\"number\">100</span>).</span><br><span class=\"line\">    collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; <span class=\"number\">18</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Children number: \"</span> + children.get(<span class=\"keyword\">true</span>).size());</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"Adult number: \"</span> + children.get(<span class=\"keyword\">false</span>).size());</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Children number: <span class=\"number\">23</span> </span><br><span class=\"line\">Adult number: <span class=\"number\">77</span></span><br></pre></td></tr></table></figure>\n<p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p>\n<h1 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h1><p>总之，Stream 的特性可以归纳为：</p>\n<ul>\n<li><p>不是数据结构<br>  它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</p>\n<p>  它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</p>\n</li>\n<li><p>所有 Stream 的操作必须以 lambda 表达式为参数</p>\n</li>\n<li><p>不支持索引访问</p>\n<p>  你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</p>\n</li>\n<li><p>很容易生成数组或者 List</p>\n</li>\n<li><p>惰性化</p>\n<p>  很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</p>\n<p>  Intermediate 操作永远是惰性化的。</p>\n</li>\n<li><p>并行能力</p>\n<p>  当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</p>\n</li>\n<li><p>可以是无限的</p>\n<p>  集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjp0xiohd0000uog40u12vpsr","category_id":"cjp0xioho0003uog45bwicsbc","_id":"cjp0xiohw0008uog4kljs77mx"},{"post_id":"cjp0xiohl0002uog47kg0ik59","category_id":"cjp0xioho0003uog45bwicsbc","_id":"cjp0xiohy0009uog4nu9ialvj"},{"post_id":"cjp0xiohq0004uog47hs634lt","category_id":"cjp0xiohw0007uog47r08s68z","_id":"cjp0xioi1000buog4h6rvtw25"},{"post_id":"cjp0xiohs0005uog4xgj08d5b","category_id":"cjp0xiohw0007uog47r08s68z","_id":"cjp0xioi3000cuog4yd1amm8k"},{"post_id":"cjp0xiomc000duog4tjm8cwzk","category_id":"cjp0xiohw0007uog47r08s68z","_id":"cjp0xiome000fuog47rmqwql7"},{"post_id":"cjp0xiomd000euog4oh6jraft","category_id":"cjp0xioho0003uog45bwicsbc","_id":"cjp0xiomf000guog4ist06eak"},{"post_id":"cjp0xionw000huog4po20o7a5","category_id":"cjp0xiohw0007uog47r08s68z","_id":"cjp0xionz000iuog4uhz4x839"},{"post_id":"cjp0xiooa000juog4t8l3ysm6","category_id":"cjp0xiohw0007uog47r08s68z","_id":"cjp0xiooc000kuog4bk3em8ed"}],"PostTag":[],"Tag":[]}}